{"version":3,"sources":["webpack:///src/assets/js/face-api.js","webpack:///src/assets/js/faceDetectionControls.js"],"names":[],"mappings":"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GAAG,gDAAgD,gBAAgB,qDAAqD,GAAG,kCAAkC,gBAAgB,mDAAmD,GAAG,+FAA+F,gBAAgB,gEAAgE,eAAe,oJAAoJ,4GAA4G,eAAe,aAAa,KAAK,gEAAgE,6EAA6E,wEAAwE,WAAW,cAAc,GAAG,QAAQ,qBAAqB,gCAAgC,WAAW,oOAAoO,6CAA6C,6GAA6G,2CAA2C,0FAA0F,yCAAyC,GAAG,kCAAkC,QAAQ,oHAAoH,4BAA4B,qEAAqE,kCAAkC,YAAY,gCAAgC,qCAAqC,cAAc,yBAAyB,2BAA2B,4BAA4B,uDAAuD,+BAA+B,oHAAoH,0BAA0B,oHAAoH,4BAA4B,kGAAkG,8BAA8B,0IAA0I,yBAAyB,oDAAoD,GAAG,UAAU,8PAA8P,6IAA6I;;AAEx3+c;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,aAAa,EAAE;AACpC,0BAA0B,kBAAkB,EAAE;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,iCAAiC,kBAAkB;AACnD,kCAAkC,kBAAkB;AACpD;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,mDAAmD,iCAAiC,EAAE;AACtF;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,gCAAgC,uCAAuC,GAAG,oCAAoC;AAC9G,oBAAoB;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA,gCAAgC,uCAAuC,GAAG,oCAAoC;AAC9G;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,gCAAgC,gDAAgD,GAAG,gDAAgD,GAAG,oCAAoC;AAC1K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0IAA0I,+BAA+B;AACzK;AACA;AACA;AACA;AACA;AACA,8BAA8B,oBAAoB,EAAE;AACpD;AACA;AACA,SAAS;AACT;AACA,8BAA8B,qBAAqB,EAAE;AACrD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gBAAgB,EAAE;AAChD;AACA;AACA,SAAS;AACT;AACA,8BAA8B,gBAAgB,EAAE;AAChD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,UAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,oBAAoB,EAAE;AACpE;AACA;AACA;AACA,uDAAuD,8BAA8B,EAAE;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,oEAAoE;AACpG;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,UAAU,EAAE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;;AAEA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;;AAEA;AACA;AACA,oDAAoD,OAAO;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACrG,sCAAsC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACxG,mCAAmC,iEAAiE,uBAAuB,EAAE,4BAA4B;AACzJ;AACA,SAAS;AACT;;AAEA;AACA,iBAAiB,6BAA6B,0BAA0B,aAAa,EAAE,qBAAqB;AAC5G,oBAAoB,qDAAqD,oEAAoE,aAAa,EAAE;AAC5J,0BAA0B,sBAAsB,qBAAqB,GAAG;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,sCAAsC,SAAS;AAC/C,sCAAsC,WAAW,UAAU;AAC3D,6CAA6C,cAAc;AAC3D;AACA,iHAAiH,OAAO,UAAU;AAClI,oFAAoF,iBAAiB,OAAO;AAC5G,4DAA4D,gBAAgB,QAAQ,OAAO;AAC3F,kDAAkD,gBAAgB,gBAAgB,OAAO;AACzF;AACA,qCAAqC;AACrC;AACA;AACA,aAAa,YAAY,aAAa,OAAO,EAAE,UAAU,WAAW;AACpE,uCAAuC,SAAS;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACA,qDAAqD,iCAAiC;AACtF,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,2CAA2C;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,iCAAiC;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gBAAgB,EAAE;AAChD;AACA;AACA,SAAS;AACT;AACA,8BAA8B,gBAAgB,EAAE;AAChD;AACA;AACA,SAAS;AACT;AACA,8BAA8B,oBAAoB,EAAE;AACpD;AACA;AACA,SAAS;AACT;AACA,8BAA8B,qBAAqB,EAAE;AACrD;AACA;AACA,SAAS;AACT;AACA,8BAA8B,eAAe,EAAE;AAC/C;AACA;AACA,SAAS;AACT;AACA,8BAA8B,eAAe,EAAE;AAC/C;AACA;AACA,SAAS;AACT;AACA,8BAA8B,4BAA4B,EAAE;AAC5D;AACA;AACA,SAAS;AACT;AACA,8BAA8B,6BAA6B,EAAE;AAC7D;AACA;AACA,SAAS;AACT;AACA,8BAA8B,iCAAiC,EAAE;AACjE;AACA;AACA,SAAS;AACT;AACA;AACA,qCAAqC,wBAAwB,EAAE;AAC/D,4BAA4B,2CAA2C;AACvE;AACA;AACA;AACA,qCAAqC,wBAAwB,EAAE;AAC/D,4BAA4B,2CAA2C;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2CAA2C;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2CAA2C;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uEAAuE;AACpG;AACA;AACA;AACA;AACA;AACA,4BAA4B,2CAA2C;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,sCAAsC,qDAAqD;AAC3F;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oBAAoB,EAAE;AACpD;AACA;AACA,SAAS;AACT;AACA,8BAA8B,yBAAyB,EAAE;AACzD;AACA;AACA,SAAS;AACT;AACA,8BAA8B,wBAAwB,EAAE;AACxD;AACA;AACA,SAAS;AACT;AACA,8BAA8B,kBAAkB,EAAE;AAClD;AACA;AACA,SAAS;AACT;AACA,8BAA8B,wBAAwB,EAAE;AACxD;AACA;AACA,SAAS;AACT;AACA,8BAA8B,6BAA6B,EAAE;AAC7D;AACA;AACA,SAAS;AACT;AACA,8BAA8B,8BAA8B,EAAE;AAC9D;AACA;AACA,SAAS;AACT;AACA,8BAA8B,6DAA6D,EAAE;AAC7F;AACA;AACA,SAAS;AACT;AACA,uGAAuG,+BAA+B;AACtI;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,yCAAyC,EAAE;AACzF,6CAA6C,sCAAsC,EAAE;AACrF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA,0BAA0B;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF,qBAAqB,EAAE;AAC5G,mFAAmF,oBAAoB,EAAE;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,qBAAqB;AAC/D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,+BAA+B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC,cAAc;AAC/C,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,+EAA+E;AAC/E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mBAAmB,EAAE;AACnD;AACA;AACA,SAAS;AACT;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oBAAoB,EAAE;AACpD;AACA;AACA,SAAS;AACT;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oBAAoB,EAAE;AACpD;AACA;AACA,SAAS;AACT;AACA,8BAA8B,yBAAyB,EAAE;AACzD;AACA;AACA,SAAS;AACT;AACA,KAAK;;AAEL;AACA,iCAAiC,cAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,2DAA2D,EAAE;AACrH;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA,qCAAqC,qBAAqB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,sCAAsC;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,uBAAuB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,YAAY,EAAE;AACpD,mCAAmC,oBAAoB,EAAE;AACzD;AACA,SAAS;AACT;;AAEA;AACA;AACA,+CAA+C,2BAA2B;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,iFAAiF,mDAAmD,EAAE;AACtI,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,+BAA+B;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,uBAAuB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,uEAAuE,oBAAoB,EAAE;AAC7F;AACA,aAAa;AACb;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,oEAAoE;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,0FAA0F,yDAAyD,EAAE;AACrJ;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,qBAAqB,EAAE;AACrD;AACA;AACA,SAAS;AACT;AACA,8BAA8B,4BAA4B,EAAE;AAC5D;AACA;AACA,SAAS;AACT;AACA,8BAA8B,sBAAsB,EAAE;AACtD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,gEAAgE,yCAAyC,EAAE;AAC3G;AACA;AACA,gEAAgE,4CAA4C,EAAE;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,8CAA8C,yBAAyB;AACvE;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,8CAA8C,yBAAyB,EAAE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,uDAAuD,gDAAgD,mBAAmB,EAAE,EAAE,EAAE,GAAG;AAC5M;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,aAAa,GAAG,uBAAuB;AACvC;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,KAAK;;AAEL;AACA,+BAA+B,cAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,cAAc;AAC7C;AACA,6CAA6C,UAAU,mCAAmC,EAAE,EAAE;AAC9F,qCAAqC,4BAA4B,EAAE;AACnE,+BAA+B,mBAAmB,EAAE;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oBAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA,gFAAgF,mCAAmC,EAAE;AACrH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,sCAAsC,OAAO;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC,gCAAgC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,8BAA8B,EAAE;AACnF;AACA;AACA;AACA;AACA,iDAAiD,gBAAgB,EAAE,sBAAsB,2CAA2C,EAAE;AACtI,mEAAmE,uBAAuB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mCAAmC,GAAG,uCAAuC;AAC7G,oBAAoB;AACpB;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,gDAAgD;AACrD;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,wBAAwB,EAAE;AACxD;AACA;AACA,SAAS;AACT;AACA,8BAA8B,6BAA6B,EAAE;AAC7D;AACA;AACA,SAAS;AACT;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,2CAA2C,oBAAoB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,qCAAqC,EAAE;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,gBAAgB,EAAE;AAClF,iEAAiE,kBAAkB,EAAE;AACrF,sEAAsE,uBAAuB,EAAE;AAC/F,qEAAqE,wCAAwC,EAAE;AAC/G,oFAAoF,+BAA+B,EAAE;AACrH;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,6BAA6B,gBAAgB;AAC7C,iCAAiC,gBAAgB;AACjD,wCAAwC,mBAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA,mCAAmC,0BAA0B;AAC7D,qDAAqD,oHAAoH;AACzK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,+CAA+C,EAAE;AACvF,mDAAmD;AACnD;AACA;AACA,aAAa,EAAE,EAAE;AACjB,iDAAiD,4DAA4D,EAAE;AAC/G;AACA;AACA;AACA;AACA;AACA,KAAK;;;;AAIL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,2BAA2B,EAAE;AAChE;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,sCAAsC,2CAA2C;AACjF;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,yBAAyB;AAC5D;AACA;AACA;AACA,+EAA+E,oDAAoD,EAAE;AACrI;AACA;AACA,8BAA8B,gDAAgD,EAAE;AAChF;AACA;AACA,SAAS;AACT;AACA,8BAA8B,4BAA4B,EAAE;AAC5D;AACA;AACA,SAAS;AACT;AACA,8BAA8B,6BAA6B,EAAE;AAC7D;AACA;AACA,SAAS;AACT;AACA,8BAA8B,wBAAwB,EAAE;AACxD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0DAA0D,iFAAiF,EAAE;AAC7I,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA,iEAAiE,+BAA+B;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,wCAAwC;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oBAAoB,EAAE;AACpD;AACA;AACA,SAAS;AACT;AACA,8BAA8B,uBAAuB,EAAE;AACvD;AACA;AACA,SAAS;AACT;AACA,0CAA0C,qBAAqB;AAC/D;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,iFAAiF,wCAAwC,EAAE;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oBAAoB,EAAE;AACpD;AACA;AACA,SAAS;AACT;AACA,8BAA8B,0BAA0B,EAAE;AAC1D;AACA;AACA,SAAS;AACT;AACA,KAAK;;AAEL;AACA,kCAAkC,kBAAkB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sFAAsF;AACtF,uCAAuC,mBAAmB,gBAAgB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,6EAA6E,EAAE;AACtI,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,sFAAsF;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,sCAAsC,EAAE;AACnG,kEAAkE,yCAAyC,EAAE;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA,kCAAkC,EAAE;AACpC,iDAAiD,4DAA4D,EAAE;AAC/G;AACA;AACA,4DAA4D,+BAA+B;AAC3F;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA,kCAAkC,EAAE;AACpC,iDAAiD,oDAAoD,EAAE;AACvG;AACA;AACA;AACA,yBAAyB;AACzB;AACA,qBAAqB;AACrB,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,sCAAsC,sBAAsB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,sCAAsC,sBAAsB;AAC5D,qCAAqC,oBAAoB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gDAAgD,GAAG,gDAAgD,GAAG,oCAAoC;AAC1K;AACA;AACA;AACA;AACA,0CAA0C,sBAAsB;AAChE;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,0CAA0C,sBAAsB;AAChE;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,sBAAsB;AAChE;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,0CAA0C,sBAAsB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,8CAA8C,yBAAyB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kDAAkD,mDAAmD;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,UAAU,uFAAuF,EAAE,EAAE;AACjJ;AACA;AACA;AACA,qCAAqC,qCAAqC,EAAE;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,iCAAiC,EAAE,EAAE;AACrC;AACA;AACA;AACA;AACA,8DAA8D,2DAA2D,EAAE;AAC3H;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,8CAA8C,cAAc,EAAE,EAAE;AACvH,uDAAuD,8CAA8C,cAAc,EAAE,EAAE;AACvH;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,+BAA+B;AAC5D,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,8CAA8C,EAAE;AAChH,sHAAsH;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iGAAiG,oBAAoB,EAAE;AACvH,iGAAiG,qBAAqB,EAAE;AACxH,iIAAiI,0CAA0C,EAAE;AAC7K;AACA;AACA,qDAAqD;AACrD;AACA,qCAAqC;AACrC,iCAAiC,EAAE,EAAE;AACrC;AACA;AACA,kEAAkE,oBAAoB,EAAE;AACxF;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,kDAAkD,mDAAmD;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,kDAAkD,uDAAuD;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA,iCAAiC,kBAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,gGAAgG,EAAE;AACvI;AACA;AACA;AACA;AACA,gCAAgC,uCAAuC,GAAG,oCAAoC;AAC9G,oBAAoB;AACpB;AACA;AACA;AACA;AACA,gCAAgC,uCAAuC,GAAG,sCAAsC;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,oCAAoC,gBAAgB;AACpD;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,2EAA2E,EAAE;AAChH,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ,+BAA+B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sCAAsC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,8CAA8C,EAAE;AACtH,qGAAqG,iBAAiB,EAAE;AACxH;AACA;AACA,wEAAwE,oBAAoB,EAAE;AAC9F;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB;AACzB,+BAA+B;AAC/B;;AAEA;AACA,yBAAyB;AACzB,+BAA+B;AAC/B;;AAEA;AACA,yBAAyB;AACzB,+BAA+B;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;;AAEA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,+BAA+B,EAAE;AAC9F;AACA;AACA;AACA,6FAA6F,+BAA+B,EAAE;AAC9H;AACA;AACA;AACA;AACA,8BAA8B,0BAA0B,EAAE;AAC1D;AACA;AACA,SAAS;AACT;AACA,8BAA8B,0BAA0B,EAAE;AAC1D;AACA;AACA,SAAS;AACT;AACA,8BAA8B,2BAA2B,EAAE;AAC3D;AACA;AACA,SAAS;AACT;AACA,8BAA8B,8BAA8B,EAAE;AAC9D;AACA;AACA,SAAS;AACT;AACA,8BAA8B,yBAAyB,EAAE;AACzD;AACA;AACA,SAAS;AACT;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uCAAuC,GAAG,gDAAgD,GAAG,iDAAiD,GAAG,+CAA+C,GAAG,mDAAmD;AACtR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uCAAuC,GAAG,mFAAmF;AAC7J,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sCAAsC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wEAAwE;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kDAAkD,yBAAyB,EAAE;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,6CAA6C,UAAU,mCAAmC,EAAE,EAAE;AAC9F,kCAAkC,iCAAiC,EAAE;AACrE,qCAAqC,4BAA4B,EAAE;AACnE,yCAAyC,kCAAkC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,4BAA4B,EAAE;AAC5D;AACA;AACA,SAAS;AACT;AACA,8BAA8B,yBAAyB,EAAE;AACzD;AACA;AACA,SAAS;AACT;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,qCAAqC,cAAc;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,mBAAmB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,mBAAmB,EAAE;AAC3E;AACA;AACA;AACA,sDAAsD,mBAAmB,EAAE;AAC3E;AACA;AACA;AACA,iCAAiC;AACjC,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,KAAK;;AAEL;AACA,iCAAiC,kDAAkD,EAAE;AACrF;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA;AACA;AACA,oCAAoC,gBAAgB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,gCAAgC,iBAAiB,qCAAqC;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iBAAiB,mEAAmE;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iBAAiB,2HAA2H;AAC5K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU,qCAAqC;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,gCAAgC,iBAAiB,qCAAqC;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iBAAiB,mEAAmE;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iBAAiB,2HAA2H;AAC5K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU,qCAAqC;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sCAAsC,qDAAqD;AAC3F;AACA;AACA,KAAK;;AAEL;AACA,iCAAiC,sDAAsD,EAAE;AACzF;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,gCAAgC,gBAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,uBAAuB,2BAA2B;AAClD,2BAA2B,2BAA2B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,uDAAuD;AACvD,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,EAAE,EAAE;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,kBAAkB,EAAE,sCAAsC,mBAAmB,EAAE;AAChK;AACA;AACA;AACA,kDAAkD,8BAA8B,EAAE;AAClF,SAAS;AACT,sEAAsE,6BAA6B,EAAE;AACrG;AACA;AACA;AACA;AACA,4EAA4E,kBAAkB,EAAE,iCAAiC,mBAAmB,EAAE;AACtJ;AACA,sDAAsD,4BAA4B,EAAE;AACpF;AACA,qCAAqC,sBAAsB,EAAE;AAC7D;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,6BAA6B,EAAE,EAAE;AACjC;AACA;AACA;AACA;AACA,sDAAsD,+BAA+B;AACrF;AACA;AACA;AACA;AACA;AACA,2CAA2C,iBAAiB;AAC5D;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,6BAA6B;AAC7B;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,wBAAwB;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,kEAAkE,mBAAmB,EAAE;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,UAAU,yBAAyB,EAAE,EAAE;AAC/F,kDAAkD,iCAAiC,EAAE;AACrF;AACA;AACA;AACA,yBAAyB;AACzB,oEAAoE,wBAAwB,EAAE;AAC9F,qEAAqE,oBAAoB,EAAE;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,yEAAyE,4BAA4B,EAAE;AACvG,2EAA2E,mDAAmD,EAAE;AAChI;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,wBAAwB;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,kEAAkE,mBAAmB,EAAE;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,UAAU,yBAAyB,EAAE,EAAE;AAC/F,kDAAkD,iCAAiC,EAAE;AACrF;AACA;AACA;AACA,yBAAyB;AACzB,sEAAsE,yJAAyJ,EAAE;AACjO;AACA,oDAAoD,sDAAsD,EAAE;AAC5G,qEAAqE,oBAAoB,EAAE;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,2BAA2B,EAAE;AACrG,yEAAyE,4BAA4B,EAAE;AACvG;AACA;AACA;AACA,iCAAiC;AACjC,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,oBAAoB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,yEAAyE,iDAAiD,EAAE;AAC5H;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,4BAA4B;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,4BAA4B;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,0DAA0D;AACpI;AACA;AACA,6BAA6B,2DAA2D,mFAAmF,EAAE,IAAI,uCAAuC,GAAG,EAAE;AAC7N,4DAA4D,iCAAiC;AAC7F;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,2CAA2C,oBAAoB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,2CAA2C,oBAAoB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,uDAAuD,iDAAiD,EAAE,EAAE;AACnM;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gDAAgD,2BAA2B;AAC3E;AACA,yCAAyC;AACzC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,uDAAuD,iDAAiD,EAAE,EAAE;AACnM;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,4CAA4C,2BAA2B;AACvE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,sCAAsC;AACxF,oDAAoD,wCAAwC;AAC5F,yCAAyC,6BAA6B;AACtE,8CAA8C,kCAAkC;AAChF,gDAAgD,yCAAyC;AACzF,oDAAoD,6CAA6C;AACjG,mDAAmD,0CAA0C;AAC7F,kDAAkD,yCAAyC;AAC3F;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2GAA2G;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,iCAAiC,EAAE,EAAE;AACrC;AACA;AACA,+DAA+D,2CAA2C,EAAE;AAC5G;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,2CAA2C,EAAE;AAC5G;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,sBAAsB,EAAE;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,gDAAgD,EAAE;AAC1I;AACA;AACA,wDAAwD,2CAA2C,EAAE;AACrG;AACA;AACA,iCAAiC;AACjC;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,2CAA2C,EAAE;AACrG;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,+BAA+B,EAAE;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,wDAAwD,EAAE;AAClJ;AACA;AACA,wDAAwD,2CAA2C,EAAE;AACrG,gGAAgG,0EAA0E,EAAE;AAC5K;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,2CAA2C,EAAE;AACrG;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,qCAAqC,uCAAuC;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,yBAAyB,EAAE;AACnF;AACA;AACA,oDAAoD,0DAA0D;AAC9G;AACA,wDAAwD,wDAAwD;AAChH;AACA,4DAA4D,oDAAoD;AAChH;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F,kCAAkC,aAAa,EAAE;AAC5I;AACA,iBAAiB;AACjB,aAAa,EAAE,EAAE;AACjB;AACA;AACA,gDAAgD,4BAA4B;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F;AAC5F;AACA,iBAAiB;AACjB,aAAa,EAAE,EAAE;AACjB;AACA;AACA,gDAAgD,4BAA4B;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,iCAAiC,uCAAuC;AACxE;AACA;AACA;AACA,iCAAiC,uCAAuC;AACxE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kHAAkH,+BAA+B,KAAK;AACtJ;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,uCAAuC,oBAAoB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,uCAAuC,oBAAoB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,uBAAuB,EAAE;AAC7D,0CAA0C,gCAAgC,EAAE;AAC5E;;AAEA;AACA;AACA,+CAA+C,yBAAyB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,4BAA4B;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,8BAA8B,iCAAiC,EAAE;AACjE;AACA;AACA,SAAS;AACT;AACA,8BAA8B,gCAAgC,EAAE;AAChE;AACA;AACA,SAAS;AACT;AACA;AACA,mCAAmC,8CAA8C,EAAE;AACnF,2CAA2C,gBAAgB,EAAE;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,+CAA+C,oDAAoD,EAAE;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+CAA+C,4BAA4B,+BAA+B,EAAE,EAAE;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kDAAkD,cAAc;;AAEhE,CAAC;AACD,oC;CChmLA;AACA;AACA;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,yCAAyC,gBAAgB;AACzD;AACA;AACA,+CAA+C,4BAA4B;AAC3E,oCAAoC,cAAc;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,QAAQ,SAAS;AACjB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,C","file":"scripts.js","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (global = global || self, factory(global.faceapi = global.faceapi || {}));\n}(this, function (exports) { 'use strict';\n\n    /**\n     * @license\n     * Copyright 2018 Google LLC. All Rights Reserved.\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     * http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     * =============================================================================\n     */\n    var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t;}||function(e,t){for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n]);};function __extends(e,t){function n(){this.constructor=e;}extendStatics(e,t),e.prototype=null===t?Object.create(t):(n.prototype=t.prototype,new n);}var __assign=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var o in t=arguments[n])Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o]);return e};function __awaiter(e,t,n,r){return new(n||(n=Promise))(function(o,a){function i(e){try{u(r.next(e));}catch(e){a(e);}}function s(e){try{u(r.throw(e));}catch(e){a(e);}}function u(e){e.done?o(e.value):new n(function(t){t(e.value);}).then(i,s);}u((r=r.apply(e,t||[])).next());})}function __generator(e,t){var n,r,o,a,i={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return a={next:s(0),throw:s(1),return:s(2)},\"function\"==typeof Symbol&&(a[Symbol.iterator]=function(){return this}),a;function s(a){return function(s){return function(a){if(n)throw new TypeError(\"Generator is already executing.\");for(;i;)try{if(n=1,r&&(o=2&a[0]?r.return:a[0]?r.throw||((o=r.return)&&o.call(r),0):r.next)&&!(o=o.call(r,a[1])).done)return o;switch(r=0,o&&(a=[2&a[0],o.value]),a[0]){case 0:case 1:o=a;break;case 4:return i.label++,{value:a[1],done:!1};case 5:i.label++,r=a[1],a=[0];continue;case 7:a=i.ops.pop(),i.trys.pop();continue;default:if(!(o=(o=i.trys).length>0&&o[o.length-1])&&(6===a[0]||2===a[0])){i=0;continue}if(3===a[0]&&(!o||a[1]>o[0]&&a[1]<o[3])){i.label=a[1];break}if(6===a[0]&&i.label<o[1]){i.label=o[1],o=a;break}if(o&&i.label<o[2]){i.label=o[2],i.ops.push(a);break}o[2]&&i.ops.pop(),i.trys.pop();continue}a=t.call(e,i);}catch(e){a=[6,e],r=0;}finally{n=o=0;}if(5&a[0])throw a[1];return {value:a[0]?a[1]:void 0,done:!0}}([a,s])}}}var contexts={},WEBGL_ATTRIBUTES={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function getWebGLContext(e){e in contexts||(document.createElement(\"canvas\").addEventListener(\"webglcontextlost\",function(t){t.preventDefault(),delete contexts[e];},!1),contexts[e]=getWebGLRenderingContext(e));var t=contexts[e];return t.isContextLost()?(delete contexts[e],getWebGLContext(e)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),contexts[e])}function getWebGLRenderingContext(e){if(1!==e&&2!==e)throw new Error(\"Cannot get WebGL rendering context, WebGL is disabled.\");var t=document.createElement(\"canvas\");return 1===e?t.getContext(\"webgl\",WEBGL_ATTRIBUTES)||t.getContext(\"experimental-webgl\",WEBGL_ATTRIBUTES):t.getContext(\"webgl2\",WEBGL_ATTRIBUTES)}function isMobile(){var e=navigator.userAgent||navigator.vendor||window.opera;return /(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i.test(e.substr(0,4))}function shuffle(e){for(var t=e.length,n=0,r=0;t>0;)r=Math.random()*t|0,n=e[--t],e[t]=e[r],e[r]=n;}function clamp(e,t,n){return Math.max(e,Math.min(t,n))}function nearestLargerEven(e){return e%2==0?e:e+1}function sum(e){for(var t=0,n=0;n<e.length;n++)t+=e[n];return t}function randUniform(e,t){var n=Math.random();return t*n+(1-n)*e}function distSquared(e,t){for(var n=0,r=0;r<e.length;r++){var o=Number(e[r])-Number(t[r]);n+=o*o;}return n}function assert(e,t){if(!e)throw new Error(\"string\"==typeof t?t:t())}function assertShapesMatch(e,t,n){void 0===n&&(n=\"\"),assert(arraysEqual(e,t),n+\" Shapes \"+e+\" and \"+t+\" must match\");}function assertNonNull(e){assert(null!=e,\"The input to the tensor constructor must be a non-null value.\");}function flatten(e,t){if(void 0===t&&(t=[]),Array.isArray(e)||isTypedArray(e))for(var n=0;n<e.length;++n)flatten(e[n],t);else t.push(e);return t}function sizeFromShape(e){if(0===e.length)return 1;for(var t=e[0],n=1;n<e.length;n++)t*=e[n];return t}function isScalarShape(e){return 0===e.length}function arraysEqual(e,t){if(e===t)return !0;if(null==e||null==t)return !1;if(e.length!==t.length)return !1;for(var n=0;n<e.length;n++)if(e[n]!==t[n])return !1;return !0}function isInt(e){return e%1==0}function tanh(e){if(null!=Math.tanh)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return -1;var t=Math.exp(2*e);return (t-1)/(t+1)}function sizeToSquarishShape(e){for(var t=Math.floor(Math.sqrt(e));t>1;--t)if(e%t==0)return [t,e/t];return [1,e]}function createShuffledIndices(e){for(var t=new Uint32Array(e),n=0;n<e;++n)t[n]=n;return shuffle(t),t}function rightPad(e,t){return t<=e.length?e:e+\" \".repeat(t-e.length)}function repeatedTry(e,t,n){return void 0===t&&(t=function(e){return 0}),new Promise(function(r,o){var a=0,i=function(){if(e())r();else{var s=t(++a);null!=n&&a>=n?o():setTimeout(i,s);}};i();})}function inferFromImplicitShape(e,t){for(var n=1,r=-1,o=0;o<e.length;++o)if(e[o]>=0)n*=e[o];else if(-1===e[o]){if(-1!==r)throw Error(\"Shapes can only have 1 implicit size. Found -1 at dim \"+r+\" and dim \"+o);r=o;}else if(e[o]<0)throw Error(\"Shapes can not be < 0. Found \"+e[o]+\" at dim \"+o);if(-1===r){if(t>0&&t!==n)throw Error(\"Size(\"+t+\") must match the product of shape \"+e);return e}if(0===n)throw Error(\"Cannot infer the missing size in [\"+e+\"] when there are 0 elements\");if(t%n!=0)throw Error(\"The implicit shape can't be a fractional number. Got \"+t+\" / \"+n);var a=e.slice();return a[r]=t/n,a}function squeezeShape(e,t){for(var n=[],r=[],o=0,a=0;a<e.length;++a){if(null!=t){if(t[o]===a&&1!==e[a])throw new Error(\"Can't squeeze axis \"+a+\" since its dim '\"+e[a]+\"' is not 1\");(null==t[o]||t[o]>a)&&1===e[a]&&(n.push(e[a]),r.push(a)),t[o]<=a&&o++;}1!==e[a]&&(n.push(e[a]),r.push(a));}return {newShape:n,keptDims:r}}function getTypedArrayFromDType(e,t){var n=null;if(null==e||\"float32\"===e)n=new Float32Array(t);else if(\"int32\"===e)n=new Int32Array(t);else{if(\"bool\"!==e)throw new Error(\"Unknown data type \"+e);n=new Uint8Array(t);}return n}function getArrayFromDType(e,t){var n=null;if(null==e||\"float32\"===e)n=new Float32Array(t);else if(\"int32\"===e)n=new Int32Array(t);else if(\"bool\"===e)n=new Uint8Array(t);else{if(\"string\"!==e)throw new Error(\"Unknown data type \"+e);n=new Array(t);}return n}function checkComputationForNaN(e,t,n){if(\"float32\"===t)for(var r=0;r<e.length;r++)if(isNaN(e[r]))throw Error(\"The result of the '\"+n+\"' has NaNs.\")}function checkConversionForNaN(e,t){if(\"float32\"!==t)for(var n=0;n<e.length;n++)if(isNaN(e[n]))throw Error(\"NaN is not a valid value for dtype: '\"+t+\"'.\")}function hasEncodingLoss(e,t){return \"complex64\"!==t&&((\"float32\"!==t||\"complex64\"===e)&&((\"int32\"!==t||\"float32\"===e||\"complex64\"===e)&&(\"bool\"!==t||\"bool\"!==e)))}function isTypedArray(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array}function bytesPerElement(e){if(\"float32\"===e||\"int32\"===e)return 4;if(\"complex64\"===e)return 8;if(\"bool\"===e)return 1;throw new Error(\"Unknown dtype \"+e)}function bytesFromStringArray(e){if(null==e)return 0;var t=0;return e.forEach(function(e){return t+=2*e.length}),t}function isString(e){return \"string\"==typeof e||e instanceof String}function isBoolean(e){return \"boolean\"==typeof e}function isNumber(e){return \"number\"==typeof e}function inferDtype(e){return e instanceof Array?inferDtype(e[0]):e instanceof Float32Array?\"float32\":e instanceof Int32Array||e instanceof Uint8Array?\"int32\":isNumber(e)?\"float32\":isString(e)?\"string\":isBoolean(e)?\"bool\":\"float32\"}function isFunction(e){return !!(e&&e.constructor&&e.call&&e.apply)}function nearestDivisor(e,t){for(var n=t;n<e;++n)if(e%n==0)return n;return e}function computeStrides(e){var t=e.length;if(t<2)return [];var n=new Array(t-1);n[t-2]=e[t-1];for(var r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function toTypedArray(e,t,n){if(\"string\"===t)throw new Error(\"Cannot convert a string[] to a TypedArray\");if(noConversionNeeded(e,t))return e;if(Array.isArray(e)&&(e=flatten(e)),null==t||\"float32\"===t||\"complex64\"===t)return new Float32Array(e);if(\"int32\"===t)return n&&checkConversionForNaN(e,t),new Int32Array(e);if(\"bool\"===t){for(var r=new Uint8Array(e.length),o=0;o<r.length;++o)0!==Math.round(e[o])&&(r[o]=1);return r}throw new Error(\"Unknown data type \"+t)}function noConversionNeeded(e,t){return e instanceof Float32Array&&\"float32\"===t||e instanceof Int32Array&&\"int32\"===t||e instanceof Uint8Array&&\"bool\"===t}function makeOnesTypedArray(e,t){for(var n=makeZerosTypedArray(e,t),r=0;r<n.length;r++)n[r]=1;return n}function makeZerosTypedArray(e,t){if(null==t||\"float32\"===t||\"complex64\"===t)return new Float32Array(e);if(\"int32\"===t)return new Int32Array(e);if(\"bool\"===t)return new Uint8Array(e);throw new Error(\"Unknown data type \"+t)}function now(){if(\"undefined\"!=typeof performance)return performance.now();if(\"undefined\"!=typeof process){var e=process.hrtime();return 1e3*e[0]+e[1]/1e6}throw new Error(\"Cannot measure time in this environment. You should run tf.js in the browser or in Node.js\")}var util=Object.freeze({shuffle:shuffle,clamp:clamp,nearestLargerEven:nearestLargerEven,sum:sum,randUniform:randUniform,distSquared:distSquared,assert:assert,assertShapesMatch:assertShapesMatch,assertNonNull:assertNonNull,flatten:flatten,sizeFromShape:sizeFromShape,isScalarShape:isScalarShape,arraysEqual:arraysEqual,isInt:isInt,tanh:tanh,sizeToSquarishShape:sizeToSquarishShape,createShuffledIndices:createShuffledIndices,rightPad:rightPad,repeatedTry:repeatedTry,inferFromImplicitShape:inferFromImplicitShape,squeezeShape:squeezeShape,getTypedArrayFromDType:getTypedArrayFromDType,getArrayFromDType:getArrayFromDType,checkComputationForNaN:checkComputationForNaN,checkConversionForNaN:checkConversionForNaN,hasEncodingLoss:hasEncodingLoss,isTypedArray:isTypedArray,bytesPerElement:bytesPerElement,bytesFromStringArray:bytesFromStringArray,isString:isString,isBoolean:isBoolean,isNumber:isNumber,inferDtype:inferDtype,isFunction:isFunction,nearestDivisor:nearestDivisor,computeStrides:computeStrides,toTypedArray:toTypedArray,makeOnesTypedArray:makeOnesTypedArray,makeZerosTypedArray:makeZerosTypedArray,now:now}),Profiler=function(){function e(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new Logger);}return e.prototype.profileKernel=function(e,t){var n,r=this,o=this.backendTimer.time(function(){n=t();});return (Array.isArray(n)?n:[n]).forEach(function(t){var n=t.dataSync();checkComputationForNaN(n,t.dtype,e),o.then(function(o){var a=\"\";null!=o.getExtraProfileInfo&&(a=o.getExtraProfileInfo()),r.logger.logKernelProfile(e,t,n,o.kernelMs,a);});}),n},e}(),Logger=function(){function e(){}return e.prototype.logKernelProfile=function(e,t,n,r,o){var a=rightPad(r+\"ms\",9),i=rightPad(e,25),s=t.rank,u=t.size,l=rightPad(t.shape.toString(),14);console.log(\"%c\"+i+\"\\t%c\"+a+\"\\t%c\"+s+\"D \"+l+\"\\t%c\"+u+\"\\t%c\"+o,\"font-weight:bold\",\"color:red\",\"color:blue\",\"color: orange\",\"color: green\");},e}(),FORMAT_LIMIT_NUM_VALS=20,FORMAT_NUM_FIRST_LAST_VALS=3,FORMAT_NUM_SIG_DIGITS=7;function tensorToString(e,t,n,r){var o=computeStrides(t),a=computeMaxSizePerColumn(e,t,n,o),i=t.length,s=subTensorToString(e,t,n,o,a),u=[\"Tensor\"];return r&&(u.push(\"  dtype: \"+n),u.push(\"  rank: \"+i),u.push(\"  shape: [\"+t+\"]\"),u.push(\"  values:\")),u.push(s.map(function(e){return \"    \"+e}).join(\"\\n\")),u.join(\"\\n\")}function computeMaxSizePerColumn(e,t,n,r){var o=sizeFromShape(t),a=r[r.length-1],i=new Array(a).fill(0),s=t.length,u=\"complex64\"===n?createComplexTuples(e):e;if(s>1)for(var l=0;l<o/a;l++)for(var c=l*a,p=0;p<a;p++)i[p]=Math.max(i[p],valToString(u[c+p],0).length);return i}function valToString(e,t){return rightPad(Array.isArray(e)?parseFloat(e[0].toFixed(FORMAT_NUM_SIG_DIGITS))+\" + \"+parseFloat(e[1].toFixed(FORMAT_NUM_SIG_DIGITS))+\"j\":isString(e)?\"'\"+e+\"'\":parseFloat(e.toFixed(FORMAT_NUM_SIG_DIGITS)).toString(),t)}function subTensorToString(e,t,n,r,o,a){void 0===a&&(a=!0);var i=\"complex64\"===n?2:1,s=t[0],u=t.length;if(0===u)return \"complex64\"===n?[valToString(createComplexTuples(e)[0],0)]:[e[0].toString()];if(1===u){if(s>FORMAT_LIMIT_NUM_VALS){var l=FORMAT_NUM_FIRST_LAST_VALS*i,c=Array.from(e.slice(0,l)),p=Array.from(e.slice(s-FORMAT_NUM_FIRST_LAST_VALS*i,s));return \"complex64\"===n&&(c=createComplexTuples(c),p=createComplexTuples(p)),[\"[\"+c.map(function(e,t){return valToString(e,o[t])}).join(\", \")+\", ..., \"+p.map(function(e,t){return valToString(e,o[s-FORMAT_NUM_FIRST_LAST_VALS+t])}).join(\", \")+\"]\"]}return [\"[\"+(\"complex64\"===n?createComplexTuples(e):Array.from(e)).map(function(e,t){return valToString(e,o[t])}).join(\", \")+\"]\"]}var d=t.slice(1),h=r.slice(1),f=r[0]*i,m=[];if(s>FORMAT_LIMIT_NUM_VALS){for(var g=0;g<FORMAT_NUM_FIRST_LAST_VALS;g++){var v=(y=g*f)+f;m.push.apply(m,subTensorToString(e.slice(y,v),d,n,h,o,!1));}m.push(\"...\");for(g=s-FORMAT_NUM_FIRST_LAST_VALS;g<s;g++){v=(y=g*f)+f;m.push.apply(m,subTensorToString(e.slice(y,v),d,n,h,o,g===s-1));}}else for(g=0;g<s;g++){var y;v=(y=g*f)+f;m.push.apply(m,subTensorToString(e.slice(y,v),d,n,h,o,g===s-1));}var x=2===u?\",\":\"\";m[0]=\"[\"+m[0]+x;for(g=1;g<m.length-1;g++)m[g]=\" \"+m[g]+x;var T=\",\\n\";for(g=2;g<u;g++)T+=\"\\n\";return m[m.length-1]=\" \"+m[m.length-1]+\"]\"+(a?\"\":T),m}function createComplexTuples(e){for(var t=[],n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}var TensorBuffer=function(){function e(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=sizeFromShape(e),null!=n){var r=n.length;assert(r===this.size,\"Length of values '\"+r+\"' does not match the size inferred by the shape '\"+this.size+\"'.\");}if(\"complex64\"===t)throw new Error(\"complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).\");this.values=n||getArrayFromDType(t,sizeFromShape(this.shape)),this.strides=computeStrides(e);}return e.prototype.set=function(e){for(var t=[],n=1;n<arguments.length;n++)t[n-1]=arguments[n];0===t.length&&(t=[0]),assert(t.length===this.rank,\"The number of provided coordinates (\"+t.length+\") must match the rank (\"+this.rank+\")\");var r=this.locToIndex(t);this.values[r]=e;},e.prototype.get=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];0===e.length&&(e=[0]);for(var n=e[e.length-1],r=0;r<e.length-1;++r)n+=this.strides[r]*e[r];return this.values[n]},e.prototype.locToIndex=function(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];for(var t=e[e.length-1],n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t},e.prototype.indexToLoc=function(e){if(0===this.rank)return [];if(1===this.rank)return [e];for(var t=new Array(this.shape.length),n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t},Object.defineProperty(e.prototype,\"rank\",{get:function(){return this.shape.length},enumerable:!0,configurable:!0}),e.prototype.toTensor=function(){return Tensor.make(this.shape,{values:this.values},this.dtype)},e}(),trackerFn=null,opHandler=null;function setTensorTracker(e){trackerFn=e;}function setOpHandler(e){opHandler=e;}var Tensor=function(){function e(e,t,n,r){this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||\"float32\",this.size=sizeFromShape(e),this.strides=computeStrides(e),this.dataId=null!=r?r:{},this.id=trackerFn().nextTensorId(),this.rankType=this.rank<5?this.rank.toString():\"higher\",trackerFn().registerTensor(this),null!=n&&trackerFn().write(this.dataId,n);}return e.make=function(t,n,r){return new e(t,r,n.values,n.dataId)},e.prototype.flatten=function(){return this.throwIfDisposed(),this.as1D()},e.prototype.asScalar=function(){return this.throwIfDisposed(),assert(1===this.size,\"The array must have only 1 element.\"),this.reshape([])},e.prototype.as1D=function(){return this.throwIfDisposed(),this.reshape([this.size])},e.prototype.as2D=function(e,t){return this.throwIfDisposed(),this.reshape([e,t])},e.prototype.as3D=function(e,t,n){return this.throwIfDisposed(),this.reshape([e,t,n])},e.prototype.as4D=function(e,t,n,r){return this.throwIfDisposed(),this.reshape([e,t,n,r])},e.prototype.as5D=function(e,t,n,r,o){return this.throwIfDisposed(),this.reshape([e,t,n,r,o])},e.prototype.asType=function(e){return this.throwIfDisposed(),opHandler.cast(this,e)},Object.defineProperty(e.prototype,\"rank\",{get:function(){return this.shape.length},enumerable:!0,configurable:!0}),e.prototype.get=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];assert(e.length===this.rank,\"Number of coordinates in get() must match the rank of the tensor\"),assert(\"complex64\"!==this.dtype,\"Tensor.get() is not supported for complex64 tensors yet.\"),this.throwIfDisposed(),0===e.length&&(e=[0]);for(var n=e[e.length-1],r=0;r<e.length-1;++r)n+=this.strides[r]*e[r];return this.dataSync()[n]},e.prototype.buffer=function(){return opHandler.buffer(this.shape,this.dtype,this.dataSync())},e.prototype.data=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return this.throwIfDisposed(),[2,trackerFn().read(this.dataId)]})})},e.prototype.dataSync=function(){return this.throwIfDisposed(),trackerFn().readSync(this.dataId)},e.prototype.dispose=function(){this.isDisposed||(trackerFn().disposeTensor(this),this.isDisposedInternal=!0);},Object.defineProperty(e.prototype,\"isDisposed\",{get:function(){return this.isDisposedInternal},enumerable:!0,configurable:!0}),e.prototype.throwIfDisposed=function(){if(this.isDisposed)throw new Error(\"Tensor is disposed.\")},e.prototype.toFloat=function(){return this.asType(\"float32\")},e.prototype.toInt=function(){return this.asType(\"int32\")},e.prototype.toBool=function(){return this.asType(\"bool\")},e.prototype.print=function(e){return void 0===e&&(e=!1),opHandler.print(this,e)},e.prototype.reshape=function(e){return this.throwIfDisposed(),opHandler.reshape(this,e)},e.prototype.reshapeAs=function(e){return this.throwIfDisposed(),this.reshape(e.shape)},e.prototype.expandDims=function(e){return void 0===e&&(e=0),opHandler.expandDims(this,e)},e.prototype.cumsum=function(e,t,n){return void 0===e&&(e=0),void 0===t&&(t=!1),void 0===n&&(n=!1),opHandler.cumsum(this,e,t,n)},e.prototype.squeeze=function(e){return this.throwIfDisposed(),opHandler.squeeze(this,e)},e.prototype.clone=function(){return this.throwIfDisposed(),opHandler.clone(this)},e.prototype.toString=function(e){return void 0===e&&(e=!1),tensorToString(this.dataSync(),this.shape,this.dtype,e)},e.prototype.tile=function(e){return this.throwIfDisposed(),opHandler.tile(this,e)},e.prototype.gather=function(e,t){return void 0===t&&(t=0),this.throwIfDisposed(),opHandler.gather(this,e,t)},e.prototype.matMul=function(e,t,n){return void 0===t&&(t=!1),void 0===n&&(n=!1),this.throwIfDisposed(),opHandler.matMul(this,e,t,n)},e.prototype.dot=function(e){return this.throwIfDisposed(),opHandler.dot(this,e)},e.prototype.norm=function(e,t,n){return void 0===e&&(e=\"euclidean\"),void 0===t&&(t=null),void 0===n&&(n=!1),this.throwIfDisposed(),opHandler.norm(this,e,t,n)},e.prototype.slice=function(e,t){return this.throwIfDisposed(),opHandler.slice(this,e,t)},e.prototype.reverse=function(e){return this.throwIfDisposed(),opHandler.reverse(this,e)},e.prototype.concat=function(t,n){return void 0===n&&(n=0),this.throwIfDisposed(),t instanceof e&&(t=[t]),opHandler.concat([this].concat(t),n)},e.prototype.split=function(e,t){return void 0===t&&(t=0),this.throwIfDisposed(),opHandler.split(this,e,t)},e.prototype.stack=function(e,t){return void 0===t&&(t=0),opHandler.stack([this,e],t)},e.prototype.unstack=function(e,t){return void 0===t&&(t=0),opHandler.unstack(this,t)},e.prototype.pad=function(e,t){return void 0===t&&(t=0),opHandler.pad(this,e,t)},e.prototype.batchNormalization=function(e,t,n,r,o){return void 0===n&&(n=.001),this.throwIfDisposed(),opHandler.batchNormalization(this,e,t,n,r,o)},e.prototype.all=function(e,t){return void 0===e&&(e=null),void 0===t&&(t=!1),this.throwIfDisposed(),opHandler.all(this,e,t)},e.prototype.any=function(e,t){return void 0===e&&(e=null),void 0===t&&(t=!1),this.throwIfDisposed(),opHandler.any(this,e,t)},e.prototype.logSumExp=function(e,t){return void 0===e&&(e=null),void 0===t&&(t=!1),this.throwIfDisposed(),opHandler.logSumExp(this,e,t)},e.prototype.sum=function(e,t){return void 0===e&&(e=null),void 0===t&&(t=!1),this.throwIfDisposed(),opHandler.sum(this,e,t)},e.prototype.prod=function(e,t){return void 0===e&&(e=null),void 0===t&&(t=!1),this.throwIfDisposed(),opHandler.prod(this,e,t)},e.prototype.mean=function(e,t){return void 0===e&&(e=null),void 0===t&&(t=!1),this.throwIfDisposed(),opHandler.mean(this,e,t)},e.prototype.min=function(e,t){return void 0===e&&(e=null),void 0===t&&(t=!1),this.throwIfDisposed(),opHandler.min(this,e,t)},e.prototype.max=function(e,t){return void 0===e&&(e=null),void 0===t&&(t=!1),this.throwIfDisposed(),opHandler.max(this,e,t)},e.prototype.argMin=function(e){return void 0===e&&(e=null),this.throwIfDisposed(),opHandler.argMin(this,e)},e.prototype.argMax=function(e){return void 0===e&&(e=null),this.throwIfDisposed(),opHandler.argMax(this,e)},e.prototype.cast=function(e){return this.throwIfDisposed(),opHandler.cast(this,e)},e.prototype.add=function(e){return this.throwIfDisposed(),opHandler.add(this,e)},e.prototype.addStrict=function(e){return this.throwIfDisposed(),opHandler.addStrict(this,e)},e.prototype.atan2=function(e){return this.throwIfDisposed(),opHandler.atan2(this,e)},e.prototype.sub=function(e){return this.throwIfDisposed(),opHandler.sub(this,e)},e.prototype.subStrict=function(e){return this.throwIfDisposed(),opHandler.subStrict(this,e)},e.prototype.pow=function(e){return this.throwIfDisposed(),opHandler.pow(this,e)},e.prototype.powStrict=function(e){return this.throwIfDisposed(),opHandler.powStrict(this,e)},e.prototype.mul=function(e){return this.throwIfDisposed(),opHandler.mul(this,e)},e.prototype.mulStrict=function(e){return this.throwIfDisposed(),opHandler.mulStrict(this,e)},e.prototype.div=function(e){return this.throwIfDisposed(),opHandler.div(this,e)},e.prototype.floorDiv=function(e){return this.throwIfDisposed(),opHandler.floorDiv(this,e)},e.prototype.divStrict=function(e){return this.throwIfDisposed(),opHandler.divStrict(this,e)},e.prototype.minimum=function(e){return this.throwIfDisposed(),opHandler.minimum(this,e)},e.prototype.minimumStrict=function(e){return this.throwIfDisposed(),opHandler.minimumStrict(this,e)},e.prototype.maximum=function(e){return this.throwIfDisposed(),opHandler.maximum(this,e)},e.prototype.maximumStrict=function(e){return this.throwIfDisposed(),opHandler.maximumStrict(this,e)},e.prototype.mod=function(e){return this.throwIfDisposed(),opHandler.mod(this,e)},e.prototype.modStrict=function(e){return this.throwIfDisposed(),opHandler.modStrict(this,e)},e.prototype.squaredDifference=function(e){return this.throwIfDisposed(),opHandler.squaredDifference(this,e)},e.prototype.squaredDifferenceStrict=function(e){return this.throwIfDisposed(),opHandler.squaredDifferenceStrict(this,e)},e.prototype.transpose=function(e){return this.throwIfDisposed(),opHandler.transpose(this,e)},e.prototype.notEqual=function(e){return this.throwIfDisposed(),opHandler.notEqual(this,e)},e.prototype.notEqualStrict=function(e){return this.throwIfDisposed(),opHandler.notEqualStrict(this,e)},e.prototype.less=function(e){return this.throwIfDisposed(),opHandler.less(this,e)},e.prototype.lessStrict=function(e){return this.throwIfDisposed(),opHandler.lessStrict(this,e)},e.prototype.equal=function(e){return this.throwIfDisposed(),opHandler.equal(this,e)},e.prototype.equalStrict=function(e){return this.throwIfDisposed(),opHandler.equalStrict(this,e)},e.prototype.lessEqual=function(e){return this.throwIfDisposed(),opHandler.lessEqual(this,e)},e.prototype.lessEqualStrict=function(e){return this.throwIfDisposed(),opHandler.lessEqualStrict(this,e)},e.prototype.greater=function(e){return this.throwIfDisposed(),opHandler.greater(this,e)},e.prototype.greaterStrict=function(e){return this.throwIfDisposed(),opHandler.greaterStrict(this,e)},e.prototype.greaterEqual=function(e){return this.throwIfDisposed(),opHandler.greaterEqual(this,e)},e.prototype.greaterEqualStrict=function(e){return this.throwIfDisposed(),opHandler.greaterEqualStrict(this,e)},e.prototype.logicalAnd=function(e){return this.throwIfDisposed(),opHandler.logicalAnd(this,e)},e.prototype.logicalOr=function(e){return this.throwIfDisposed(),opHandler.logicalOr(this,e)},e.prototype.logicalNot=function(){return this.throwIfDisposed(),opHandler.logicalNot(this)},e.prototype.logicalXor=function(e){return this.throwIfDisposed(),opHandler.logicalXor(this,e)},e.prototype.where=function(e,t){return this.throwIfDisposed(),opHandler.where(e,this,t)},e.prototype.neg=function(){return this.throwIfDisposed(),opHandler.neg(this)},e.prototype.ceil=function(){return this.throwIfDisposed(),opHandler.ceil(this)},e.prototype.floor=function(){return this.throwIfDisposed(),opHandler.floor(this)},e.prototype.sign=function(){return this.throwIfDisposed(),opHandler.sign(this)},e.prototype.exp=function(){return this.throwIfDisposed(),opHandler.exp(this)},e.prototype.expm1=function(){return this.throwIfDisposed(),opHandler.expm1(this)},e.prototype.log=function(){return this.throwIfDisposed(),opHandler.log(this)},e.prototype.log1p=function(){return this.throwIfDisposed(),opHandler.log1p(this)},e.prototype.sqrt=function(){return this.throwIfDisposed(),opHandler.sqrt(this)},e.prototype.rsqrt=function(){return this.throwIfDisposed(),opHandler.rsqrt(this)},e.prototype.square=function(){return this.throwIfDisposed(),opHandler.square(this)},e.prototype.reciprocal=function(){return this.throwIfDisposed(),opHandler.reciprocal(this)},e.prototype.abs=function(){return this.throwIfDisposed(),opHandler.abs(this)},e.prototype.clipByValue=function(e,t){return this.throwIfDisposed(),opHandler.clipByValue(this,e,t)},e.prototype.relu=function(){return this.throwIfDisposed(),opHandler.relu(this)},e.prototype.elu=function(){return this.throwIfDisposed(),opHandler.elu(this)},e.prototype.selu=function(){return this.throwIfDisposed(),opHandler.selu(this)},e.prototype.leakyRelu=function(e){return void 0===e&&(e=.2),this.throwIfDisposed(),opHandler.leakyRelu(this,e)},e.prototype.prelu=function(e){return this.throwIfDisposed(),opHandler.prelu(this,e)},e.prototype.sigmoid=function(){return this.throwIfDisposed(),opHandler.sigmoid(this)},e.prototype.logSigmoid=function(){return this.throwIfDisposed(),opHandler.logSigmoid(this)},e.prototype.softplus=function(){return this.throwIfDisposed(),opHandler.softplus(this)},e.prototype.zerosLike=function(){return this.throwIfDisposed(),opHandler.zerosLike(this)},e.prototype.onesLike=function(){return this.throwIfDisposed(),opHandler.onesLike(this)},e.prototype.sin=function(){return this.throwIfDisposed(),opHandler.sin(this)},e.prototype.cos=function(){return this.throwIfDisposed(),opHandler.cos(this)},e.prototype.tan=function(){return this.throwIfDisposed(),opHandler.tan(this)},e.prototype.asin=function(){return this.throwIfDisposed(),opHandler.asin(this)},e.prototype.acos=function(){return this.throwIfDisposed(),opHandler.acos(this)},e.prototype.atan=function(){return this.throwIfDisposed(),opHandler.atan(this)},e.prototype.sinh=function(){return this.throwIfDisposed(),opHandler.sinh(this)},e.prototype.cosh=function(){return this.throwIfDisposed(),opHandler.cosh(this)},e.prototype.tanh=function(){return this.throwIfDisposed(),opHandler.tanh(this)},e.prototype.asinh=function(){return this.throwIfDisposed(),opHandler.asinh(this)},e.prototype.acosh=function(){return this.throwIfDisposed(),opHandler.acosh(this)},e.prototype.atanh=function(){return this.throwIfDisposed(),opHandler.atanh(this)},e.prototype.erf=function(){return this.throwIfDisposed(),opHandler.erf(this)},e.prototype.round=function(){return this.throwIfDisposed(),opHandler.round(this)},e.prototype.step=function(e){return void 0===e&&(e=0),this.throwIfDisposed(),opHandler.step(this,e)},e.prototype.softmax=function(e){return void 0===e&&(e=-1),this.throwIfDisposed(),opHandler.softmax(this,e)},e.prototype.logSoftmax=function(e){return void 0===e&&(e=-1),this.throwIfDisposed(),opHandler.logSoftmax(this,e)},e.prototype.resizeBilinear=function(e,t){return void 0===t&&(t=!1),this.throwIfDisposed(),opHandler.image.resizeBilinear(this,e,t)},e.prototype.resizeNearestNeighbor=function(e,t){return void 0===t&&(t=!1),this.throwIfDisposed(),opHandler.image.resizeNearestNeighbor(this,e,t)},e.prototype.conv1d=function(e,t,n,r,o,a){return void 0===r&&(r=\"NWC\"),void 0===o&&(o=1),this.throwIfDisposed(),opHandler.conv1d(this,e,t,n,r,o,a)},e.prototype.conv2d=function(e,t,n,r,o,a){return void 0===r&&(r=\"NHWC\"),void 0===o&&(o=[1,1]),this.throwIfDisposed(),opHandler.conv2d(this,e,t,n,r,o,a)},e.prototype.conv2dTranspose=function(e,t,n,r,o){return this.throwIfDisposed(),opHandler.conv2dTranspose(this,e,t,n,r,o)},e.prototype.depthwiseConv2D=function(e,t,n,r,o,a){return void 0===r&&(r=\"NHWC\"),void 0===o&&(o=[1,1]),this.throwIfDisposed(),opHandler.depthwiseConv2d(this,e,t,n,r,o,a)},e.prototype.separableConv2d=function(e,t,n,r,o,a){return void 0===o&&(o=[1,1]),void 0===a&&(a=\"NHWC\"),this.throwIfDisposed(),opHandler.separableConv2d(this,e,t,n,r,o,a)},e.prototype.avgPool=function(e,t,n,r){return this.throwIfDisposed(),opHandler.avgPool(this,e,t,n,r)},e.prototype.maxPool=function(e,t,n,r){return this.throwIfDisposed(),opHandler.maxPool(this,e,t,n,r)},e.prototype.localResponseNormalization=function(e,t,n,r){return void 0===e&&(e=5),void 0===t&&(t=1),void 0===n&&(n=1),void 0===r&&(r=.5),opHandler.localResponseNormalization(this,e,t,n,r)},e.prototype.pool=function(e,t,n,r,o){return this.throwIfDisposed(),opHandler.pool(this,e,t,n,r,o)},e.prototype.variable=function(e,t,n){return void 0===e&&(e=!0),this.throwIfDisposed(),Variable.variable(this,e,t,n)},e.prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),opHandler.unsortedSegmentSum(this,e,t)},e.prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),opHandler.batchToSpaceND(this,e,t)},e.prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),opHandler.spaceToBatchND(this,e,t)},e.prototype.topk=function(e,t){return void 0===e&&(e=1),void 0===t&&(t=!0),this.throwIfDisposed(),opHandler.topk(this,e,t)},e.prototype.stridedSlice=function(e,t,n,r,o){return void 0===r&&(r=0),void 0===o&&(o=0),this.throwIfDisposed(),opHandler.stridedSlice(this,e,t,n,r,o)},e.prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),opHandler.depthToSpace(this,e,t)},e.prototype.fft=function(){return this.throwIfDisposed(),opHandler.spectral.fft(this)},e.prototype.ifft=function(){return this.throwIfDisposed(),opHandler.spectral.ifft(this)},e}();Object.defineProperty(Tensor,Symbol.hasInstance,{value:function(e){return !!e&&null!=e.shape&&null!=e.dtype}});var Variable=function(e){function t(t,n,r){void 0===n&&(n=!0);var o=e.call(this,t.shape,t.dtype,null,t.dataId)||this;o.trainable=n,o.name=r,null==o.name&&(o.name=trackerFn().nextVariableId().toString());try{trackerFn().registerVariable(o);}catch(e){throw trackerFn().disposeTensor(o),e}return o}return __extends(t,e),t.variable=function(e,n,r,o){return void 0===n&&(n=!0),null!=o&&o!==e.dtype&&(e=e.asType(o)),new t(e,n,r)},t.prototype.assign=function(e){if(e.dtype!==this.dtype)throw new Error(\"dtype of the new value (\"+e.dtype+\") and previous value (\"+this.dtype+\") must match\");if(!arraysEqual(e.shape,this.shape))throw new Error(\"shape of the new value (\"+e.shape+\") and previous value (\"+this.shape+\") must match\");trackerFn().disposeTensor(this),this.dataId=e.dataId,trackerFn().registerTensor(this);},t}(Tensor);Object.defineProperty(Variable,Symbol.hasInstance,{value:function(e){return e instanceof Tensor&&null!=e.assign&&e.assign instanceof Function}});var Rank,UpcastInt32AndMap,UpcastBoolAndMap,UpcastFloat32AndMap,UpcastComplex64AndMap,variable=Variable.variable;function getFilteredNodesXToY(e,t,n){for(var r={},o={},a=0;a<t.length;a++)r[t[a].id]=!0;for(a=0;a<e.length;a++){var i=(f=e[a]).inputs;for(var s in i){for(var u=i[s],l=!1,c=0;c<t.length;c++)if(r[u.id]){f.outputs.forEach(function(e){return r[e.id]=!0}),l=!0,o[f.id]=!0;break}if(l)break}}var p={};p[n.id]=!0;var d={};for(a=e.length-1;a>=0;a--)for(i=(f=e[a]).inputs,c=0;c<f.outputs.length;c++)if(p[f.outputs[c].id]){for(var s in i)p[i[s].id]=!0,d[f.id]=!0;break}var h=[];for(a=0;a<e.length;a++){var f;if(o[(f=e[a]).id]&&d[f.id]){var m={};for(var s in f.inputs){var g=f.inputs[s];r[g.id]&&(m[s]=g);}var v=Object.assign({},f);v.inputs=m,v.outputs=f.outputs,h.push(v);}}return h}function backpropagateGradients(e,t){for(var n=function(n){var r=t[n],o=[];if(r.outputs.forEach(function(t){var n=e[t.id];if(null!=n)o.push(n);else{var r=Tensor.make(t.shape,{values:makeZerosTypedArray(t.size,t.dtype)},t.dtype);o.push(r);}}),null==r.gradient)throw new Error(\"Cannot compute gradient: gradient function not found for \"+r.name+\".\");var a=r.gradient(1===r.outputs.length?o[0]:o);for(var i in r.inputs){if(!(i in a))throw new Error(\"Cannot backprop through input \"+i+\". Available gradients found: \"+Object.keys(a)+\".\");var s=a[i]();if(\"float32\"!==s.dtype)throw new Error(\"Error in gradient for op \"+r.name+\". The gradient of input \"+i+\" must have 'float32' dtype, but has '\"+s.dtype+\"'\");var u=r.inputs[i];if(!arraysEqual(s.shape,u.shape))throw new Error(\"Error in gradient for op \"+r.name+\". The gradient of input '\"+i+\"' has shape '\"+s.shape+\"', which does not match the shape of the input '\"+u.shape+\"'\");if(null==e[u.id])e[u.id]=s;else{var l=e[u.id];e[u.id]=l.add(s),l.dispose();}}},r=t.length-1;r>=0;r--)n(r);}!function(e){e.R0=\"R0\",e.R1=\"R1\",e.R2=\"R2\",e.R3=\"R3\",e.R4=\"R4\",e.R5=\"R5\",e.R6=\"R6\";}(Rank||(Rank={})),function(e){e.float32=\"float32\",e.int32=\"int32\",e.bool=\"int32\",e.complex64=\"complex64\";}(UpcastInt32AndMap||(UpcastInt32AndMap={})),function(e){e.float32=\"float32\",e.int32=\"int32\",e.bool=\"bool\",e.complex64=\"complex64\";}(UpcastBoolAndMap||(UpcastBoolAndMap={})),function(e){e.float32=\"float32\",e.int32=\"float32\",e.bool=\"float32\",e.complex64=\"complex64\";}(UpcastFloat32AndMap||(UpcastFloat32AndMap={})),function(e){e.float32=\"complex64\",e.int32=\"complex64\",e.bool=\"complex64\",e.complex64=\"complex64\";}(UpcastComplex64AndMap||(UpcastComplex64AndMap={}));var upcastTypeMap={float32:UpcastFloat32AndMap,int32:UpcastInt32AndMap,bool:UpcastBoolAndMap,complex64:UpcastComplex64AndMap};function upcastType(e,t){if(\"string\"===e||\"string\"===t){if(\"string\"===e&&\"string\"===t)return \"string\";throw new Error(\"Can not upcast \"+e+\" with \"+t)}return upcastTypeMap[e][t]}function sumOutType(e){return upcastType(e,\"int32\")}function makeTypesMatch(e,t){if(e.dtype===t.dtype)return [e,t];var n=upcastType(e.dtype,t.dtype);return [e.cast(n),t.cast(n)]}function assertTypesMatch(e,t){assert(e.dtype===t.dtype,\"The dtypes of the first(\"+e.dtype+\") and second(\"+t.dtype+\") input must match\");}function isTensorInList(e,t){for(var n=0;n<t.length;n++)if(t[n].id===e.id)return !0;return !1}function getTensorsInContainer(e){var t=[];return walkTensorContainer(e,t,new Set),t}function walkTensorContainer(e,t,n){if(null!=e)if(e instanceof Tensor)t.push(e);else if(isIterable(e)){var r=e;for(var o in r){var a=r[o];n.has(a)||(n.add(a),walkTensorContainer(a,t,n));}}}function isIterable(e){return Array.isArray(e)||\"object\"==typeof e}var Type,Engine=function(){function e(e,t,n){this.backend=e,this.safeMode=t,this.debugMode=n,this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.profiling=!1,this.gradientScopeCount=0,this.customGradientDepth=0,this.scopeStack=[],this.keepTensors=new Set,this.tensorInfo=new WeakMap,this.profiler=new Profiler(e),this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null};}return e.prototype.moveData=function(e){this.write(e,this.readSync(e));},e.prototype.tidy=function(e,t,n){var r=this;void 0===n&&(n=!1);var o,a=null;if(null==t){if(\"function\"!=typeof e)throw new Error(\"Please provide a function to tidy()\");t=e;}else{if(\"string\"!=typeof e&&!(e instanceof String))throw new Error(\"When calling with two arguments, the first argument to tidy() must be a string\");if(\"function\"!=typeof t)throw new Error(\"When calling with two arguments, the 2nd argument to tidy() must be a function\");a=e;}return this.scopedRun(function(){return r.startScope(a,n)},function(){return r.endScope(o,n)},function(){return (o=t())instanceof Promise&&console.error(\"Cannot return a Promise inside of tidy.\"),o})},e.prototype.scopedRun=function(e,t,n){e();try{var r=n();return t(),r}catch(e){throw t(),e}},e.prototype.nextTensorId=function(){return e.nextTensorId++},e.prototype.nextVariableId=function(){return e.nextVariableId++},e.prototype.runKernel=function(e,t,n){var r,o=this,a=[],i=function(e){return a.push(e),e},s=this.activeScope.name,u=this.numBytes,l=this.numTensors;if(this.scopedRun(function(){return o.customGradientDepth++},function(){return o.customGradientDepth--},function(){r=o.debugMode()?o.profiler.profileKernel(s,function(){return e(o.backend,i)}):e(o.backend,i);}),this.shouldRecord()){var c={id:this.nextTapeNodeId++,name:s,inputs:t,outputs:Array.isArray(r)?r:[r]};null!=n&&(c.gradient=function(e){return n(e,a)}),this.activeTape.push(c);}return this.profiling&&this.activeProfile.kernels.push({name:s,bytesAdded:this.numBytes-u,totalBytesSnapshot:this.numBytes,tensorsAdded:this.numTensors-l,totalTensorsSnapshot:this.numTensors,inputShapes:Object.keys(t).map(function(e){return t[e].shape}),outputShape:Array.isArray(r)?r.map(function(e){return e.shape}):r.shape}),r},e.prototype.registerTensor=function(e){var t=this.tensorInfo.has(e.dataId)?this.tensorInfo.get(e.dataId).refCount:0;if(this.numTensors++,\"string\"===e.dtype&&this.numStringTensors++,0===t){this.numDataBuffers++;var n=0;\"complex64\"!==e.dtype&&\"string\"!==e.dtype&&(n=sizeFromShape(e.shape)*bytesPerElement(e.dtype)),this.tensorInfo.set(e.dataId,{backend:this.backend,dtype:e.dtype,shape:e.shape,bytes:n,refCount:0}),this.numBytes+=n,this.backend.register(e.dataId,e.shape,e.dtype);}this.tensorInfo.get(e.dataId).refCount++,e instanceof Variable||this.track(e);},e.prototype.registerVariable=function(e){if(null!=this.registeredVariables[e.name])throw new Error(\"Variable with name \"+e.name+\" was already registered\");this.registeredVariables[e.name]=e;},e.prototype.disposeTensor=function(e){if(this.tensorInfo.has(e.dataId)){this.keepTensors.has(e.id)&&this.keepTensors.delete(e.id),this.numTensors--,\"string\"===e.dtype&&this.numStringTensors--;var t=this.tensorInfo.get(e.dataId);t.refCount<=1?(\"complex64\"!==e.dtype&&(this.numBytes-=t.bytes),this.numDataBuffers--,t.backend.disposeData(e.dataId),this.tensorInfo.delete(e.dataId)):this.tensorInfo.get(e.dataId).refCount--;}},e.prototype.disposeVariables=function(){for(var e in this.registeredVariables){var t=this.registeredVariables[e];this.disposeTensor(t),delete this.registeredVariables[e];}},e.prototype.memory=function(){var e=this.backend.memory();return e.numTensors=this.numTensors,e.numDataBuffers=this.numDataBuffers,e.numBytes=this.numBytes,this.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push(\"Memory usage by string tensors is approximate (2 bytes per character)\")),e},e.prototype.profile=function(e){return __awaiter(this,void 0,void 0,function(){var t,n;return __generator(this,function(r){return this.profiling=!0,t=this.numBytes,n=this.numTensors,this.activeProfile.kernels=[],this.activeProfile.result=e(),this.profiling=!1,this.activeProfile.peakBytes=Math.max.apply(Math,this.activeProfile.kernels.map(function(e){return e.totalBytesSnapshot})),this.activeProfile.newBytes=this.numBytes-t,this.activeProfile.newTensors=this.numTensors-n,[2,this.activeProfile]})})},e.prototype.shouldRecord=function(){return null!=this.activeTape&&0===this.customGradientDepth},e.prototype.addTapeNode=function(e,t,n){var r={};e.forEach(function(e,t){r[t]=e;});var o={id:this.nextTapeNodeId++,name:this.activeScope.name,inputs:r,outputs:[t],gradient:function(e){var t={};return n(e).forEach(function(e,n){t[n]=function(){return e};}),t}};this.activeTape.push(o);},e.prototype.keep=function(e){if(1===this.scopeStack.length&&this.safeMode)throw new Error(\"Safe mode is ON. Enclose all tensor operations inside tf.tidy(): tf.tidy(() => {...}) to avoid memory leaks.\");return this.keepTensors.add(e.id),e},e.prototype.startScope=function(e,t){void 0===t&&(t=!1),t&&0===this.gradientScopeCount&&(this.activeTape=[]),t&&this.gradientScopeCount++;var n={track:[],name:\"unnamed scope\"};e&&(n.name=e),this.scopeStack.push(n),this.activeScope=n;},e.prototype.endScope=function(e,t){var n=this;void 0===t&&(t=!1),t&&(this.gradientScopeCount--,0===this.gradientScopeCount&&(this.activeTape=null));var r=new Set(this.keepTensors),o=getTensorsInContainer(e);o.forEach(function(e){return r.add(e.id)});for(var a=0;a<this.activeScope.track.length;a++){var i=this.activeScope.track[a];r.has(i.id)||(null!=this.activeTape?o.push(i):i.dispose());}var s=this.scopeStack.pop();this.activeScope=0===this.scopeStack.length?null:this.scopeStack[this.scopeStack.length-1],o.forEach(function(e){!n.keepTensors.has(e.id)&&isTensorInList(e,s.track)&&n.track(e);});},e.prototype.gradients=function(e,t,n,r){var o=this;if(void 0===r&&(r=!1),assert(t.length>0,\"gradients() received an empty list of xs.\"),null!=n&&\"float32\"!==n.dtype)throw new Error(\"dy must have 'float32' dtype, but has '\"+n.dtype+\"'\");return this.tidy(\"gradients\",function(){var a=e();assert(a instanceof Tensor,\"The result y returned by f() must be a tensor.\");var i=getFilteredNodesXToY(o.activeTape,t,a);if(!r&&0===i.length&&t.length>0)throw new Error(\"Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.\");var s={};return s[a.id]=null==n?ones(a.shape):n,backpropagateGradients(s,i),{value:a,grads:t.map(function(e){return s[e.id]})}},!0)},e.prototype.customGrad=function(e){var t=this;return assert(isFunction(e),\"The f passed in customGrad(f) must be a function.\"),function(){for(var n,r,o=[],a=0;a<arguments.length;a++)o[a]=arguments[a];if(assert(o.every(function(e){return e instanceof Tensor}),\"The args passed in customGrad(f)(x1, x2,...) must all be tensors\"),t.scopedRun(function(){return t.customGradientDepth++},function(){return t.customGradientDepth--},function(){r=t.tidy(e.name,function(){var t=e.apply(void 0,o),r=t.value,a=t.gradFunc;return assert(r instanceof Tensor,\"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor\"),assert(isFunction(a),\"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.\"),n=a,r},!0);}),t.shouldRecord()){t.addTapeNode(o,r,function(e){var t=n(e),r=Array.isArray(t)?t:[t];return assert(r.length===o.length,\"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).\"),assert(r.every(function(e){return e instanceof Tensor}),\"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.\"),r});}return r}},e.prototype.write=function(e,t){var n=this.tensorInfo.get(e);if(\"string\"===n.dtype){var r=bytesFromStringArray(t);this.numBytes+=r-n.bytes,n.bytes=r;}this.backend!==n.backend&&(n.backend.disposeData(e),n.backend=this.backend,this.backend.register(e,n.shape,n.dtype)),this.backend.write(e,t);},e.prototype.readSync=function(e){return this.tensorInfo.get(e).backend.readSync(e)},e.prototype.read=function(e){return this.tensorInfo.get(e).backend.read(e)},e.prototype.fromPixels=function(e,t){return this.backend.fromPixels(e,t)},e.prototype.time=function(e){return __awaiter(this,void 0,void 0,function(){var t,n;return __generator(this,function(r){switch(r.label){case 0:return t=now(),[4,this.backend.time(e)];case 1:return (n=r.sent()).wallMs=now()-t,[2,n]}})})},e.prototype.track=function(e){if(1===this.scopeStack.length&&this.safeMode)throw new Error(\"Safe mode is ON. Enclose all tensor operations inside tf.tidy(): tf.tidy(() => {op();...}); to avoid memory leaks.\");return null!=this.activeScope&&this.activeScope.track.push(e),e},e.nextTensorId=0,e.nextVariableId=0,e}();function ones(e){var t=makeOnesTypedArray(sizeFromShape(e),\"float32\");return Tensor.make(e,{values:t})}!function(e){e[e.NUMBER=0]=\"NUMBER\",e[e.BOOLEAN=1]=\"BOOLEAN\",e[e.STRING=2]=\"STRING\";}(Type||(Type={}));var MAX_TEXTURE_SIZE,URL_PROPERTIES=[{name:\"DEBUG\",type:Type.BOOLEAN},{name:\"IS_BROWSER\",type:Type.BOOLEAN},{name:\"WEBGL_LAZILY_UNPACK\",type:Type.BOOLEAN},{name:\"WEBGL_CPU_FORWARD\",type:Type.BOOLEAN},{name:\"WEBGL_PACK\",type:Type.BOOLEAN},{name:\"WEBGL_PACK_BATCHNORMALIZATION\",type:Type.BOOLEAN},{name:\"WEBGL_PACK_CLIP\",type:Type.BOOLEAN},{name:\"WEBGL_PACK_DEPTHWISECONV\",type:Type.BOOLEAN},{name:\"WEBGL_CONV_IM2COL\",type:Type.BOOLEAN},{name:\"WEBGL_MAX_TEXTURE_SIZE\",type:Type.NUMBER},{name:\"WEBGL_PAGING_ENABLED\",type:Type.BOOLEAN},{name:\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\",type:Type.NUMBER},{name:\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE\",type:Type.BOOLEAN},{name:\"WEBGL_VERSION\",type:Type.NUMBER},{name:\"WEBGL_RENDER_FLOAT32_ENABLED\",type:Type.BOOLEAN},{name:\"WEBGL_DOWNLOAD_FLOAT_ENABLED\",type:Type.BOOLEAN},{name:\"WEBGL_FENCE_API_ENABLED\",type:Type.BOOLEAN},{name:\"WEBGL_SIZE_UPLOAD_UNIFORM\",type:Type.NUMBER},{name:\"BACKEND\",type:Type.STRING},{name:\"EPSILON\",type:Type.NUMBER},{name:\"PROD\",type:Type.BOOLEAN},{name:\"TENSORLIKE_CHECK_SHAPE_CONSISTENCY\",type:Type.BOOLEAN}];function isWebGLVersionEnabled(e){try{if(null!=getWebGLContext(e))return !0}catch(e){return !1}return !1}function getWebGLMaxTextureSize(e){if(null==MAX_TEXTURE_SIZE){var t=getWebGLContext(e);MAX_TEXTURE_SIZE=t.getParameter(t.MAX_TEXTURE_SIZE);}return MAX_TEXTURE_SIZE}function getWebGLDisjointQueryTimerVersion(e){if(0===e)return 0;var t=getWebGLContext(e);return hasExtension(t,\"EXT_disjoint_timer_query_webgl2\")&&2===e?2:hasExtension(t,\"EXT_disjoint_timer_query\")?1:0}function isRenderToFloatTextureEnabled(e){if(0===e)return !1;var t=getWebGLContext(e);if(1===e){if(!hasExtension(t,\"OES_texture_float\"))return !1}else if(!hasExtension(t,\"EXT_color_buffer_float\"))return !1;return createFloatTextureAndBindToFramebuffer(t,e)}function isDownloadFloatTextureEnabled(e){if(0===e)return !1;var t=getWebGLContext(e);if(1===e){if(!hasExtension(t,\"OES_texture_float\"))return !1;if(!hasExtension(t,\"WEBGL_color_buffer_float\"))return !1}else if(!hasExtension(t,\"EXT_color_buffer_float\"))return !1;return createFloatTextureAndBindToFramebuffer(t,e)}function isWebGLFenceEnabled(e){return 2===e&&null!=getWebGLContext(e).fenceSync}function isChrome(){return \"undefined\"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)}var TENSORFLOWJS_FLAGS_PREFIX=\"tfjsflags\";function getFeaturesFromURL(){var e={};if(\"undefined\"==typeof window||void 0===window.location||void 0===window.location.search)return e;var t=getQueryParams(window.location.search);if(TENSORFLOWJS_FLAGS_PREFIX in t){var n={};t[TENSORFLOWJS_FLAGS_PREFIX].split(\",\").forEach(function(e){var t=e.split(\":\"),r=t[0],o=t[1];n[r]=o;}),URL_PROPERTIES.forEach(function(t){t.name in n&&(console.log(\"Setting feature override from URL \"+t.name+\": \"+n[t.name]),t.type===Type.NUMBER?e[t.name]=+n[t.name]:t.type===Type.BOOLEAN?e[t.name]=\"true\"===n[t.name]:t.type===Type.STRING?e[t.name]=n[t.name]:console.warn(\"Unknown URL param: \"+t.name+\".\"));});}return e}function hasExtension(e,t){return null!=e.getExtension(t)}function createFloatTextureAndBindToFramebuffer(e,t){var n=e.createFramebuffer(),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r);var o=2===t?e.RGBA32F:e.RGBA;e.texImage2D(e.TEXTURE_2D,0,o,1,1,0,e.RGBA,e.FLOAT,null),e.bindFramebuffer(e.FRAMEBUFFER,n),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);var a=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(n),a}function getQueryParams(e){var t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,function(e){for(var n=[],r=1;r<arguments.length;r++)n[r-1]=arguments[r];return decodeParam(t,n[0],n[1]),n.join(\"=\")}),t}function decodeParam(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||\"\");}var EPSILON_FLOAT16=1e-4,TEST_EPSILON_FLOAT16=.1,EPSILON_FLOAT32=1e-7,TEST_EPSILON_FLOAT32=.001,Environment=function(){function e(e){this.features={},this.registry={},null!=e&&(this.features=e),this.get(\"DEBUG\")&&console.warn(\"Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.\");}return e.setBackend=function(e,t){if(void 0===t&&(t=!1),!(e in ENV.registry))throw new Error(\"Backend name '\"+e+\"' not found in registry\");ENV.engine.backend=ENV.findBackend(e),ENV.backendName=e;},e.getBackend=function(){return ENV.initEngine(),ENV.backendName},e.disposeVariables=function(){ENV.engine.disposeVariables();},e.memory=function(){return ENV.engine.memory()},e.profile=function(e){return ENV.engine.profile(e)},e.tidy=function(e,t){return ENV.engine.tidy(e,t)},e.dispose=function(e){getTensorsInContainer(e).forEach(function(e){return e.dispose()});},e.keep=function(e){return ENV.engine.keep(e)},e.time=function(e){return ENV.engine.time(e)},e.prototype.get=function(e){return e in this.features?this.features[e]:(this.features[e]=this.evaluateFeature(e),this.features[e])},e.prototype.getFeatures=function(){return this.features},e.prototype.set=function(e,t){this.features[e]=t;},e.prototype.getBestBackendName=function(){var e=this;if(0===Object.keys(this.registry).length)throw new Error(\"No backend found in registry.\");return Object.keys(this.registry).map(function(t){return {name:t,entry:e.registry[t]}}).sort(function(e,t){return t.entry.priority-e.entry.priority})[0].name},e.prototype.evaluateFeature=function(e){if(\"DEBUG\"===e)return !1;if(\"IS_BROWSER\"===e)return \"undefined\"!=typeof window;if(\"IS_NODE\"===e)return \"undefined\"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node;if(\"IS_CHROME\"===e)return isChrome();if(\"WEBGL_CPU_FORWARD\"===e)return !0;if(\"WEBGL_PACK\"===e)return !1;if(\"WEBGL_PACK_BATCHNORMALIZATION\"===e)return this.get(\"WEBGL_PACK\");if(\"WEBGL_PACK_CLIP\"===e)return this.get(\"WEBGL_PACK\");if(\"WEBGL_PACK_DEPTHWISECONV\"===e)return this.get(\"WEBGL_PACK\");if(\"WEBGL_LAZILY_UNPACK\"===e)return this.get(\"WEBGL_PACK\");if(\"WEBGL_CONV_IM2COL\"===e)return this.get(\"WEBGL_PACK\");if(\"WEBGL_PAGING_ENABLED\"===e)return this.get(\"IS_BROWSER\")&&!this.get(\"PROD\");if(\"WEBGL_MAX_TEXTURE_SIZE\"===e)return getWebGLMaxTextureSize(this.get(\"WEBGL_VERSION\"));if(\"IS_TEST\"===e)return !1;if(\"BACKEND\"===e)return this.getBestBackendName();if(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\"===e){var t=this.get(\"WEBGL_VERSION\");return 0===t?0:getWebGLDisjointQueryTimerVersion(t)}if(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE\"===e)return this.get(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\")>0&&!isMobile();if(\"HAS_WEBGL\"===e)return this.get(\"WEBGL_VERSION\")>0;if(\"WEBGL_VERSION\"===e)return isWebGLVersionEnabled(2)?2:isWebGLVersionEnabled(1)?1:0;if(\"WEBGL_RENDER_FLOAT32_ENABLED\"===e)return isRenderToFloatTextureEnabled(this.get(\"WEBGL_VERSION\"));if(\"WEBGL_DOWNLOAD_FLOAT_ENABLED\"===e)return isDownloadFloatTextureEnabled(this.get(\"WEBGL_VERSION\"));if(\"WEBGL_FENCE_API_ENABLED\"===e)return isWebGLFenceEnabled(this.get(\"WEBGL_VERSION\"));if(\"WEBGL_SIZE_UPLOAD_UNIFORM\"===e)return this.get(\"WEBGL_RENDER_FLOAT32_ENABLED\")?4:0;if(\"TEST_EPSILON\"===e)return 32===this.backend.floatPrecision()?TEST_EPSILON_FLOAT32:TEST_EPSILON_FLOAT16;if(\"EPSILON\"===e)return 32===this.backend.floatPrecision()?EPSILON_FLOAT32:EPSILON_FLOAT16;if(\"PROD\"===e)return !1;if(\"TENSORLIKE_CHECK_SHAPE_CONSISTENCY\"===e)return !this.get(\"PROD\");throw new Error(\"Unknown feature \"+e+\".\")},e.prototype.setFeatures=function(e){this.features=Object.assign({},e);},e.prototype.reset=function(){this.features=getFeaturesFromURL(),null!=this.globalEngine&&(this.globalEngine=null);},Object.defineProperty(e.prototype,\"backend\",{get:function(){return this.engine.backend},enumerable:!0,configurable:!0}),e.prototype.findBackend=function(e){return e in this.registry?this.registry[e].backend:null},e.prototype.registerBackend=function(e,t,n,r){var o=this;if(void 0===n&&(n=1),e in this.registry)return console.warn(e+\" backend was already registered. Reusing existing backend\"),null!=r&&r(function(){return o.engine}),!1;try{var a=t();return a.setDataMover({moveData:function(e){return o.engine.moveData(e)}}),this.registry[e]={backend:a,priority:n},!0}catch(t){return console.warn(\"Registration of backend \"+e+\" failed\"),console.warn(t.stack||t.message),!1}},e.prototype.removeBackend=function(e){if(!(e in this.registry))throw new Error(e+\" backend not found in registry\");this.registry[e].backend.dispose(),delete this.registry[e];},Object.defineProperty(e.prototype,\"engine\",{get:function(){return this.initEngine(),this.globalEngine},enumerable:!0,configurable:!0}),e.prototype.initEngine=function(){var e=this;if(null==this.globalEngine){this.backendName=this.get(\"BACKEND\");var t=this.findBackend(this.backendName);this.globalEngine=new Engine(t,!1,function(){return e.get(\"DEBUG\")});}},e}();function getGlobalNamespace(){var e;if(\"undefined\"!=typeof window)e=window;else{if(\"undefined\"==typeof process)throw new Error(\"Could not find a global object\");e=process;}return e}function getOrMakeEnvironment(){var e=getGlobalNamespace();return null==e.ENV&&(e.ENV=new Environment(getFeaturesFromURL()),setTensorTracker(function(){return e.ENV.engine})),e.ENV}var ENV=getOrMakeEnvironment(),environment=Object.freeze({EPSILON_FLOAT16:EPSILON_FLOAT16,EPSILON_FLOAT32:EPSILON_FLOAT32,Environment:Environment,ENV:ENV});function grad(e){return assert(isFunction(e),\"The f passed in grad(f) must be a function\"),function(t,n){return assert(t instanceof Tensor,\"The x passed in grad(f)(x) must be a tensor\"),assert(null==n||n instanceof Tensor,\"The dy passed in grad(f)(x, dy) must be a tensor\"),ENV.engine.tidy(function(){var r=ENV.engine.gradients(function(){return e(t)},[t],n),o=r.value,a=r.grads;return null!=n&&assertShapesMatch(o.shape,n.shape,\"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)\"),checkGrads(a),a[0]})}}function grads(e){return assert(isFunction(e),\"The f passed in grads(f) must be a function\"),function(t,n){return assert(Array.isArray(t)&&t.every(function(e){return e instanceof Tensor}),\"The args passed in grads(f)(args) must be an array of tensors\"),assert(null==n||n instanceof Tensor,\"The dy passed in grads(f)(args, dy) must be a tensor\"),ENV.engine.tidy(function(){var r=ENV.engine.gradients(function(){return e.apply(void 0,t)},t,n),o=r.value,a=r.grads;return null!=n&&assertShapesMatch(o.shape,n.shape,\"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])\"),checkGrads(a),a})}}function valueAndGrad(e){return assert(isFunction(e),\"The f passed in valueAndGrad(f) must be a function\"),function(t,n){assert(t instanceof Tensor,\"The x passed in valueAndGrad(f)(x) must be a tensor\"),assert(null==n||n instanceof Tensor,\"The dy passed in valueAndGrad(f)(x, dy) must be a tensor\");var r=ENV.engine.gradients(function(){return e(t)},[t],n),o=r.grads,a=r.value;return checkGrads(o),{grad:o[0],value:a}}}function valueAndGrads(e){return assert(isFunction(e),\"The f passed in valueAndGrads(f) must be a function\"),function(t,n){assert(Array.isArray(t)&&t.every(function(e){return e instanceof Tensor}),\"The args passed in valueAndGrads(f)(args) must be array of tensors\"),assert(null==n||n instanceof Tensor,\"The dy passed in valueAndGrads(f)(args, dy) must be a tensor\");var r=ENV.engine.gradients(function(){return e.apply(void 0,t)},t,n);return null!=n&&assertShapesMatch(r.value.shape,n.shape,\"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])\"),checkGrads(r.grads),r}}function variableGrads(e,t){if(assert(isFunction(e),\"The f passed in variableGrads(f) must be a function\"),assert(null==t||Array.isArray(t)&&t.every(function(e){return e instanceof Variable}),\"The varList passed in variableGrads(f, varList) must be an array of variables\"),null==t)for(var n in t=[],ENV.engine.registeredVariables)t.push(ENV.engine.registeredVariables[n]);var r=t.length;assert((t=t.filter(function(e){return e.trainable})).length>0,\"variableGrads() expects at least one of the input variables to be trainable, but none of the \"+r+\" variables is trainable.\");var o=ENV.engine.gradients(e,t,null,!0),a=o.value,i=o.grads;assert(i.some(function(e){return null!=e}),\"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().\"),assert(0===a.rank,\"The f passed in variableGrads(f) must return a scalar, but it returned a rank-\"+a.rank+\" tensor\");var s={};return t.forEach(function(e,t){null!=i[t]&&(s[e.name]=i[t]);}),{value:a,grads:s}}function customGrad(e){return ENV.engine.customGrad(e)}function checkGrads(e){if(e.filter(function(e){return null==e}).length>0)throw new Error(\"Cannot compute gradient of y=f(x) with respect to x. Make sure that\\n    the f you passed encloses all operations that lead from x to y.\")}var tidy=Environment.tidy,keep=Environment.keep,dispose=Environment.dispose,time=Environment.time,profile=Environment.profile;function warn(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];ENV.get(\"IS_TEST\")||console.warn.apply(console,e);}function getReshaped(e,t,n,r){void 0===r&&(r=!0);var o=[];if(r)(o=o.concat(t.slice(0))).push(e[0]/n),o=o.concat(e.slice(1));else{o=o.concat(e[0]);for(var a=t.length,i=0;i<a;++i)o=o.concat([e[i+1]/t[i],t[i]]);o=o.concat(e.slice(a+1));}return o}function getPermuted(e,t,n){void 0===n&&(n=!0);var r=[];if(n){r.push(t);for(var o=t+1;o<e;++o)o<=2*t?(r.push(o),r.push(o-(t+1))):r.push(o);}else{var a=[],i=[];for(o=1;o<e;++o)o>=2*t+1||o%2==1?i.push(o):a.push(o);r.push.apply(r,a),r.push(0),r.push.apply(r,i);}return r}function getReshapedPermuted(e,t,n,r){void 0===r&&(r=!0);var o=[];r?o.push(e[0]/n):o.push(e[0]*n);for(var a=1;a<e.length;++a)a<=t.length?r?o.push(t[a-1]*e[a]):o.push(e[a]/t[a-1]):o.push(e[a]);return o}function getSliceBeginCoords(e,t){for(var n=[0],r=0;r<t;++r)n.push(e[r][0]);return n}function getSliceSize(e,t,n){for(var r=e.slice(0,1),o=0;o<n;++o)r.push(e[o+1]-t[o][0]-t[o][1]);return r}function axesAreInnerMostDims(e,t){for(var n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return !1;return !0}function combineLocations(e,t,n){for(var r=e.length+t.length,o=[],a=0,i=0,s=0;s<r;s++)-1===n.indexOf(s)?o.push(e[a++]):o.push(t[i++]);return o}function computeOutAndReduceShapes(e,t){for(var n=[],r=e.length,o=0;o<r;o++)-1===t.indexOf(o)&&n.push(e[o]);return [n,t.map(function(t){return e[t]})]}function expandShapeToKeepDim(e,t){return combineLocations(e,t.map(function(e){return 1}),t)}function parseAxisParam(e,t){var n=t.length;return assert((e=null==e?t.map(function(e,t){return t}):[].concat(e)).every(function(e){return e>=-n&&e<n}),\"All values in axis param must be in range [-\"+n+\", \"+n+\") but got axis \"+e),assert(e.every(function(e){return isInt(e)}),\"All values in axis param must be integers but got axis \"+e),e.map(function(e){return e<0?n+e:e})}function assertAxesAreInnerMostDims(e,t,n){assert(axesAreInnerMostDims(t,n),e+\" supports only inner-most axes for now. Got axes \"+t+\" and rank-\"+n+\" input.\");}function getAxesPermutation(e,t){if(axesAreInnerMostDims(e,t))return null;for(var n=[],r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);return e.forEach(function(e){return n.push(e)}),n}function getUndoAxesPermutation(e){return e.map(function(e,t){return [t,e]}).sort(function(e,t){return e[1]-t[1]}).map(function(e){return e[0]})}function getInnerMostAxes(e,t){for(var n=[],r=t-e;r<t;++r)n.push(r);return n}function assertParamsConsistent(e,t){var n=e[0].length;e.forEach(function(e,t){assert(e.length===n,\"Error in concat\"+n+\"D: rank of tensors[\"+t+\"] must be the same as the rank of the rest (\"+n+\")\");}),assert(t>=0&&t<n,\"Error in concat\"+n+\"D: axis must be between 0 and \"+(n-1)+\".\");var r=e[0];e.forEach(function(e,o){for(var a=0;a<n;a++)assert(a===t||e[a]===r[a],\"Error in concat\"+n+\"D: Shape of tensors[\"+o+\"] (\"+e+\") does not match the shape of the rest (\"+r+\") along the non-concatenated axis \"+o+\".\");});}function computeOutShape(e,t){for(var n=e[0].slice(),r=1;r<e.length;r++)n[t]+=e[r][t];return n}function prepareAndValidate(e,t){if(e.rank<1)throw new Error(\"tf.gatherND() expects the input to be rank 1 or higher, but the rank was \"+e.rank+\".\");if(t.rank<1)throw new Error(\"tf.gatherND() expects the indices to be rank 1 or higher, but the rank was \"+t.rank+\".\");if(\"int32\"!==t.dtype)throw new Error(\"tf.gatherND() expects the indices to be int32 type, but the dtype was \"+t.dtype+\".\");if(t.shape[t.rank-1]>e.rank)throw new Error(\"index innermost dimension length must be <= tensor rank; saw: \"+t.shape[t.rank-1]+\" vs. \"+e.rank);if(0===e.size)throw new Error(\"Requested more than 0 entries, but input is empty. Input shape: \"+e.shape+\".\");for(var n=t.shape,r=n[n.length-1],o=1,a=0;a<n.length-1;++a)o*=n[a];var i=e.shape,s=n.slice();s.pop();var u=1;for(a=r;a<e.rank;++a)u*=i[a],s.push(i[a]);var l=computeStrides(e.shape).map(function(e){return e/u}).concat([1]).slice(0,r);return [s,o,u,l]}var PARALLELIZE_THRESHOLD=30;function computeOptimalWindowSize(e){return e<=PARALLELIZE_THRESHOLD?e:nearestDivisor(e,Math.floor(Math.sqrt(e)))}function validateUpdateShape(e,t,n){var r=t.rank>1?t.shape[t.rank-1]:1,o=t.rank>1?t.rank-1:1,a=\"Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: \"+n.shape+\", indices.shape: \"+t.shape+\", shape: \"+e+\", sliceDim: \"+r+\", and batchDim: \"+o+\".\";if(n.rank<o)throw new Error(a+\" update.rank < \"+o+\". \");if(e.length<r+(n.rank-o))throw new Error(a+\" Output shape length < \"+(r+(n.rank-o)));if(n.rank!==o+e.length-r)throw new Error(a+\" update.rank != \"+(o+e.length-r));for(var i=0;i<o;++i)if(n.shape[i]!==t.shape[i])throw new Error(a+\" updates.shape[\"+i+\"] (\"+n.shape[i]+\") != indices.shape[\"+i+\"] (\"+t.shape[i]+\").\");for(i=0;i<n.rank-o;++i)if(n.shape[i+o]!==e[i+r])throw new Error(a+\" updates.shape[\"+(i+o)+\"] (\"+n.shape[i+o]+\") != shape[\"+(i+o)+\"] (\"+e[i+o]+\")\")}function validateInput(e,t,n){if(t.rank<1)throw new Error(\"tf.scatterND() expects the indices to be rank 1 or higher, but the rank was \"+t.rank+\".\");if(e.rank<1)throw new Error(\"tf.scatterND() expects the updates to be rank 1 or higher, but the rank was \"+e.rank+\".\");if(\"int32\"!==t.dtype)throw new Error(\"The dtype of 'indices' should be int32, but got dtype: \"+t.dtype);if(n.length<1)throw new Error(\"Output rank must be greater or equal to 1, but got shape: \"+n);if(0===n.length){if(0===t.size)throw new Error(\"Indices specified for empty output. indices shape: \"+t.shape);if(0===e.size)throw new Error(\"Updates specified for empty output. updates shape: \"+e.shape)}validateUpdateShape(n,t,e);}function calculateShapes(e,t,n){for(var r=t.rank>1?t.shape[t.rank-1]:1,o=n.length,a=1,i=r;i<o;++i)a*=n[i];var s=r<1?1:r,u=t.size/s,l=computeStrides(n).concat([1]);return {sliceRank:r,numUpdates:u,sliceSize:a,strides:l.slice(l.length-r,l.length),outputSize:sizeFromShape(n)}}function segOpComputeOptimalWindowSize(e,t){var n,r=!1;for(e<=PARALLELIZE_THRESHOLD?(n=e,r=!0):n=nearestDivisor(e,Math.floor(Math.sqrt(e)));!r;){if(n>t||n===e){r=!0;break}n=nearestDivisor(e,n+1);}return n}function computeOutShape$1(e,t,n){for(var r=[],o=e.length,a=0;a<o;a++)a!==t?r.push(e[a]):r.push(n);return r}function assertParamsValid(e,t,n){assert(e.rank===t.length,\"Error in slice\"+e.rank+\"D: Length of begin \"+t+\" must match the rank of the array (\"+e.rank+\").\"),assert(e.rank===n.length,\"Error in slice\"+e.rank+\"D: Length of size \"+n+\" must match the rank of the array (\"+e.rank+\").\");for(var r=0;r<e.rank;++r)assert(t[r]+n[r]<=e.shape[r],\"Error in slice\"+e.rank+\"D: begin[\"+r+\"] + size[\"+r+\"] (\"+(t[r]+n[r])+\") would overflow input.shape[\"+r+\"] (\"+e.shape[r]+\")\");}function getStridedSlicedInfo(e,t,n,r,o,a,i,s,u){if(void 0===o&&(o=0),void 0===a&&(a=0),void 0===i&&(i=0),void 0===s&&(s=0),void 0===u&&(u=0),0!==i)throw new Error(\"ellipsis mask is not yet supported\");if(0!==s)throw new Error(\"new axis mask is not yet supported\");for(var l=[],c=[],p=[],d=0;d<e.length;d++)l[d]=startForAxis(o,t,r,e,d),c[d]=stopForAxis(a,n,r,e,d),u&1<<d&&(c[d]=l[d]+1,p.push(d));var h=new Array(e.length).fill(0);return h=h.map(function(e,t){for(var n=0,o=l[t];!(r[t]>0?o>=c[t]:o<=c[t]);o+=r[t])n+=1;return n}),[l,h,p]}function startForAxis(e,t,n,r,o){var a=t[o];e&1<<o&&(a=n[o]>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);var i=r[o];return a<0&&(a+=i),a=clamp(0,a,i-1)}function stopForAxis(e,t,n,r,o){var a=t[o];e&1<<o&&(a=n[o]>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);var i=r[o];return a<0&&(a+=i),a=n[o]>0?clamp(0,a,i):clamp(-1,a,i-1)}function inferShape(e){var t=e;if(isTypedArray(e))return [e.length];if(!Array.isArray(e))return [];for(var n=[];t instanceof Array||isTypedArray(t);)n.push(t.length),t=t[0];return e instanceof Array&&ENV.get(\"TENSORLIKE_CHECK_SHAPE_CONSISTENCY\")&&deepAssertShapeConsistency(e,n,[]),n}function deepAssertShapeConsistency(e,t,n){if(n=n||[],e instanceof Array||isTypedArray(e)){assert(t.length>0,function(){return \"Element arr[\"+n.join(\"][\")+\"] should be a primitive, but is an array of \"+e.length+\" elements\"}),assert(e.length===t[0],function(){return \"Element arr[\"+n.join(\"][\")+\"] should have \"+t[0]+\" elements, but has \"+e.length+\" elements\"});for(var r=t.slice(1),o=0;o<e.length;++o)deepAssertShapeConsistency(e[o],r,n.concat(o));}else assert(0===t.length,function(){return \"Element arr[\"+n.join(\"][\")+\"] is a primitive, but should be an array/TypedArray of \"+t[0]+\" elements\"});}function assertDtype(e,t,n,r){if(null!=e&&(\"numeric\"!==e&&e!==t||\"numeric\"===e&&\"string\"===t))throw new Error(\"Argument '\"+n+\"' passed to '\"+r+\"' must be \"+e+\" tensor, but got \"+t+\" tensor\")}function convertToTensor(e,t,n,r){if(void 0===r&&(r=\"numeric\"),e instanceof Tensor)return assertDtype(r,e.dtype,t,n),e;var o=inferDtype(e);if(\"string\"!==o&&[\"bool\",\"int32\",\"float32\"].indexOf(r)>=0&&(o=r),assertDtype(r,o,t,n),!isTypedArray(e)&&!Array.isArray(e)&&\"number\"!=typeof e&&\"boolean\"!=typeof e&&\"string\"!=typeof e)throw new Error(\"Argument '\"+t+\"' passed to '\"+n+\"' must be a Tensor or TensorLike, but got '\"+e.constructor.name+\"'\");var a=inferShape(e);isTypedArray(e)||Array.isArray(e)||(e=[e]);var i=\"string\"!==o?toTypedArray(e,o,ENV.get(\"DEBUG\")):flatten(e);return Tensor.make(a,{values:i},o)}function convertToTensorArray(e,t,n){if(!Array.isArray(e))throw new Error(\"Argument \"+t+\" passed to \"+n+\" must be a `Tensor[]` or `TensorLike[]`\");return e.map(function(e,r){return convertToTensor(e,t+\"[\"+r+\"]\",n)})}function op(e){var t=Object.keys(e);if(1!==t.length)throw new Error(\"Please provide an object with a single key (operation name) mapping to a function. Got an object with \"+t.length+\" keys.\");var n=t[0],r=e[n];n.endsWith(\"_\")&&(n=n.substring(0,n.length-1));var o=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];ENV.engine.startScope(n);try{var o=r.apply(void 0,e);return o instanceof Promise&&console.error(\"Cannot return a Promise inside of tidy.\"),ENV.engine.endScope(o),o}catch(e){throw ENV.engine.endScope(null),e}};return Object.defineProperty(o,\"name\",{value:n,configurable:!0}),o}function softmax_(e,t){void 0===t&&(t=-1);var n=convertToTensor(e,\"logits\",\"softmax\");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(\"Softmax along a non-last dimension is not yet supported. Logits was rank \"+n.rank+\" and dim was \"+t);return customGrad(function(e){var n=e.logSumExp([t],!0),r=e.toFloat().sub(n).exp();return {value:r,gradFunc:function(e){var n=e.mul(r);return n.sub(n.sum([t],!0).mul(r))}}})(n)}function logSoftmax_(e,t){void 0===t&&(t=-1);var n=convertToTensor(e,\"logits\",\"logSoftmax\");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(\"Log Softmax along a non-last dimension is not yet supported. Logits was rank \"+n.rank+\" and axis was \"+t);return customGrad(function(e){var n=e.max(t,!0),r=e.sub(n),o=r.toFloat().sub(r.exp().sum(t,!0).log());return {value:o,gradFunc:function(e){var n=o.exp();return e.sub(e.sum(t,!0).mul(n))}}})(n)}var softmax=op({softmax_:softmax_}),logSoftmax=op({logSoftmax_:logSoftmax_});function complex_(e,t){var n=convertToTensor(e,\"real\",\"complex\"),r=convertToTensor(t,\"imag\",\"complex\");return assertShapesMatch(n.shape,r.shape,\"real and imag shapes, \"+n.shape+\" and \"+r.shape+\", must match in call to tf.complex().\"),ENV.engine.runKernel(function(e){return e.complex(n,r)},{$real:n,$imag:r})}function real_(e){var t=convertToTensor(e,\"input\",\"real\");return ENV.engine.runKernel(function(e){return e.real(t)},{$input:t})}function imag_(e){var t=convertToTensor(e,\"input\",\"imag\");return ENV.engine.runKernel(function(e){return e.imag(t)},{$input:t})}var complex=op({complex_:complex_}),real=op({real_:real_}),imag=op({imag_:imag_});function tensor(e,t,n){if(null==n&&(n=inferDtype(e)),\"complex64\"===n)throw new Error(\"Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).\");if(!isTypedArray(e)&&!Array.isArray(e)&&\"number\"!=typeof e&&\"boolean\"!=typeof e&&\"string\"!=typeof e)throw new Error(\"values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray\");var r=inferShape(e);if(null!=t){var o=sizeFromShape(t),a=sizeFromShape(r);assert(o===a,function(){return \"Based on the provided shape, [\"+t+\"], the tensor should have \"+o+\" values but has \"+a});for(var i=0;i<r.length;++i){var s=r[i],u=i!==r.length-1||s!==sizeFromShape(t.slice(i));assert(r[i]===t[i]||!u,function(){return \"Error creating a new Tensor. Inferred shape (\"+r+\") does not match the provided shape (\"+t+\"). \"});}}return isTypedArray(e)||Array.isArray(e)||(e=[e]),t=t||r,e=\"string\"!==n?toTypedArray(e,n,ENV.get(\"DEBUG\")):flatten(e),Tensor.make(t,{values:e},n)}function scalar(e,t){if((isTypedArray(e)||Array.isArray(e))&&\"complex64\"!==t)throw new Error(\"Error creating a new Scalar: value must be a primitive (number|boolean|string)\");return tensor(e,[],t)}function tensor1d(e,t){assertNonNull(e);var n=inferShape(e);if(1!==n.length)throw new Error(\"tensor1d() requires values to be a flat/TypedArray\");return tensor(e,n,t)}function tensor2d(e,t,n){if(assertNonNull(e),null!=t&&2!==t.length)throw new Error(\"tensor2d() requires shape to have two numbers\");var r=inferShape(e);if(2!==r.length&&1!==r.length)throw new Error(\"tensor2d() requires values to be number[][] or flat/TypedArray\");if(1===r.length&&null==t)throw new Error(\"tensor2d() requires shape to be provided when `values` are a flat/TypedArray\");return tensor(e,t=t||r,n)}function tensor3d(e,t,n){if(assertNonNull(e),null!=t&&3!==t.length)throw new Error(\"tensor3d() requires shape to have three numbers\");var r=inferShape(e);if(3!==r.length&&1!==r.length)throw new Error(\"tensor3d() requires values to be number[][][] or flat/TypedArray\");if(1===r.length&&null==t)throw new Error(\"tensor3d() requires shape to be provided when `values` are a flat array\");return tensor(e,t=t||r,n)}function tensor4d(e,t,n){if(assertNonNull(e),null!=t&&4!==t.length)throw new Error(\"tensor4d() requires shape to have four numbers\");var r=inferShape(e);if(4!==r.length&&1!==r.length)throw new Error(\"tensor4d() requires values to be number[][][][] or flat/TypedArray\");if(1===r.length&&null==t)throw new Error(\"tensor4d() requires shape to be provided when `values` are a flat array\");return tensor(e,t=t||r,n)}function tensor5d(e,t,n){if(assertNonNull(e),null!=t&&5!==t.length)throw new Error(\"tensor5d() requires shape to have five numbers\");var r=inferShape(e);if(5!==r.length&&1!==r.length)throw new Error(\"tensor5d() requires values to be number[][][][][] or flat/TypedArray\");if(1===r.length&&null==t)throw new Error(\"tensor5d() requires shape to be provided when `values` are a flat array\");return tensor(e,t=t||r,n)}function tensor6d(e,t,n){if(assertNonNull(e),null!=t&&6!==t.length)throw new Error(\"tensor6d() requires shape to have six numbers\");var r=inferShape(e);if(6!==r.length&&1!==r.length)throw new Error(\"tensor6d() requires values to be number[][][][] or flat/TypedArray\");if(1===r.length&&null==t)throw new Error(\"tensor6d() requires shape to be provided when `values` are a flat array\");return tensor(e,t=t||r,n)}function ones$1(e,t){if(void 0===t&&(t=\"float32\"),\"complex64\"===t){var n=ones$1(e,\"float32\"),r=ones$1(e,\"float32\");return complex(n,r)}var o=makeOnesTypedArray(sizeFromShape(e),t);return Tensor.make(e,{values:o},t)}function zeros(e,t){if(void 0===t&&(t=\"float32\"),\"complex64\"===t){var n=zeros(e,\"float32\"),r=zeros(e,\"float32\");return complex(n,r)}var o=makeZerosTypedArray(sizeFromShape(e),t);return Tensor.make(e,{values:o},t)}function fill(e,t,n){var r=getArrayFromDType(n=n||inferDtype(t),sizeFromShape(e));return r.fill(t),Tensor.make(e,{values:r},n)}function onesLike_(e){var t=convertToTensor(e,\"x\",\"onesLike\");return ones$1(t.shape,t.dtype)}function zerosLike_(e){var t=convertToTensor(e,\"x\",\"zerosLike\");return zeros(t.shape,t.dtype)}function linspace(e,t,n){if(0===n)throw new Error(\"Cannot request zero samples\");var r=(t-e)/(n-1),o=makeZerosTypedArray(n,\"float32\");o[0]=e;for(var a=1;a<o.length;a++)o[a]=o[a-1]+r;return tensor1d(o,\"float32\")}function range(e,t,n,r){if(void 0===n&&(n=1),void 0===r&&(r=\"float32\"),0===n)throw new Error(\"Cannot have a step of zero\");if(e===t||e<t&&n<0||t<e&&n>1)return zeros([0],r);var o=makeZerosTypedArray(Math.abs(Math.ceil((t-e)/n)),r);t<e&&1===n&&(n=-1),o[0]=e;for(var a=1;a<o.length;a++)o[a]=o[a-1]+n;return tensor1d(o,r)}var onesLike=op({onesLike_:onesLike_}),zerosLike=op({zerosLike_:zerosLike_}),DataStorage=function(){function e(e){this.dataMover=e,this.data=new WeakMap;}return e.prototype.get=function(e){return this.data.has(e)||this.dataMover.moveData(e),this.data.get(e)},e.prototype.set=function(e,t){this.data.set(e,t);},e.prototype.has=function(e){return this.data.has(e)},e.prototype.delete=function(e){return this.data.delete(e)},e}(),KernelBackend=function(){function e(){}return e.prototype.time=function(e){throw new Error(\"Not yet implemented.\")},e.prototype.read=function(e){throw new Error(\"Not yet implemented.\")},e.prototype.readSync=function(e){throw new Error(\"Not yet implemented.\")},e.prototype.disposeData=function(e){throw new Error(\"Not yet implemented.\")},e.prototype.write=function(e,t){throw new Error(\"Not yet implemented.\")},e.prototype.fromPixels=function(e,t){throw new Error(\"Not yet implemented.\")},e.prototype.register=function(e,t,n){throw new Error(\"Not yet implemented.\")},e.prototype.memory=function(){throw new Error(\"Not yet implemented.\")},e.prototype.floatPrecision=function(){throw new Error(\"Not yet implemented\")},e.prototype.batchMatMul=function(e,t,n,r){throw new Error(\"Not yet implemented\")},e.prototype.slice=function(e,t,n){throw new Error(\"Not yet implemented\")},e.prototype.stridedSlice=function(e,t,n,r,o,a,i,s,u){throw new Error(\"Not yet implemented\")},e.prototype.reverse=function(e,t){throw new Error(\"Not yet implemented\")},e.prototype.concat=function(e,t){throw new Error(\"Not yet implemented\")},e.prototype.neg=function(e){throw new Error(\"Not yet implemented\")},e.prototype.add=function(e,t){throw new Error(\"Not yet implemented\")},e.prototype.addN=function(e){throw new Error(\"Not yet implemented\")},e.prototype.subtract=function(e,t){throw new Error(\"Not yet implemented\")},e.prototype.multiply=function(e,t){throw new Error(\"Not yet implemented\")},e.prototype.realDivide=function(e,t){throw new Error(\"Not yet implemented\")},e.prototype.floorDiv=function(e,t){throw new Error(\"Not yet implemented\")},e.prototype.sum=function(e,t){throw new Error(\"Not yet implemented\")},e.prototype.prod=function(e,t){throw new Error(\"Not yet implemented\")},e.prototype.unsortedSegmentSum=function(e,t,n){throw new Error(\"Not yet implemented\")},e.prototype.argMin=function(e,t){throw new Error(\"Not yet implemented\")},e.prototype.argMax=function(e,t){throw new Error(\"Not yet implemented\")},e.prototype.equal=function(e,t){throw new Error(\"Not yet implemented\")},e.prototype.notEqual=function(e,t){throw new Error(\"Not yet implemented\")},e.prototype.less=function(e,t){throw new Error(\"Not yet implemented\")},e.prototype.lessEqual=function(e,t){throw new Error(\"Not yet implemented\")},e.prototype.greater=function(e,t){throw new Error(\"Not yet implemented\")},e.prototype.greaterEqual=function(e,t){throw new Error(\"Not yet implemented\")},e.prototype.logicalNot=function(e){throw new Error(\"Not yet implemented\")},e.prototype.logicalAnd=function(e,t){throw new Error(\"Not yet implemented\")},e.prototype.logicalOr=function(e,t){throw new Error(\"Not yet implemented\")},e.prototype.where=function(e){throw new Error(\"Not yet implemented\")},e.prototype.select=function(e,t,n){throw new Error(\"Not yet implemented\")},e.prototype.topk=function(e,t,n){throw new Error(\"Not yet implemented\")},e.prototype.min=function(e,t){throw new Error(\"Not yet implemented\")},e.prototype.minimum=function(e,t){throw new Error(\"Not yet implemented\")},e.prototype.mod=function(e,t){throw new Error(\"Not yet implemented\")},e.prototype.max=function(e,t){throw new Error(\"Not yet implemented\")},e.prototype.maximum=function(e,t){throw new Error(\"Not yet implemented\")},e.prototype.all=function(e,t){throw new Error(\"Not yet implemented\")},e.prototype.any=function(e,t){throw new Error(\"Not yet implemented\")},e.prototype.squaredDifference=function(e,t){throw new Error(\"Not yet implemented\")},e.prototype.ceil=function(e){throw new Error(\"Not yet implemented\")},e.prototype.floor=function(e){throw new Error(\"Not yet implemented\")},e.prototype.round=function(e){throw new Error(\"Not yet implemented\")},e.prototype.sign=function(e){throw new Error(\"Not yet implemented\")},e.prototype.pow=function(e,t){throw new Error(\"Not yet implemented\")},e.prototype.exp=function(e){throw new Error(\"Not yet implemented\")},e.prototype.expm1=function(e){throw new Error(\"Not yet implemented\")},e.prototype.log=function(e){throw new Error(\"Not yet implemented\")},e.prototype.log1p=function(e){throw new Error(\"Not yet implemented\")},e.prototype.sqrt=function(e){throw new Error(\"Not yet implemented\")},e.prototype.rsqrt=function(e){throw new Error(\"Not yet implemented\")},e.prototype.square=function(e){throw new Error(\"Not yet implemented\")},e.prototype.reciprocal=function(e){throw new Error(\"Not yet implemented\")},e.prototype.relu=function(e){throw new Error(\"Not yet implemented\")},e.prototype.elu=function(e){throw new Error(\"Not yet implemented\")},e.prototype.eluDer=function(e,t){throw new Error(\"Not yet implemented\")},e.prototype.selu=function(e){throw new Error(\"Not yet implemented\")},e.prototype.int=function(e){throw new Error(\"Not yet implemented\")},e.prototype.clip=function(e,t,n){throw new Error(\"Not yet implemented\")},e.prototype.abs=function(e){throw new Error(\"Not yet implemented\")},e.prototype.complexAbs=function(e){throw new Error(\"Not yet implemented\")},e.prototype.sigmoid=function(e){throw new Error(\"Not yet implemented\")},e.prototype.softplus=function(e){throw new Error(\"Not yet implemented\")},e.prototype.sin=function(e){throw new Error(\"Not yet implemented\")},e.prototype.cos=function(e){throw new Error(\"Not yet implemented\")},e.prototype.tan=function(e){throw new Error(\"Not yet implemented\")},e.prototype.asin=function(e){throw new Error(\"Not yet implemented\")},e.prototype.acos=function(e){throw new Error(\"Not yet implemented\")},e.prototype.atan=function(e){throw new Error(\"Not yet implemented\")},e.prototype.atan2=function(e,t){throw new Error(\"Not yet implemented\")},e.prototype.sinh=function(e){throw new Error(\"Not yet implemented\")},e.prototype.cosh=function(e){throw new Error(\"Not yet implemented\")},e.prototype.tanh=function(e){throw new Error(\"Not yet implemented\")},e.prototype.asinh=function(e){throw new Error(\"Not yet implemented\")},e.prototype.acosh=function(e){throw new Error(\"Not yet implemented\")},e.prototype.atanh=function(e){throw new Error(\"Not yet implemented\")},e.prototype.erf=function(e){throw new Error(\"Not yet implemented\")},e.prototype.step=function(e,t){throw new Error(\"Not yet implemented\")},e.prototype.conv2d=function(e,t,n){throw new Error(\"Not yet implemented\")},e.prototype.conv2dDerInput=function(e,t,n){throw new Error(\"Not yet implemented\")},e.prototype.conv2dDerFilter=function(e,t,n){throw new Error(\"Not yet implemented\")},e.prototype.depthwiseConv2D=function(e,t,n){throw new Error(\"Not yet implemented\")},e.prototype.depthwiseConv2DDerInput=function(e,t,n){throw new Error(\"Not yet implemented\")},e.prototype.depthwiseConv2DDerFilter=function(e,t,n){throw new Error(\"Not yet implemented\")},e.prototype.conv3d=function(e,t,n){throw new Error(\"Not yet implemented\")},e.prototype.conv3dDerInput=function(e,t,n){throw new Error(\"Not yet implemented\")},e.prototype.conv3dDerFilter=function(e,t,n){throw new Error(\"Not yet implemented\")},e.prototype.maxPool=function(e,t){throw new Error(\"Not yet implemented\")},e.prototype.maxPoolBackprop=function(e,t,n,r){throw new Error(\"Not yet implemented\")},e.prototype.avgPool=function(e,t){throw new Error(\"Not yet implemented\")},e.prototype.avgPoolBackprop=function(e,t,n){throw new Error(\"Not yet implemented\")},e.prototype.reshape=function(e,t){throw new Error(\"Not yet implemented\")},e.prototype.cast=function(e,t){throw new Error(\"Not yet implemented\")},e.prototype.tile=function(e,t){throw new Error(\"Not yet implemented\")},e.prototype.pad=function(e,t,n){throw new Error(\"Not yet implemented\")},e.prototype.transpose=function(e,t){throw new Error(\"Not yet implemented\")},e.prototype.gather=function(e,t,n){throw new Error(\"Not yet implemented\")},e.prototype.gatherND=function(e,t){throw new Error(\"Not yet implemented\")},e.prototype.scatterND=function(e,t,n){throw new Error(\"Not yet implemented\")},e.prototype.batchToSpaceND=function(e,t,n){throw new Error(\"Not yet implemented\")},e.prototype.spaceToBatchND=function(e,t,n){throw new Error(\"Not yet implemented\")},e.prototype.resizeBilinear=function(e,t,n,r){throw new Error(\"Not yet implemented\")},e.prototype.resizeBilinearBackprop=function(e,t,n){throw new Error(\"Not yet implemented\")},e.prototype.resizeNearestNeighbor=function(e,t,n,r){throw new Error(\"Not yet implemented\")},e.prototype.resizeNearestNeighborBackprop=function(e,t,n){throw new Error(\"Not yet implemented\")},e.prototype.batchNormalization=function(e,t,n,r,o,a){throw new Error(\"Not yet implemented\")},e.prototype.localResponseNormalization4D=function(e,t,n,r,o){throw new Error(\"Not yet implemented\")},e.prototype.LRNGrad=function(e,t,n,r,o,a,i){throw new Error(\"Not yet implemented\")},e.prototype.multinomial=function(e,t,n,r){throw new Error(\"Not yet implemented\")},e.prototype.oneHot=function(e,t,n,r){throw new Error(\"Not yet implemented\")},e.prototype.cumsum=function(e,t,n,r){throw new Error(\"Not yet implemented\")},e.prototype.nonMaxSuppression=function(e,t,n,r,o){throw new Error(\"Not yet implemented\")},e.prototype.fft=function(e){throw new Error(\"Not yet implemented\")},e.prototype.ifft=function(e){throw new Error(\"Not yet implemented\")},e.prototype.complex=function(e,t){throw new Error(\"Not yet implemented\")},e.prototype.real=function(e){throw new Error(\"Not yet implemented\")},e.prototype.imag=function(e){throw new Error(\"Not yet implemented\")},e.prototype.cropAndResize=function(e,t,n,r,o,a){throw new Error(\"Not yet implemented\")},e.prototype.depthToSpace=function(e,t,n){throw new Error(\"Not yet implemented\")},e.prototype.split=function(e,t,n){throw new Error(\"Not yet implemented\")},e.prototype.sparseToDense=function(e,t,n,r){throw new Error(\"Not yet implemented\")},e.prototype.setDataMover=function(e){throw new Error(\"Not yet implemented\")},e.prototype.dispose=function(){throw new Error(\"Not yet implemented\")},e}();function castTensor(e,t,n){if(\"complex64\"===t){if(\"complex64\"===e.dtype)return e.clone();var r=zeros(e.shape),o=e.toFloat(),a=n.complex(o,r);return r.dispose(),o.dispose(),a}if(!hasEncodingLoss(e.dtype,t))return Tensor.make(e.shape,{dataId:e.dataId},t);if(\"complex64\"===e.dtype){var i=n.real(e);a=i.cast(t);return i.dispose(),a}if(\"int32\"===t)return n.int(e);if(\"bool\"===t){var s=scalar(0,e.dtype);a=n.notEqual(e,s);return s.dispose(),a}throw new Error(\"Error in Cast: unknown dtype argument (\"+t+\")\")}function reshapeTensor(e,t){return Tensor.make(t,{dataId:e.dataId},e.dtype)}function mergeRealAndImagArrays(e,t){if(e.length!==t.length)throw new Error(\"Cannot merge real and imag arrays of different lengths. real:\"+e.length+\", imag: \"+t.length+\".\");for(var n=new Float32Array(2*e.length),r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function splitRealAndImagArrays(e){for(var t=new Float32Array(e.length/2),n=new Float32Array(e.length/2),r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return {real:t,imag:n}}function complexWithEvenIndex(e){for(var t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t),o=0;o<e.length;o+=4)n[Math.floor(o/4)]=e[o],r[Math.floor(o/4)]=e[o+1];return {real:n,imag:r}}function complexWithOddIndex(e){for(var t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t),o=2;o<e.length;o+=4)n[Math.floor(o/4)]=e[o],r[Math.floor(o/4)]=e[o+1];return {real:n,imag:r}}function getComplexWithIndex(e,t){return {real:e[2*t],imag:e[2*t+1]}}function assignToTypedArray(e,t,n,r){e[2*r]=t,e[2*r+1]=n;}function exponents(e,t){for(var n=new Float32Array(e/2),r=new Float32Array(e/2),o=0;o<Math.ceil(e/2);o++){var a=(t?2:-2)*Math.PI*(o/e);n[o]=Math.cos(a),r[o]=Math.sin(a);}return {real:n,imag:r}}function exponent(e,t,n){var r=(n?2:-2)*Math.PI*(e/t);return {real:Math.cos(r),imag:Math.sin(r)}}function nonMaxSuppressionImpl(e,t,n,r,o){for(var a=Array.from(t).map(function(e,t){return {score:e,boxIndex:t}}).filter(function(e){return e.score>o}).sort(function(e,t){return t.score-e.score}),i=[],s=0;s<a.length;s++){var u=a[s],l=u.score,c=u.boxIndex;if(l<o)break;for(var p=!1,d=i.length-1;d>=0;--d){if(intersectionOverUnion(e,c,i[d])>=r){p=!0;break}}if(!p&&(i.push(c),i.length>=n))break}return tensor1d(i,\"int32\")}function intersectionOverUnion(e,t,n){var r=e.subarray(4*t,4*t+4),o=e.subarray(4*n,4*n+4),a=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),s=Math.max(r[0],r[2]),u=Math.max(r[1],r[3]),l=Math.min(o[0],o[2]),c=Math.min(o[1],o[3]),p=Math.max(o[0],o[2]),d=Math.max(o[1],o[3]),h=(s-a)*(u-i),f=(p-l)*(d-c);if(h<=0||f<=0)return 0;var m=Math.max(a,l),g=Math.max(i,c),v=Math.min(s,p),y=Math.min(u,d),x=Math.max(v-m,0)*Math.max(y-g,0);return x/(h+f-x)}function split(e,t,n){var r=Array(e.rank).fill(0),o=e.shape.slice();return t.map(function(t){o[n]=t;var a=e.slice(r,o);return r[n]+=t,a})}function topkImpl(e,t,n,r,o){for(var a=t[t.length-1],i=[e.length/a,a],s=i[0],u=i[1],l=getTypedArrayFromDType(n,s*r),c=getTypedArrayFromDType(\"int32\",s*r),p=0;p<s;p++){for(var d=p*u,h=e.subarray(d,d+u),f=[],m=0;m<h.length;m++)f.push({value:h[m],index:m});f.sort(function(e,t){return t.value-e.value});var g=p*r,v=l.subarray(g,g+r),y=c.subarray(g,g+r);for(m=0;m<r;m++)v[m]=f[m].value,y[m]=f[m].index;}var x=t.slice();return x[x.length-1]=r,[tensor(l,x,n),tensor(c,x,\"int32\")]}var ArgMinMaxProgram=function(){return function(e,t,n){this.variableNames=[\"A\"];var r=e.windowSize,o=e.batchSize,a=e.inSize,i=Math.ceil(a/r);n||this.variableNames.push(\"bestIndicesA\"),this.outputShape=[o,i];var s=\"max\"===t?\">\":\"<\",u=n?\"inOffset + i;\":\"round(getBestIndicesA(batch, inOffset + i));\";this.userCode=\"\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int outIdx = coords[1];\\n        int inOffset = outIdx * \"+r+\";\\n\\n        int bestIndex = inOffset;\\n        float bestValue = getA(batch, bestIndex);\\n\\n        for (int i = 0; i < \"+r+\"; i++) {\\n          int inIdx = \"+u+\";\\n          float candidate = getA(batch, inIdx);\\n          if (candidate \"+s+\" bestValue) {\\n            bestValue = candidate;\\n            bestIndex = inIdx;\\n          }\\n        }\\n        setOutput(float(bestIndex));\\n      }\\n    \";}}(),AvgPool2DBackpropProgram=function(){return function(e){this.variableNames=[\"dy\"],this.outputShape=e.inShape;var t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,o=e.strideWidth,a=e.dilationHeight,i=e.dilationWidth,s=e.effectiveFilterHeight,u=e.effectiveFilterWidth,l=s-1-e.padInfo.top,c=u-1-e.padInfo.left,p=1/(t*n);this.userCode=\"\\n      const ivec2 pads = ivec2(\"+l+\", \"+c+\");\\n      const float avgMultiplier = float(\"+p+\");\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int d = coords[3];\\n\\n        ivec2 dyRCCorner = coords.yz - pads;\\n        int dyRCorner = dyRCCorner.x;\\n        int dyCCorner = dyRCCorner.y;\\n\\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n        for (int wR = 0; wR < \"+s+\";\\n            wR += \"+a+\") {\\n          float dyR = float(dyRCorner + wR) / \"+r+\".0;\\n\\n          if (dyR < 0.0 || dyR >= \"+e.outHeight+\".0 || fract(dyR) > 0.0) {\\n            continue;\\n          }\\n          int idyR = int(dyR);\\n\\n          for (int wC = 0; wC < \"+u+\";\\n            wC+= \"+i+\") {\\n            float dyC = float(dyCCorner + wC) / \"+o+\".0;\\n\\n            if (dyC < 0.0 || dyC >= \"+e.outWidth+\".0 ||\\n                fract(dyC) > 0.0) {\\n              continue;\\n            }\\n            int idyC = int(dyC);\\n\\n            float dyValue = getDy(b, idyR, idyC, d);\\n\\n            dotProd += dyValue * avgMultiplier;\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";}}();function getBroadcastDims(e,t){for(var n=e.length,r=[],o=0;o<n;o++){var a=n-1-o,i=e[a]||1;(t[t.length-1-o]||1)>1&&1===i&&r.unshift(a);}return r}function getReductionAxes(e,t){for(var n=[],r=0;r<t.length;r++){var o=e[e.length-r-1],a=t.length-r-1,i=t[a];(null==o||1===o&&i>1)&&n.unshift(a);}return n}function broadcastDimsAreOuter(e){for(var t=0;t<e.length;t++)if(e[t]!==t)return !1;return !0}function assertAndGetBroadcastShape(e,t){for(var n=[],r=Math.max(e.length,t.length),o=0;o<r;o++){var a=e[e.length-o-1];null==a&&(a=1);var i=t[t.length-o-1];if(null==i&&(i=1),1===a)n.unshift(i);else if(1===i)n.unshift(a);else{if(a!==i)throw Error(\"Operands could not be broadcast together with shapes \"+e+\" and \"+t+\".\");n.unshift(a);}}return n}var BatchNormProgram=function(){return function(e,t,n,r,o,a){this.outputShape=[],this.supportsBroadcasting=!0,this.variableNames=[\"x\",\"mean\",\"variance\"],assertAndGetBroadcastShape(e,t),assertAndGetBroadcastShape(e,n);var i=\"0.0\";null!=r&&(assertAndGetBroadcastShape(e,r),this.variableNames.push(\"offset\"),i=\"getOffsetAtOutCoords()\");var s=\"1.0\";null!=o&&(assertAndGetBroadcastShape(e,o),this.variableNames.push(\"scale\"),s=\"getScaleAtOutCoords()\"),this.outputShape=e,this.userCode=\"\\n      void main() {\\n        float x = getXAtOutCoords();\\n        float mean = getMeanAtOutCoords();\\n        float variance = getVarianceAtOutCoords();\\n        float offset = \"+i+\";\\n        float scale = \"+s+\";\\n        float inv = scale * inversesqrt(variance + float(\"+a+\"));\\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\\n      }\\n    \";}}(),BatchNormPackedProgram=function(){return function(e,t,n,r,o,a){this.supportsBroadcasting=!0,this.usesPackedTextures=!0,this.variableNames=[\"x\",\"mean\",\"variance\"],assertAndGetBroadcastShape(e,t),assertAndGetBroadcastShape(e,n);var i=\"vec4(0.0)\";null!=r&&(assertAndGetBroadcastShape(e,r),this.variableNames.push(\"offset\"),i=\"getOffsetAtOutCoords()\");var s=\"vec4(1.0)\";null!=o&&(assertAndGetBroadcastShape(e,o),this.variableNames.push(\"scale\"),s=\"getScaleAtOutCoords()\"),this.outputShape=e,this.userCode=\"\\n      void main() {\\n        vec4 offset = \"+i+\";\\n        vec4 scale = \"+s+\";\\n\\n        vec4 x = getXAtOutCoords();\\n        vec4 mean = getMeanAtOutCoords();\\n        vec4 variance = getVarianceAtOutCoords();\\n\\n        vec4 inv = scale * inversesqrt(variance + vec4(\"+a+\"));\\n\\n        setOutput((x - mean) * inv + offset);\\n      }\\n    \";}}(),COMPLEX_MULTIPLY={REAL:\"return areal * breal - aimag * bimag;\",IMAG:\"return areal * bimag + aimag * breal;\"},BinaryOpComplexProgram=function(){return function(e,t,n){this.variableNames=[\"AReal\",\"AImag\",\"BReal\",\"BImag\"],this.supportsBroadcasting=!0,this.outputShape=assertAndGetBroadcastShape(t,n),this.userCode=\"\\n      float binaryOpComplex(\\n          float areal, float aimag, float breal, float bimag) {\\n        \"+e+\"\\n      }\\n\\n      void main() {\\n        float areal = getARealAtOutCoords();\\n        float aimag = getAImagAtOutCoords();\\n        float breal = getBRealAtOutCoords();\\n        float bimag = getBImagAtOutCoords();\\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\\n      }\\n    \";}}(),CHECK_NAN_SNIPPET=\"\\n  if (isNaN(a)) return a;\\n  if (isNaN(b)) return b;\\n\",ADD=\"return a + b;\",SUB=\"return a - b;\",MUL=\"return a * b;\",DIV=\"if (a == b) return 1.0;\\n  return a / b;\",INT_DIV=\"\\n  float resultSign = sign(a) * sign(b);\\n  int ia = round(a);\\n  int ib = round(b);\\n  int result = ia / ib;\\n  int amodb = ia - ib * result;\\n\\n  if (resultSign < 0.0 && amodb != 0) {\\n    result -= 1;\\n  }\\n  return float(result);\\n\",POW=\"\\nif(a < 0.0 && floor(b) < b){\\n  return NAN;\\n}\\nreturn (round(mod(b, 2.0)) == 0 || round(mod(b, 2.0)) == 2) ?\\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\\n\",SQUARED_DIFFERENCE=\"return (a - b) * (a - b);\",EQUAL=\"return float(a == b);\",NOT_EQUAL=\"return float(a != b);\",LESS=\"return float(a < b);\",LESS_EQUAL=\"return float(a <= b);\",GREATER=\"return float(a > b);\",GREATER_EQUAL=\"return float(a >= b);\",LOGICAL_AND=\"return float(a >= 1.0 && b >= 1.0);\",LOGICAL_OR=\"return float(a >= 1.0 || b >= 1.0);\",MAX=CHECK_NAN_SNIPPET+\"\\n  return max(a, b);\\n\",MIN=CHECK_NAN_SNIPPET+\"\\n  return min(a, b);\\n\",MOD=\"if (b == 0.0) return NAN;\\n  return mod(a, b);\",ATAN2=CHECK_NAN_SNIPPET+\"\\n  return atan(a, b);\\n\",ELU_DER=\"return (b >= 1.0) ? a : a * (b + 1.0);\",BinaryOpProgram=function(){function e(e,t,n){this.variableNames=[\"A\",\"B\"],this.supportsBroadcasting=!0,this.outputShape=assertAndGetBroadcastShape(t,n),this.userCode=\"\\n      uniform float NAN;\\n      float binaryOperation(float a, float b) {\\n        \"+e+\"\\n      }\\n\\n      void main() {\\n        float a = getAAtOutCoords();\\n        float b = getBAtOutCoords();\\n        setOutput(binaryOperation(a, b));\\n      }\\n    \";}return e.prototype.getCustomSetupFunc=function(){var e=this;return function(t,n){null==e.startLoc&&(e.startLoc=t.getUniformLocationNoThrow(n,\"NAN\"),null==e.startLoc)||t.gl.uniform1f(e.startLoc,NaN);}},e}(),ClipProgram=function(){return function(e,t,n){this.variableNames=[\"A\"],this.outputShape=e,this.userCode=\"\\n      void main() {\\n        float value = getAAtOutCoords();\\n        if (isNaN(value)) {\\n          setOutput(value);\\n          return;\\n        }\\n\\n        setOutput(clamp(value, float(\"+t+\"), float(\"+n+\")));\\n      }\\n    \";}}(),ClipPackedProgram=function(){return function(e,t,n){this.variableNames=[\"A\"],this.usesPackedTextures=!0,this.outputShape=e,this.userCode=\"\\n      void main() {\\n        vec4 value = getAAtOutCoords();\\n\\n        if (hasNaN(value)) {\\n          setOutput(value);\\n          return;\\n        }\\n\\n        setOutput(clamp(value, vec4(\"+t+\"), vec4(\"+n+\")));\\n      }\\n    \";}}(),ComplexAbsProgram=function(){return function(e){this.variableNames=[\"real\",\"imag\"],this.outputShape=e,this.userCode=\"\\n      void main() {\\n        float re = abs(getRealAtOutCoords());\\n        float im = abs(getImagAtOutCoords());\\n        float mx = max(re, im);\\n\\n        // sadly the length function in glsl is not underflow-safe\\n        // (at least not on Intel GPUs). So the safe solution is\\n        // to ensure underflow-safety in all cases.\\n        setOutput(\\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\\n        );\\n      }\\n    \";}}(),ConcatProgram=function(){return function(e,t){this.variableNames=[\"A\",\"B\"],this.outputShape=[],this.outputShape=computeOutShape([e,t],1),this.userCode=\"\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int yR = coords.x;\\n        int yC = coords.y;\\n\\n        float value = 0.0;\\n        if (yC < \"+e[1]+\") {\\n          value = getA(yR, yC);\\n        } else {\\n          yC -= \"+e[1]+\";\\n          value = getB(yR, yC);\\n        }\\n\\n        setOutput(value);\\n      }\\n    \";}}(),Conv2DDerFilterProgram=function(){return function(e){this.variableNames=[\"x\",\"dy\"],this.outputShape=e.filterShape;var t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,o=e.padInfo.left;this.userCode=\"\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int wR = coords.x;\\n        int wC = coords.y;\\n        int d1 = coords.z;\\n        int d2 = coords.w;\\n\\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n\\n        for (int b = 0; b < \"+e.batchSize+\"; b++) {\\n          for (int yR = 0; yR < \"+e.outHeight+\"; yR++) {\\n            int xR = wR + yR * \"+t+\" - \"+r+\";\\n\\n            if (xR < 0 || xR >= \"+e.inHeight+\") {\\n              continue;\\n            }\\n\\n            for (int yC = 0; yC < \"+e.outWidth+\"; yC++) {\\n              int xC = wC + yC * \"+n+\" - \"+o+\";\\n\\n              if (xC < 0 || xC >= \"+e.inWidth+\") {\\n                continue;\\n              }\\n\\n              float dyValue = getDy(b, yR, yC, d2);\\n              float xValue = getX(b, xR, xC, d1);\\n              dotProd += (xValue * dyValue);\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";}}(),Conv2DDerInputProgram=function(){return function(e){this.variableNames=[\"dy\",\"W\"],this.outputShape=e.inShape;var t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,o=e.strideWidth,a=t-1-e.padInfo.top,i=n-1-e.padInfo.left;this.userCode=\"\\n      const ivec2 pads = ivec2(\"+a+\", \"+i+\");\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int d1 = coords[3];\\n\\n        ivec2 dyCorner = coords.yz - pads;\\n        int dyRCorner = dyCorner.x;\\n        int dyCCorner = dyCorner.y;\\n\\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n        for (int wR = 0; wR < \"+t+\"; wR++) {\\n          float dyR = float(dyRCorner + wR) / \"+r+\".0;\\n\\n          if (dyR < 0.0 || dyR >= \"+e.outHeight+\".0 || fract(dyR) > 0.0) {\\n            continue;\\n          }\\n          int idyR = int(dyR);\\n\\n          int wRPerm = \"+t+\" - 1 - wR;\\n\\n          for (int wC = 0; wC < \"+n+\"; wC++) {\\n            float dyC = float(dyCCorner + wC) / \"+o+\".0;\\n\\n            if (dyC < 0.0 || dyC >= \"+e.outWidth+\".0 ||\\n                fract(dyC) > 0.0) {\\n              continue;\\n            }\\n            int idyC = int(dyC);\\n\\n            int wCPerm = \"+n+\" - 1 - wC;\\n\\n            for (int d2 = 0; d2 < \"+e.outChannels+\"; d2++) {\\n              float xValue = getDy(batch, idyR, idyC, d2);\\n              float wValue = getW(wRPerm, wCPerm, d1, d2);\\n              dotProd += xValue * wValue;\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";}}(),Conv3DDerFilterProgram=function(){return function(e){this.variableNames=[\"x\",\"dy\"],this.outputShape=e.filterShape;var t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,o=e.padInfo.front,a=e.padInfo.top,i=e.padInfo.left;this.userCode=\"\\n      void main() {\\n        ivec5 coords = getOutputCoords();\\n        int wF = coords.x;\\n        int wR = coords.y;\\n        int wC = coords.z;\\n        int d1 = coords.w;\\n        int d2 = coords.u;\\n\\n        float dotProd = 0.0;\\n\\n        for (int b = 0; b < \"+e.batchSize+\"; b++) {\\n          for (int yF = 0; yF < \"+e.outDepth+\"; yF++) {\\n            int xF = wF + yF * \"+t+\" - \"+o+\";\\n\\n            if (xF < 0 || xF >= \"+e.inDepth+\") {\\n              continue;\\n            }\\n\\n            for (int yR = 0; yR < \"+e.outHeight+\"; yR++) {\\n              int xR = wR + yR * \"+n+\" - \"+a+\";\\n\\n              if (xR < 0 || xR >= \"+e.inHeight+\") {\\n                continue;\\n              }\\n\\n              for (int yC = 0; yC < \"+e.outWidth+\"; yC++) {\\n                int xC = wC + yC * \"+r+\" - \"+i+\";\\n\\n                if (xC < 0 || xC >= \"+e.inWidth+\") {\\n                  continue;\\n                }\\n\\n                float dyValue = getDy(b, yF, yR, yC, d2);\\n                float xValue = getX(b, xF, xR, xC, d1);\\n                dotProd += (xValue * dyValue);\\n              }\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";}}(),Conv3DDerInputProgram=function(){return function(e){this.variableNames=[\"dy\",\"W\"],this.outputShape=e.inShape;var t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,o=e.strideDepth,a=e.strideHeight,i=e.strideWidth,s=t-1-e.padInfo.front,u=n-1-e.padInfo.top,l=r-1-e.padInfo.left;this.userCode=\"\\n      const ivec3 pads = ivec3(\"+s+\", \"+u+\", \"+l+\");\\n\\n      void main() {\\n        ivec5 coords = getOutputCoords();\\n        int batch = coords.x;\\n        int d1 = coords.u;\\n\\n\\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\\n        int dyFCorner = dyCorner.x;\\n        int dyRCorner = dyCorner.y;\\n        int dyCCorner = dyCorner.z;\\n\\n        float dotProd = 0.0;\\n        for (int wF = 0; wF < \"+t+\"; wF++) {\\n          float dyF = float(dyFCorner + wF) / \"+o+\".0;\\n\\n          if (dyF < 0.0 || dyF >= \"+e.outDepth+\".0 || fract(dyF) > 0.0) {\\n            continue;\\n          }\\n          int idyF = int(dyF);\\n\\n          int wFPerm = \"+t+\" - 1 - wF;\\n\\n          for (int wR = 0; wR < \"+n+\"; wR++) {\\n            float dyR = float(dyRCorner + wR) / \"+a+\".0;\\n\\n            if (dyR < 0.0 || dyR >= \"+e.outHeight+\".0 ||\\n              fract(dyR) > 0.0) {\\n              continue;\\n            }\\n            int idyR = int(dyR);\\n\\n            int wRPerm = \"+n+\" - 1 - wR;\\n\\n            for (int wC = 0; wC < \"+r+\"; wC++) {\\n              float dyC = float(dyCCorner + wC) / \"+i+\".0;\\n\\n              if (dyC < 0.0 || dyC >= \"+e.outWidth+\".0 ||\\n                  fract(dyC) > 0.0) {\\n                continue;\\n              }\\n              int idyC = int(dyC);\\n\\n              int wCPerm = \"+r+\" - 1 - wC;\\n\\n              for (int d2 = 0; d2 < \"+e.outChannels+\"; d2++) {\\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\\n                dotProd += xValue * wValue;\\n              }\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";}}(),DepthwiseConv2DDerFilterProgram=function(){return function(e){this.variableNames=[\"x\",\"dy\"],this.outputShape=e.filterShape;var t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,o=e.padInfo.left,a=e.outChannels/e.inChannels;this.userCode=\"\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int wR = coords.x;\\n        int wC = coords.y;\\n        int d1 = coords.z;\\n        int dm = coords.w;\\n        int d2 = d1 * \"+a+\" + dm;\\n\\n        float dotProd = 0.0;\\n\\n        // TODO: Vec4 over the batch size\\n        for (int b = 0; b < \"+e.batchSize+\"; b++) {\\n          for (int yR = 0; yR < \"+e.outHeight+\"; yR++) {\\n            int xR = wR + yR * \"+t+\" - \"+r+\";\\n\\n            if (xR < 0 || xR >= \"+e.inHeight+\") {\\n              continue;\\n            }\\n\\n            for (int yC = 0; yC < \"+e.outWidth+\"; yC++) {\\n              int xC = wC + yC * \"+n+\" - \"+o+\";\\n\\n              if (xC < 0 || xC >= \"+e.inWidth+\") {\\n                continue;\\n              }\\n\\n              float dyValue = getDy(b, yR, yC, d2);\\n              float xValue = getX(b, xR, xC, d1);\\n              dotProd += (xValue * dyValue);\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";}}(),DepthwiseConv2DDerInputProgram=function(){return function(e){this.variableNames=[\"dy\",\"W\"],this.outputShape=e.inShape;var t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,o=e.strideWidth,a=t-1-e.padInfo.top,i=n-1-e.padInfo.left,s=e.outChannels/e.inChannels;this.userCode=\"\\n      const ivec2 pads = ivec2(\"+a+\", \"+i+\");\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int d1 = coords[3];\\n        ivec2 dyCorner = coords.yz - pads;\\n        int dyRCorner = dyCorner.x;\\n        int dyCCorner = dyCorner.y;\\n\\n        float dotProd = 0.0;\\n\\n        for (int wR = 0; wR < \"+t+\"; wR++) {\\n          float dyR = float(dyRCorner + wR) / \"+r+\".0;\\n\\n          if (dyR < 0.0 || dyR >= \"+e.outHeight+\".0 || fract(dyR) > 0.0) {\\n            continue;\\n          }\\n          int idyR = int(dyR);\\n\\n          int wRPerm = \"+t+\" - 1 - wR;\\n\\n          for (int wC = 0; wC < \"+n+\"; wC++) {\\n            float dyC = float(dyCCorner + wC) / \"+o+\".0;\\n\\n            if (dyC < 0.0 || dyC >= \"+e.outWidth+\".0 ||\\n                fract(dyC) > 0.0) {\\n              continue;\\n            }\\n            int idyC = int(dyC);\\n\\n            int wCPerm = \"+n+\" - 1 - wC;\\n\\n            // TODO: Vec4 over the channelMul\\n            for (int dm = 0; dm < \"+s+\"; dm++) {\\n              int d2 = d1 * \"+s+\" + dm;\\n              float xValue = getDy(batch, idyR, idyC, d2);\\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\\n              dotProd += xValue * wValue;\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";}}(),Conv2DProgram=function(){return function(e){this.variableNames=[\"x\",\"W\"],this.outputShape=e.outShape;var t=e.padInfo.top,n=e.padInfo.left,r=e.strideHeight,o=e.strideWidth,a=e.dilationHeight,i=e.dilationWidth,s=e.filterHeight,u=e.filterWidth,l=4*Math.floor(e.inChannels/4),c=e.inChannels%4;this.userCode=\"\\n      const ivec2 strides = ivec2(\"+r+\", \"+o+\");\\n      const ivec2 pads = ivec2(\"+t+\", \"+n+\");\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int d2 = coords[3];\\n\\n        ivec2 xRCCorner = coords.yz * strides - pads;\\n        int xRCorner = xRCCorner.x;\\n        int xCCorner = xRCCorner.y;\\n\\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n        for (int wR = 0; wR < \"+s+\"; wR++) {\\n          int xR = xRCorner + wR * \"+a+\";\\n\\n          if (xR < 0 || xR >= \"+e.inHeight+\") {\\n            continue;\\n          }\\n\\n          for (int wC = 0; wC < \"+u+\"; wC++) {\\n            int xC = xCCorner + wC * \"+i+\";\\n\\n            if (xC < 0 || xC >= \"+e.inWidth+\") {\\n              continue;\\n            }\\n\\n            for (int d1 = 0; d1 < \"+l+\"; d1 += 4) {\\n              vec4 xValues = vec4(\\n                getX(batch, xR, xC, d1),\\n                getX(batch, xR, xC, d1 + 1),\\n                getX(batch, xR, xC, d1 + 2),\\n                getX(batch, xR, xC, d1 + 3)\\n              );\\n              vec4 wValues = vec4(\\n                getW(wR, wC, d1, d2),\\n                getW(wR, wC, d1 + 1, d2),\\n                getW(wR, wC, d1 + 2, d2),\\n                getW(wR, wC, d1 + 3, d2)\\n              );\\n\\n              dotProd += dot(xValues, wValues);\\n            }\\n\\n            if (\"+(1===c)+\") {\\n              dotProd +=\\n                getX(batch, xR, xC, \"+l+\") *\\n                getW(wR, wC, \"+l+\", d2);\\n            } else if (\"+(2===c)+\") {\\n              vec2 xValues = vec2(\\n                getX(batch, xR, xC, \"+l+\"),\\n                getX(batch, xR, xC, \"+l+\" + 1)\\n              );\\n              vec2 wValues = vec2(\\n                getW(wR, wC, \"+l+\", d2),\\n                getW(wR, wC, \"+l+\" + 1, d2)\\n              );\\n              dotProd += dot(xValues, wValues);\\n            } else if (\"+(3===c)+\") {\\n              vec3 xValues = vec3(\\n                getX(batch, xR, xC, \"+l+\"),\\n                getX(batch, xR, xC, \"+l+\" + 1),\\n                getX(batch, xR, xC, \"+l+\" + 2)\\n              );\\n              vec3 wValues = vec3(\\n                getW(wR, wC, \"+l+\", d2),\\n                getW(wR, wC, \"+l+\" + 1, d2),\\n                getW(wR, wC, \"+l+\" + 2, d2)\\n              );\\n              dotProd += dot(xValues, wValues);\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";}}(),Conv3DProgram=function(){return function(e){this.variableNames=[\"x\",\"W\"],this.outputShape=e.outShape;var t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,o=e.strideDepth,a=e.strideHeight,i=e.strideWidth,s=e.dilationDepth,u=e.dilationHeight,l=e.dilationWidth,c=e.filterDepth,p=e.filterHeight,d=e.filterWidth,h=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode=\"\\n      const ivec3 strides = ivec3(\"+o+\", \"+a+\", \"+i+\");\\n      const ivec3 pads = ivec3(\"+t+\", \"+n+\", \"+r+\");\\n\\n      void main() {\\n        ivec5 coords = getOutputCoords();\\n        int batch = coords.x;\\n        int d2 = coords.u;\\n\\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\\n        int xFCorner = xFRCCorner.x;\\n        int xRCorner = xFRCCorner.y;\\n        int xCCorner = xFRCCorner.z;\\n\\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\\n        // values in that axis.\\n        float dotProd = 0.0;\\n        for (int wF = 0; wF < \"+c+\"; wF++) {\\n          int xF = xFCorner + wF * \"+s+\";\\n\\n          if (xF < 0 || xF >= \"+e.inDepth+\") {\\n            continue;\\n          }\\n\\n          for (int wR = 0; wR < \"+p+\"; wR++) {\\n            int xR = xRCorner + wR * \"+u+\";\\n\\n            if (xR < 0 || xR >= \"+e.inHeight+\") {\\n              continue;\\n            }\\n\\n            for (int wC = 0; wC < \"+d+\"; wC++) {\\n              int xC = xCCorner + wC * \"+l+\";\\n\\n              if (xC < 0 || xC >= \"+e.inWidth+\") {\\n                continue;\\n              }\\n\\n              for (int d1 = 0; d1 < \"+h+\"; d1 += 4) {\\n                vec4 xValues = vec4(\\n                  getX(batch, xF, xR, xC, d1),\\n                  getX(batch, xF, xR, xC, d1 + 1),\\n                  getX(batch, xF, xR, xC, d1 + 2),\\n                  getX(batch, xF, xR, xC, d1 + 3)\\n                );\\n                vec4 wValues = vec4(\\n                  getW(wF, wR, wC, d1, d2),\\n                  getW(wF, wR, wC, d1 + 1, d2),\\n                  getW(wF, wR, wC, d1 + 2, d2),\\n                  getW(wF, wR, wC, d1 + 3, d2)\\n                );\\n\\n                dotProd += dot(xValues, wValues);\\n              }\\n\\n              if (\"+(1===f)+\") {\\n                dotProd +=\\n                  getX(batch, xF, xR, xC, \"+h+\") *\\n                  getW(wF, wR, wC, \"+h+\", d2);\\n              } else if (\"+(2===f)+\") {\\n                vec2 xValues = vec2(\\n                  getX(batch, xF, xR, xC, \"+h+\"),\\n                  getX(batch, xF, xR, xC, \"+h+\" + 1)\\n                );\\n                vec2 wValues = vec2(\\n                  getW(wF, wR, wC, \"+h+\", d2),\\n                  getW(wF, wR, wC, \"+h+\" + 1, d2)\\n                );\\n                dotProd += dot(xValues, wValues);\\n              } else if (\"+(3===f)+\") {\\n                vec3 xValues = vec3(\\n                  getX(batch, xF, xR, xC, \"+h+\"),\\n                  getX(batch, xF, xR, xC, \"+h+\" + 1),\\n                  getX(batch, xF, xR, xC, \"+h+\" + 2)\\n                );\\n                vec3 wValues = vec3(\\n                  getW(wF, wR, wC, \"+h+\", d2),\\n                  getW(wF, wR, wC, \"+h+\" + 1, d2),\\n                  getW(wF, wR, wC, \"+h+\" + 2, d2)\\n                );\\n                dotProd += dot(xValues, wValues);\\n              }\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";}}(),DepthwiseConv2DProgram=function(){return function(e){this.variableNames=[\"x\",\"W\"],this.outputShape=e.outShape;var t=e.inHeight,n=e.inWidth,r=e.padInfo.top,o=e.padInfo.left,a=e.strideHeight,i=e.strideWidth,s=e.dilationHeight,u=e.dilationWidth,l=e.filterHeight,c=e.filterWidth,p=e.outChannels/e.inChannels;this.userCode=\"\\n      const ivec2 strides = ivec2(\"+a+\", \"+i+\");\\n      const ivec2 pads = ivec2(\"+r+\", \"+o+\");\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords.x;\\n        ivec2 xRCCorner = coords.yz * strides - pads;\\n        int d2 = coords.w;\\n        int d1 = d2 / \"+p+\";\\n        int q = d2 - d1 * \"+p+\";\\n\\n        int xRCorner = xRCCorner.x;\\n        int xCCorner = xRCCorner.y;\\n\\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n        // TODO(dsmilkov): Flatten the two for loops and vec4 the operations.\\n        for (int wR = 0; wR < \"+l+\"; wR++) {\\n          int xR = xRCorner + wR * \"+s+\";\\n\\n          if (xR < 0 || xR >= \"+t+\") {\\n            continue;\\n          }\\n\\n          for (int wC = 0; wC < \"+c+\"; wC++) {\\n            int xC = xCCorner + wC * \"+u+\";\\n\\n            if (xC < 0 || xC >= \"+n+\") {\\n              continue;\\n            }\\n\\n            float xVal = getX(batch, xR, xC, d1);\\n            float wVal = getW(wR, wC, d1, q);\\n            dotProd += xVal * wVal;\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";}}(),DepthwiseConvPacked2DProgram=function(){return function(e){this.variableNames=[\"x\",\"W\"],this.usesPackedTextures=!0,this.outputShape=e.outShape;for(var t=e.inHeight,n=e.inWidth,r=e.padInfo.top,o=e.padInfo.left,a=e.strideHeight,i=e.strideWidth,s=e.filterHeight,u=e.filterWidth,l=Math.ceil((u+1)/2),c=\"int xR; int xC;\",p=0;p<s;p++){for(var d=-o;d<2*l;d++)c+=\"vec4 \"+xTexelName(p,d)+\" = vec4(0.);\";for(d=0;d<u;d++)c+=\"\\n          vec4 wR\"+p+\"C\"+d+\" = vec4(0.);\\n          vec4 xR\"+p+\"C\"+d+\" = vec4(0.);\";}for(p=0;p<s;p++)for(d=0;d<l;d++){var h=2*d,f=2*d+o;c+=\"\\n          xR = xRCorner + \"+p+\";\\n          xC = xCCorner + \"+f+\";\\n\\n          if(xR >= 0 && xR < \"+t+\" && xC >= 0 && xC < \"+n+\") {\\n            \"+xTexelName(p,f)+\" = getX(batch, xR, xC, d1);\\n          }\",0===o?h<u&&d===l-1&&(i>1&&(c+=\"\\n                vec4 \"+xTexelName(p,f+2)+\" = vec4(0.);\\n\\n                if(xR >= 0 && xR < \"+t+\" && xC + 2 < \"+n+\") {\\n                  \"+xTexelName(p,f+2)+\" = getX(batch, xR, xC + 2, d1);\\n                }\"),c+=\"\\n              xR\"+p+\"C\"+f+\" = \"+constructTexel(p,f,i,o)+\";\\n            \"):0===d&&(c+=\"\\n            if(xR >= 0 && xR < \"+t+\" && xC - 2 >= 0) {\\n              \"+xTexelName(p,f-2)+\" = getX(batch, xR, xC - 2, d1);\\n            }\"),h>0&&(c+=\"xR\"+p+\"C\"+(f-2)+\" =\\n            \"+constructTexel(p,f-2,i,o)+\";\"),f-1>=0&&f-1<u&&(c+=\"xR\"+p+\"C\"+(f-1)+\" =\\n              \"+constructTexel(p,f-1,i,o)+\";\"),h<u&&(c+=\"\\n            vec4 wTexel\"+p+\"C\"+h+\" = getW(\"+p+\", \"+h+\", d1, q);\\n            wR\"+p+\"C\"+h+\" = vec4(wTexel\"+p+\"C\"+h+\".xz, wTexel\"+p+\"C\"+h+\".xz);\\n          \",h+1<u&&(c+=\"\\n              vec4 wTexelR\"+p+\"C\"+(h+1)+\" = getW(\"+p+\", \"+(h+1)+\", d1, q);\\n              wR\"+p+\"C\"+(h+1)+\" =\\n                vec4(wTexelR\"+p+\"C\"+(h+1)+\".xz, wTexelR\"+p+\"C\"+(h+1)+\".xz);\"));}for(p=0;p<s;p++)for(d=0;d<u;d++)c+=\"result += xR\"+p+\"C\"+d+\" * wR\"+p+\"C\"+d+\";\";this.userCode=\"\\n      const ivec2 strides = ivec2(\"+a+\", \"+i+\");\\n      const ivec2 pads = ivec2(\"+r+\", \"+o+\");\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords.x;\\n        ivec2 xRCCorner = coords.yz * strides - pads;\\n        int d2 = coords.w;\\n        int d1 = d2;\\n        int q = 0;\\n        int xRCorner = xRCCorner.x;\\n        int xCCorner = xRCCorner.y;\\n\\n        vec4 result = vec4(0.);\\n\\n        \"+c+\"\\n\\n        setOutput(result);\\n      }\\n    \";}}();function xTexelName(e,t){return \"xTexelR\"+e+\"C\"+(t<0?\"minus\"+Math.abs(t).toString():t)}function constructTexel(e,t,n,r){return 1===n?r%2==t%2?xTexelName(e,t):\"vec4(\"+xTexelName(e,t-1)+\".zw, \"+xTexelName(e,t+1)+\".xy)\":r%2==t%2?\"vec4(\"+xTexelName(e,t)+\".xy, \"+xTexelName(e,t+2)+\".xy)\":\"vec4(\"+xTexelName(e,t-1)+\".zw, \"+xTexelName(e,t+1)+\".zw)\"}var CropAndResizeProgram=function(){return function(e,t,n,r,o){this.variableNames=[\"Image\",\"Boxes\",\"BoxInd\"],this.outputShape=[];var a=e[0],i=e[1],s=e[2],u=e[3],l=t[0],c=n[0],p=n[1];this.outputShape=[l,c,p,u];var d=\"bilinear\"===r?1:0,h=[i-1+\".0\",s-1+\".0\"],f=h[0],m=h[1],g=c>1?[\"\"+(i-1)/(c-1),\"(y2-y1) * height_ratio\",\"y1*\"+f+\" + float(y)*(height_scale)\"]:[\"0.0\",\"0.0\",\"0.5 * (y1+y2) * \"+f],v=g[0],y=g[1],x=g[2],T=p>1?[\"\"+(s-1)/(p-1),\"(x2-x1) * width_ratio\",\"x1*\"+m+\" + float(x)*(width_scale)\"]:[\"0.0\",\"0.0\",\"0.5 * (x1+x2) * \"+m],w=T[0],E=T[1],S=T[2];this.userCode=\"\\n      const float height_ratio = float(\"+v+\");\\n      const float width_ratio = float(\"+w+\");\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int y = coords[1];\\n        int x = coords[2];\\n        int d = coords[3];\\n\\n        // get box vals\\n        float y1 = getBoxes(b,0);\\n        float x1 = getBoxes(b,1);\\n        float y2 = getBoxes(b,2);\\n        float x2 = getBoxes(b,3);\\n\\n        // get image in batch index\\n        int bInd = round(getBoxInd(b));\\n        if(bInd < 0 || bInd >= \"+a+\") {\\n          return;\\n        }\\n\\n        float height_scale = \"+y+\";\\n        float width_scale = \"+E+\";\\n\\n        float in_y = \"+x+\";\\n        if( in_y < 0.0 || in_y > \"+f+\" ) {\\n          setOutput(float(\"+o+\"));\\n          return;\\n        }\\n        float in_x = \"+S+\";\\n        if( in_x < 0.0 || in_x > \"+m+\" ) {\\n          setOutput(float(\"+o+\"));\\n          return;\\n        }\\n\\n        vec2 sourceFracIndexRC = vec2(in_y,in_x);\\n        if(\"+d+\" == 1) {\\n          // Compute the four integer indices.\\n          ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\\n          ivec2 sourceCeilRC = ivec2(ceil(sourceFracIndexRC));\\n\\n          float topLeft = getImage(b, sourceFloorRC.x, sourceFloorRC.y, d);\\n          float bottomLeft = getImage(b, sourceCeilRC.x, sourceFloorRC.y, d);\\n          float topRight = getImage(b, sourceFloorRC.x, sourceCeilRC.y, d);\\n          float bottomRight = getImage(b, sourceCeilRC.x, sourceCeilRC.y, d);\\n\\n          vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\\n\\n          float top = topLeft + (topRight - topLeft) * fracRC.y;\\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\\n          float newValue = top + (bottom - top) * fracRC.x;\\n          setOutput(newValue);\\n        } else {\\n          // Compute the coordinators of nearest neighbor point.\\n          ivec2 sourceNearestRC = ivec2(floor(\\n            sourceFracIndexRC + vec2(0.5,0.5)));\\n          float newValue = getImage(b, sourceNearestRC.x, sourceNearestRC.y, d);\\n          setOutput(newValue);\\n        }\\n      }\\n    \";}}();function getLogicalCoordinatesFromFlatIndex(e,t,n){void 0===n&&(n=\"index\");var r=computeStrides(t);return r.map(function(t,o){return \"int \"+e[o]+\" = \"+n+\" / \"+t+\"; \"+(o===r.length-1?\"int \"+e[o+1]+\" = \"+n+\" - \"+e[o]+\" * \"+t:\"index -= \"+e[o]+\" * \"+t)+\";\"}).join(\"\")}function buildVec(e){return 1===e.length?\"\"+e[0]:\"vec\"+e.length+\"(\"+e.join(\",\")+\")\"}function dotify(e,t){if(e.length!==t.length)throw new Error(\"Vectors to be dotted must be of the same length -got \"+e.length+\" and \"+t.length);for(var n=[],r=Math.floor(e.length/4),o=e.length%4,a=0;a<r;a++){var i=e.slice(4*a,4*a+4),s=t.slice(4*a,4*a+4);n.push(buildVec(i)+\", \"+buildVec(s));}if(0!==o){i=e.slice(4*r),s=t.slice(4*r);1===i.length&&(i=i.map(function(e){return \"float(\"+e+\")\"}),s=s.map(function(e){return \"float(\"+e+\")\"})),n.push(buildVec(i)+\", \"+buildVec(s));}return n.map(function(e,t){return \"dot(\"+e+\")\"}).join(\"+\")}function makeShader(e,t,n,r,o){var a=e.map(function(e){var t=sizeFromShape(e.shapeInfo.logicalShape);return e.shapeInfo.isUniform?\"uniform float \"+e.name+(t>1?\"[\"+t+\"]\":\"\")+\";\":\"uniform sampler2D \"+e.name+\";\"});a=a.join(\"\\n\");var i,s,u=e.map(function(e){return getInputSamplingSnippet(e,t,r,o)}).join(\"\\n\"),l=t.texShape,c=SHADER_PREFIX;return t.isPacked?(i=getPackedOutputSamplingSnippet(t.logicalShape,l),s=FLOAT_TEXTURE_SET_RGBA_SNIPPET):(i=getOutputSamplingSnippet(t.logicalShape,l),s=FLOAT_TEXTURE_SET_R_SNIPPET),o&&(c+=SHADER_PACKED_PREFIX),[c,FLOAT_TEXTURE_SAMPLE_SNIPPET,s,a,i,u,n].join(\"\\n\")}function getSamplerFromInInfo(e){var t=e.shapeInfo.logicalShape;switch(t.length){case 0:return getSamplerScalar(e);case 1:return getSampler1D(e);case 2:return getSampler2D(e);case 3:return getSampler3D(e);case 4:return getSampler4D(e);case 5:return getSampler5D(e);case 6:return getSampler6D(e);default:throw new Error(t.length+\"-D input sampling is not yet supported\")}}function getPackedSamplerFromInInfo(e){var t=e.shapeInfo.logicalShape;switch(t.length){case 0:return getPackedSamplerScalar(e);case 1:return getPackedSampler1D(e);case 2:return getPackedSampler2D(e);case 3:return getPackedSampler3D(e);case 4:return getPackedSampler4D(e);default:throw new Error(\"Packed \"+t.length+\"-D input sampling is not yet supported\")}}function getInputSamplingSnippet(e,t,n,r){void 0===r&&(r=!1);var o=getSamplerFlat(e);return o+=r?getPackedSamplerFromInInfo(e):getSamplerFromInInfo(e),(n||arraysEqual(e.shapeInfo.logicalShape,t.logicalShape))&&(o+=r?getPackedSamplerAtOutputCoords(e,t,n):getSamplerAtOutputCoords(e,t,n)),o}function getPackedOutputSamplingSnippet(e,t){switch(e.length){case 0:return getOutputScalarCoords();case 1:return getOutputPacked1DCoords(e,t);case 2:return getOutputPacked2DCoords(e,t);case 3:return getOutputPacked3DCoords(e,t);case 4:return getOutputPacked4DCoords(e,t);default:throw new Error(e.length+\"-D packed output coordinate fetching is not yet supported\")}}function getOutputSamplingSnippet(e,t){switch(e.length){case 0:return getOutputScalarCoords();case 1:return getOutput1DCoords(e,t);case 2:return getOutput2DCoords(e,t);case 3:return getOutput3DCoords(e,t);case 4:return getOutput4DCoords(e,t);case 5:return getOutput5DCoords(e,t);case 6:return getOutput6DCoords(e,t);default:throw new Error(e.length+\"-D output sampling is not yet supported\")}}var SAMPLE_1D_SNIPPET=\"\\nvec2 UVfrom1D(int texNumR, int texNumC, int index) {\\n  int texR = index / texNumC;\\n  int texC = index - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\\n  int texelIndex = index / 2;\\n  int texR = texelIndex / texNumC;\\n  int texC = texelIndex - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\n\",SAMPLE_2D_SNIPPET=\"\\nvec2 UVfrom2D(int texNumR, int texNumC, int numC, int row, int col) {\\n  int index = row * numC + col;\\n  int texR = index / texNumC;\\n  int texC = index - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\\n  int texNumC, int row, int col) {\\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\\n  int texR = texelIndex / texNumC;\\n  int texC = texelIndex - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\n\",SAMPLE_3D_SNIPPET=\"\\nvec2 UVfrom3D(int texNumR, int texNumC, int stride0,\\n    int stride1, int row, int col, int depth) {\\n  // Explicitly use integer operations as dot() only works on floats.\\n  int index = row * stride0 + col * stride1 + depth;\\n  int texR = index / texNumC;\\n  int texC = index - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\nvec2 packedUVfrom3D(int texNumR, int texNumC,\\n    int texelsInBatch, int texelsInLogicalRow, int b,\\n    int row, int col) {\\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\\n  int texR = index / texNumC;\\n  int texC = index - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\n\",SAMPLE_4D_SNIPPET=\"\\nvec2 UVfrom4D(int texNumR, int texNumC, int stride0,\\n    int stride1, int stride2, int row, int col, int depth,\\n    int depth2) {\\n  // Explicitly use integer operations as dot() only works on floats.\\n  int index = row * stride0 + col * stride1 + depth * stride2 + depth2;\\n  int texR = index / texNumC;\\n  int texC = index - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\nvec2 packedUVfrom4D(int texNumR, int texNumC, int texelsInBatch2,\\n    int texelsInBatch, int texelsInLogicalRow, int b2, int b,\\n    int row, int col) {\\n  int index = b2 * texelsInBatch2 + b * texelsInBatch +\\n    (row / 2) * texelsInLogicalRow + (col / 2);\\n  int texR = index / texNumC;\\n  int texC = index - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\n\",SAMPLE_5D_SNIPPET=\"\\nvec2 UVfrom5D(int texNumR, int texNumC, int stride0,\\n    int stride1, int stride2, int stride3, int row, int col, int depth,\\n    int depth2, int depth3) {\\n  // Explicitly use integer operations as dot() only works on floats.\\n  int index = row * stride0 + col * stride1 +\\n              depth * stride2 + depth2 * stride3 + depth3;\\n  int texR = index / texNumC;\\n  int texC = index - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\n\",SAMPLE_6D_SNIPPET=\"\\nvec2 UVfrom6D(int texNumR, int texNumC, int stride0,\\n    int stride1, int stride2, int stride3, int stride4,\\n    int row, int col, int depth, int depth2, int depth3, int depth4) {\\n  // Explicitly use integer operations as dot() only works on floats.\\n  int index = row * stride0 + col * stride1 + depth * stride2 + depth2 *\\n    stride3 + depth3 * stride4 + depth4;\\n  int texR = index / texNumC;\\n  int texC = index - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\n\",FLOAT_TEXTURE_SAMPLE_SNIPPET=\"\\n  float sampleTexture(sampler2D textureSampler, vec2 uv) {\\n    return texture2D(textureSampler, uv).r;\\n  }\\n\",FLOAT_TEXTURE_SET_R_SNIPPET=\"\\n  void setOutput(float val) {\\n    gl_FragColor = vec4(val, 0, 0, 0);\\n  }\\n\",FLOAT_TEXTURE_SET_RGBA_SNIPPET=\"\\n  void setOutput(vec4 val) {\\n    gl_FragColor = val;\\n  }\\n\",NAN_CHECKS=\"\",SHADER_PREFIX=\"\\n  precision highp float;\\n  precision highp int;\\n  varying vec2 resultUV;\\n  const vec2 halfCR = vec2(0.5, 0.5);\\n\\n  struct ivec5\\n  {\\n    int x;\\n    int y;\\n    int z;\\n    int w;\\n    int u;\\n  };\\n\\n  struct ivec6\\n  {\\n    int x;\\n    int y;\\n    int z;\\n    int w;\\n    int u;\\n    int v;\\n  };\\n\\n  \"+(NAN_CHECKS=ENV.get(\"PROD\")?\"\\n    bool isNaN(float val) {\\n      return false;\\n    }\\n\\n    bool hasNaN(vec4 values) {\\n      return false;\\n    }\\n  \":\"\\n    bool isNaN(float val) {\\n      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;\\n    }\\n\\n    bool hasNaN(vec4 values) {\\n      return any(bvec4(\\n        isNaN(values.x),\\n        isNaN(values.y),\\n        isNaN(values.z),\\n        isNaN(values.w)\\n      ));\\n    }\\n  \")+\"\\n\\n  float getNaN(vec4 values) {\\n    return dot(vec4(1), values);\\n  }\\n\\n  int round(float value) {\\n    return int(floor(value + 0.5));\\n  }\\n\\n  int imod(int x, int y) {\\n    return x - y * (x / y);\\n  }\\n\\n  //Based on the work of Dave Hoskins\\n  //https://www.shadertoy.com/view/4djSRW\\n  #define HASHSCALE1 443.8975\\n  float random(float seed){\\n    vec2 p = resultUV * seed;\\n    vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\\n    p3 += dot(p3, p3.yzx + 19.19);\\n    return fract((p3.x + p3.y) * p3.z);\\n  }\\n\\n  \"+SAMPLE_1D_SNIPPET+\"\\n  \"+SAMPLE_2D_SNIPPET+\"\\n  \"+SAMPLE_3D_SNIPPET+\"\\n  \"+SAMPLE_4D_SNIPPET+\"\\n  \"+SAMPLE_5D_SNIPPET+\"\\n  \"+SAMPLE_6D_SNIPPET+\"\\n\",SHADER_PACKED_PREFIX=\"\\n  float getChannel(vec4 frag, vec2 innerDims) {\\n    vec2 modCoord = mod(innerDims, 2.);\\n    return modCoord.x == 0. ?\\n      (modCoord.y == 0. ? frag.r : frag.g) :\\n      (modCoord.y == 0. ? frag.b : frag.a);\\n  }\\n  float getChannel(vec4 frag, int dim) {\\n    float modCoord = mod(float(dim), 2.);\\n    return modCoord == 0. ? frag.r : frag.g;\\n  }\\n\";function getOutputScalarCoords(){return \"\\n    int getOutputCoords() {\\n      return 0;\\n    }\\n  \"}function getOutputPacked1DCoords(e,t){var n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return 1===t[0]?\"\\n      int getOutputCoords() {\\n        return 2 * int(resultUV.x * \"+n[1]+\".0);\\n      }\\n    \":1===t[1]?\"\\n      int getOutputCoords() {\\n        return 2 * int(resultUV.y * \"+n[0]+\".0);\\n      }\\n    \":\"\\n    int getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\"+n[0]+\", \"+n[1]+\"));\\n      return resTexRC.x * \"+n[1]+\" + resTexRC.y;\\n    }\\n  \"}function getOutput1DCoords(e,t){return 1===t[0]?\"\\n      int getOutputCoords() {\\n        return int(resultUV.x * \"+t[1]+\".0);\\n      }\\n    \":1===t[1]?\"\\n      int getOutputCoords() {\\n        return int(resultUV.y * \"+t[0]+\".0);\\n      }\\n    \":\"\\n    int getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\"+t[0]+\", \"+t[1]+\"));\\n      return resTexRC.x * \"+t[1]+\" + resTexRC.y;\\n    }\\n  \"}function getOutputPacked3DCoords(e,t){var n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[2]/2),o=r*Math.ceil(e[1]/2);return \"\\n    ivec3 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\"+n[0]+\", \"+n[1]+\"));\\n      int index = resTexRC.x * \"+n[1]+\" + resTexRC.y;\\n\\n      int b = index / \"+o+\";\\n      index -= b * \"+o+\";\\n\\n      int r = 2 * (index / \"+r+\");\\n      int c = imod(index, \"+r+\") * 2;\\n\\n      return ivec3(b, r, c);\\n    }\\n  \"}function getOutput3DCoords(e,t){var n=getLogicalCoordinatesFromFlatIndex([\"r\",\"c\",\"d\"],e);return \"\\n    ivec3 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\"+t[0]+\", \"+t[1]+\"));\\n      int index = resTexRC.x * \"+t[1]+\" + resTexRC.y;\\n      \"+n+\"\\n      return ivec3(r, c, d);\\n    }\\n  \"}function getOutputPacked4DCoords(e,t){var n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[3]/2),o=r*Math.ceil(e[2]/2),a=o*e[1];return \"\\n    ivec4 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\"+n[0]+\", \"+n[1]+\"));\\n      int index = resTexRC.x * \"+n[1]+\" + resTexRC.y;\\n\\n      int b2 = index / \"+a+\";\\n      index -= b2 * \"+a+\";\\n\\n      int b = index / \"+o+\";\\n      index -= b * \"+o+\";\\n\\n      int r = 2 * (index / \"+r+\");\\n      int c = imod(index, \"+r+\") * 2;\\n\\n      return ivec4(b2, b, r, c);\\n    }\\n  \"}function getOutput4DCoords(e,t){var n=getLogicalCoordinatesFromFlatIndex([\"r\",\"c\",\"d\",\"d2\"],e);return \"\\n    ivec4 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n        vec2(\"+t[0]+\", \"+t[1]+\"));\\n      int index = resTexRC.x * \"+t[1]+\" + resTexRC.y;\\n      \"+n+\"\\n      return ivec4(r, c, d, d2);\\n    }\\n  \"}function getOutput5DCoords(e,t){var n=getLogicalCoordinatesFromFlatIndex([\"r\",\"c\",\"d\",\"d2\",\"d3\"],e);return \"\\n    ivec5 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(\"+t[0]+\",\\n                             \"+t[1]+\"));\\n\\n      int index = resTexRC.x * \"+t[1]+\" + resTexRC.y;\\n\\n      \"+n+\"\\n\\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\\n      return outShape;\\n    }\\n  \"}function getOutput6DCoords(e,t){var n=getLogicalCoordinatesFromFlatIndex([\"r\",\"c\",\"d\",\"d2\",\"d3\",\"d4\"],e);return \"\\n    ivec6 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n        vec2(\"+t[0]+\", \"+t[1]+\"));\\n      int index = resTexRC.x * \"+t[1]+\" + resTexRC.y;\\n\\n      \"+n+\"\\n\\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\\n      return result;\\n    }\\n  \"}function getOutputPacked2DCoords(e,t){var n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(arraysEqual(e,t))return \"\\n      ivec2 getOutputCoords() {\\n        return 2 * ivec2(resultUV.yx * vec2(\"+n[0]+\", \"+n[1]+\"));\\n      }\\n    \";var r=Math.ceil(e[1]/2);return \"\\n    ivec2 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\"+n[0]+\", \"+n[1]+\"));\\n\\n      int index = resTexRC.x * \"+n[1]+\" + resTexRC.y;\\n      int r = 2 * (index / \"+r+\");\\n      int c = imod(index, \"+r+\") * 2;\\n\\n      return ivec2(r, c);\\n    }\\n  \"}function getOutput2DCoords(e,t){return arraysEqual(e,t)?\"\\n      ivec2 getOutputCoords() {\\n        return ivec2(resultUV.yx * vec2(\"+t[0]+\", \"+t[1]+\"));\\n      }\\n    \":1===e[1]?\"\\n      ivec2 getOutputCoords() {\\n        ivec2 resTexRC = ivec2(resultUV.yx *\\n                               vec2(\"+t[0]+\", \"+t[1]+\"));\\n        int index = resTexRC.x * \"+t[1]+\" + resTexRC.y;\\n        return ivec2(index, 0);\\n      }\\n    \":1===e[0]?\"\\n      ivec2 getOutputCoords() {\\n        ivec2 resTexRC = ivec2(resultUV.yx *\\n                               vec2(\"+t[0]+\", \"+t[1]+\"));\\n        int index = resTexRC.x * \"+t[1]+\" + resTexRC.y;\\n        return ivec2(0, index);\\n      }\\n    \":\"\\n    ivec2 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\"+t[0]+\", \"+t[1]+\"));\\n      int index = resTexRC.x * \"+t[1]+\" + resTexRC.y;\\n      int r = index / \"+e[1]+\";\\n      int c = index - r * \"+e[1]+\";\\n      return ivec2(r, c);\\n    }\\n  \"}function getPackedSamplerScalar(e){var t=e.name;return \"\\n    vec4 \"+(\"get\"+t.charAt(0).toUpperCase()+t.slice(1))+\"() {\\n      return texture2D(\"+t+\", halfCR);\\n    }\\n  \"}function getSamplerScalar(e){var t=e.name,n=\"get\"+t.charAt(0).toUpperCase()+t.slice(1);return e.shapeInfo.isUniform?\"float \"+n+\"() {return \"+t+\";}\":\"\\n    float \"+n+\"() {\\n      return sampleTexture(\"+t+\", halfCR);\\n    }\\n  \"}function getPackedSampler1D(e){var t=e.name,n=\"get\"+t.charAt(0).toUpperCase()+t.slice(1),r=e.shapeInfo.texShape,o=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return \"\\n    vec4 \"+n+\"(int index) {\\n      vec2 uv = packedUVfrom1D(\\n        \"+o[0]+\", \"+o[1]+\", index);\\n      return texture2D(\"+t+\", uv);\\n    }\\n  \"}function getSampler1D(e){var t=e.name,n=\"get\"+t.charAt(0).toUpperCase()+t.slice(1);return \"\\n    float \"+n+\"(int index) {\\n      return \"+n+\"Flat(index);\\n    }\\n  \"}function getPackedSampler2D(e){var t=e.shapeInfo.logicalShape,n=e.name,r=\"get\"+n.charAt(0).toUpperCase()+n.slice(1),o=e.shapeInfo.texShape,a=o[0],i=o[1];if(null!=o&&arraysEqual(t,o))return \"\\n      vec4 \"+r+\"(int row, int col) {\\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(\"+i+\".0, \"+a+\".0);\\n\\n        return texture2D(\"+n+\", uv);\\n      }\\n    \";var s=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];return \"\\n    vec4 \"+r+\"(int row, int col) {\\n      vec2 uv = packedUVfrom2D(\"+Math.ceil(t[1]/2)+\", \"+s[0]+\", \"+s[1]+\", row, col);\\n      return texture2D(\"+n+\", uv);\\n    }\\n  \"}function getSampler2D(e){var t=e.shapeInfo.logicalShape,n=e.name,r=\"get\"+n.charAt(0).toUpperCase()+n.slice(1),o=e.shapeInfo.texShape;if(null!=o&&arraysEqual(t,o)){var a=o[0];return \"\\n    float \"+r+\"(int row, int col) {\\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(\"+o[1]+\".0, \"+a+\".0);\\n      return sampleTexture(\"+n+\", uv);\\n    }\\n  \"}var i=squeezeShape(t),s=i.newShape,u=i.keptDims,l=s;if(l.length<t.length){return \"\\n      \"+getSamplerFromInInfo(squeezeInputInfo(e,l))+\"\\n      float \"+r+\"(int row, int col) {\\n        return \"+r+\"(\"+getSqueezedParams([\"row\",\"col\"],u)+\");\\n      }\\n    \"}if(e.shapeInfo.isUniform)return \"\\n      float \"+r+\"(int row, int col) {\\n        float index = dot(vec2(row, col), vec2(\"+t[1]+\", 1));\\n        return \"+r+\"Flat(round(index));\\n      }\\n    \";var c=o[0],p=o[1];return 1===p?\"\\n    float \"+r+\"(int row, int col) {\\n      float index = dot(vec2(row, col), vec2(\"+t[1]+\", 1));\\n      vec2 uv = vec2(0.5, (index + 0.5) / \"+c+\".0);\\n      return sampleTexture(\"+n+\", uv);\\n    }\\n  \":1===c?\"\\n    float \"+r+\"(int row, int col) {\\n      float index = dot(vec2(row, col), vec2(\"+t[1]+\", 1));\\n      vec2 uv = vec2((index + 0.5) / \"+p+\".0, 0.5);\\n      return sampleTexture(\"+n+\", uv);\\n    }\\n  \":\"\\n  float \"+r+\"(int row, int col) {\\n    vec2 uv = UVfrom2D(\"+c+\", \"+p+\", \"+t[1]+\", row, col);\\n    return sampleTexture(\"+n+\", uv);\\n  }\\n\"}function getPackedSampler3D(e){var t=e.shapeInfo.logicalShape,n=e.name,r=\"get\"+n.charAt(0).toUpperCase()+n.slice(1),o=e.shapeInfo.texShape,a=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(1===t[0]){return \"\\n        \"+getPackedSamplerFromInInfo(squeezeInputInfo(e,t.slice(1)))+\"\\n        vec4 \"+r+\"(int b, int row, int col) {\\n          return \"+r+\"(\"+getSqueezedParams([\"b\",\"row\",\"col\"],[1,2])+\");\\n        }\\n      \"}var i=a[0],s=a[1],u=Math.ceil(t[2]/2);return \"\\n    vec4 \"+r+\"(int b, int row, int col) {\\n      vec2 uv = packedUVfrom3D(\\n        \"+i+\", \"+s+\", \"+u*Math.ceil(t[1]/2)+\", \"+u+\", b, row, col);\\n      return texture2D(\"+n+\", uv);\\n    }\\n  \"}function getSampler3D(e){var t=e.shapeInfo.logicalShape,n=e.name,r=\"get\"+n.charAt(0).toUpperCase()+n.slice(1),o=t[1]*t[2],a=t[2],i=squeezeShape(t),s=i.newShape,u=i.keptDims,l=s;if(l.length<t.length){return \"\\n        \"+getSamplerFromInInfo(squeezeInputInfo(e,l))+\"\\n        float \"+r+\"(int row, int col, int depth) {\\n          return \"+r+\"(\"+getSqueezedParams([\"row\",\"col\",\"depth\"],u)+\");\\n        }\\n      \"}if(e.shapeInfo.isUniform)return \"\\n      float \"+r+\"(int row, int col, int depth) {\\n        float index = dot(vec3(row, col, depth),\\n                          vec3(\"+o+\", \"+a+\", 1));\\n        return \"+r+\"Flat(round(index));\\n      }\\n    \";var c=e.shapeInfo.texShape,p=c[0],d=c[1];return d===o?\"\\n        float \"+r+\"(int row, int col, int depth) {\\n          float texR = float(row);\\n          float texC = dot(vec2(col, depth), vec2(\"+a+\", 1));\\n          vec2 uv = (vec2(texC, texR) + halfCR) /\\n                     vec2(\"+d+\".0, \"+p+\".0);\\n          return sampleTexture(\"+n+\", uv);\\n        }\\n      \":d===a?\"\\n    float \"+r+\"(int row, int col, int depth) {\\n      float texR = dot(vec2(row, col), vec2(\"+t[1]+\", 1));\\n      float texC = float(depth);\\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(\"+d+\".0, \"+p+\".0);\\n      return sampleTexture(\"+n+\", uv);\\n    }\\n  \":\"\\n      float \"+r+\"(int row, int col, int depth) {\\n        vec2 uv = UVfrom3D(\\n            \"+p+\", \"+d+\", \"+o+\", \"+a+\", row, col, depth);\\n        return sampleTexture(\"+n+\", uv);\\n      }\\n  \"}function getPackedSampler4D(e){var t=e.shapeInfo.logicalShape,n=e.name,r=\"get\"+n.charAt(0).toUpperCase()+n.slice(1),o=e.shapeInfo.texShape,a=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],i=a[0],s=a[1],u=Math.ceil(t[3]/2),l=u*Math.ceil(t[2]/2);return \"\\n    vec4 \"+r+\"(int b2, int b, int row, int col) {\\n      vec2 uv = packedUVfrom4D(\\n        \"+i+\", \"+s+\", \"+l*t[1]+\",\\n        \"+l+\", \"+u+\", b2, b, row, col);\\n      return texture2D(\"+n+\", uv);\\n    }\\n  \"}function getSampler4D(e){var t=e.shapeInfo.logicalShape,n=e.name,r=\"get\"+n.charAt(0).toUpperCase()+n.slice(1),o=t[3],a=t[2]*o,i=t[1]*a,s=squeezeShape(t),u=s.newShape,l=s.keptDims;if(u.length<t.length){return \"\\n      \"+getSamplerFromInInfo(squeezeInputInfo(e,u))+\"\\n      float \"+r+\"(int row, int col, int depth, int depth2) {\\n        return \"+r+\"(\"+getSqueezedParams([\"row\",\"col\",\"depth\",\"depth2\"],l)+\");\\n      }\\n    \"}if(e.shapeInfo.isUniform)return \"\\n      float \"+r+\"(int row, int col, int depth, int depth2) {\\n        float index = dot(vec4(row, col, depth, depth2),\\n                          vec4(\"+i+\", \"+a+\", \"+o+\", 1));\\n        return \"+r+\"Flat(round(index));\\n      }\\n    \";var c=e.shapeInfo.texShape,p=c[0],d=c[1];return d===i?\"\\n      float \"+r+\"(int row, int col, int depth, int depth2) {\\n        float texR = float(row);\\n        float texC =\\n            dot(vec3(col, depth, depth2), vec3(\"+a+\", \"+o+\", 1));\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                   vec2(\"+d+\".0, \"+p+\".0);\\n        return sampleTexture(\"+n+\", uv);\\n      }\\n    \":d===o?\"\\n      float \"+r+\"(int row, int col, int depth, int depth2) {\\n        float texR = dot(vec3(row, col, depth),\\n                         vec3(\"+t[1]*t[2]+\", \"+t[2]+\", 1));\\n        float texC = float(depth2);\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                  vec2(\"+d+\".0, \"+p+\".0);\\n        return sampleTexture(\"+n+\", uv);\\n      }\\n    \":\"\\n    float \"+r+\"(int row, int col, int depth, int depth2) {\\n      vec2 uv = UVfrom4D(\"+p+\", \"+d+\", \"+i+\", \"+a+\",\\n          \"+o+\", row, col, depth, depth2);\\n      return sampleTexture(\"+n+\", uv);\\n    }\\n  \"}function getSampler5D(e){var t=e.shapeInfo.logicalShape,n=e.name,r=\"get\"+n.charAt(0).toUpperCase()+n.slice(1),o=t[4],a=t[3]*o,i=t[2]*a,s=t[1]*i,u=squeezeShape(t),l=u.newShape,c=u.keptDims;if(l.length<t.length){return \"\\n      \"+getSamplerFromInInfo(squeezeInputInfo(e,l))+\"\\n      float \"+r+\"(int row, int col, int depth, int depth2, int depth3) {\\n        return \"+r+\"(\"+getSqueezedParams([\"row\",\"col\",\"depth\",\"depth2\",\"depth3\"],c)+\");\\n      }\\n    \"}if(e.shapeInfo.isUniform)return \"\\n      float \"+r+\"(int row, int col, int depth, int depth2, int depth3) {\\n        float index = dot(\\n          vec4(row, col, depth, depth2),\\n          vec4(\"+s+\", \"+i+\", \"+a+\", \"+o+\")) +\\n          depth3;\\n        return \"+r+\"Flat(index);\\n      }\\n    \";var p=e.shapeInfo.texShape,d=p[0],h=p[1];return h===s?\"\\n      float \"+r+\"(int row, int col, int depth, int depth2, int depth3) {\\n        int texR = row;\\n        float texC = dot(\\n          vec4(col, depth, depth2, depth3),\\n          vec4(\"+i+\", \"+a+\", \"+o+\", 1));\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                   vec2(\"+h+\".0, \"+d+\".0);\\n        return sampleTexture(\"+n+\", uv);\\n      }\\n    \":h===o?\"\\n      float \"+r+\"(int row, int col, int depth, int depth2, int depth3) {\\n        float texR = dot(\\n          vec4(row, col, depth, depth2),\\n          vec4(\"+t[1]*t[2]*t[3]+\", \"+t[2]*t[3]+\",\\n            \"+t[3]+\", 1));\\n        int texC = depth3;\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                  vec2(\"+h+\".0, \"+d+\".0);\\n        return sampleTexture(\"+n+\", uv);\\n      }\\n    \":\"\\n    float \"+r+\"(int row, int col, int depth, int depth2, int depth3) {\\n      vec2 uv = UVfrom5D(\"+d+\", \"+h+\", \"+s+\", \"+i+\",\\n          \"+a+\", \"+o+\", row, col, depth, depth2, depth3);\\n      return sampleTexture(\"+n+\", uv);\\n    }\\n  \"}function getSampler6D(e){var t=e.shapeInfo.logicalShape,n=e.name,r=\"get\"+n.charAt(0).toUpperCase()+n.slice(1),o=t[5],a=t[4]*o,i=t[3]*a,s=t[2]*i,u=t[1]*s,l=squeezeShape(t),c=l.newShape,p=l.keptDims;if(c.length<t.length){return \"\\n      \"+getSamplerFromInInfo(squeezeInputInfo(e,c))+\"\\n      float \"+r+\"(int row, int col, int depth,\\n                    int depth2, int depth3, int depth4) {\\n        return \"+r+\"(\"+getSqueezedParams([\"row\",\"col\",\"depth\",\"depth2\",\"depth3\",\"depth4\"],p)+\");\\n      }\\n    \"}if(e.shapeInfo.isUniform)return \"\\n      float \"+r+\"(int row, int col, int depth,\\n                  int depth2, int depth3, int depth4) {\\n        float index = dot(\\n          vec4(row, col, depth, depth2),\\n          vec4(\"+u+\", \"+s+\", \"+i+\", \"+a+\")) +\\n          dot(\\n            vec2(depth3, depth4),\\n            vec2(\"+o+\", 1));\\n        return \"+r+\"Flat(index);\\n      }\\n    \";var d=e.shapeInfo.texShape,h=d[0],f=d[1];return f===u?\"\\n      float \"+r+\"(int row, int col, int depth,\\n                    int depth2, int depth3, int depth4) {\\n        int texR = row;\\n        float texC = dot(\\n          vec4(col, depth, depth2, depth3),\\n          vec4(\"+s+\", \"+i+\", \"+a+\", \"+o+\")) + depth4;\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                   vec2(\"+f+\".0, \"+h+\".0);\\n        return sampleTexture(\"+n+\", uv);\\n      }\\n    \":f===o?\"\\n      float \"+r+\"(int row, int col, int depth,\\n                    int depth2, int depth3, int depth4) {\\n        float texR = dot(\\n          vec4(row, col, depth, depth2),\\n          vec4(\"+t[1]*t[2]*t[3]*t[4]+\",\\n               \"+t[2]*t[3]*t[4]+\",\\n               \"+t[3]*t[4]+\",\\n               \"+t[4]+\")) + depth3;\\n        int texC = depth4;\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                  vec2(\"+f+\".0, \"+h+\".0);\\n        return sampleTexture(\"+n+\", uv);\\n      }\\n    \":\"\\n    float \"+r+\"(int row, int col, int depth,\\n                  int depth2, int depth3, int depth4) {\\n      vec2 uv = UVfrom6D(\"+h+\", \"+f+\", \"+u+\", \"+s+\",\\n          \"+i+\", \"+a+\", \"+o+\"\\n          ,row, col, depth, depth2, depth3, depth4);\\n      return sampleTexture(\"+n+\", uv);\\n    }\\n  \"}function getSamplerFlat(e){var t=e.name,n=\"get\"+t.charAt(0).toUpperCase()+t.slice(1)+\"Flat\",r=sizeFromShape(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform)return 1===r?\"float \"+n+\"(int index) {return \"+t+\";}\":\"\\n      float \"+n+\"(int index) {\\n        for (int i = 0; i < \"+r+\"; i++) {\\n          if (i == index) {\\n            return \"+t+\"[i];\\n          }\\n        }\\n      }\\n    \";var o=e.shapeInfo.texShape,a=o[0],i=o[1];return 1===i&&1===a?\"\\n      float \"+n+\"(int index) {\\n        return sampleTexture(\"+t+\", halfCR);\\n      }\\n    \":1===i?\"\\n      float \"+n+\"(int index) {\\n        vec2 uv = vec2(0.5, (float(index) + 0.5) / \"+a+\".0);\\n        return sampleTexture(\"+t+\", uv);\\n      }\\n    \":1===a?\"\\n      float \"+n+\"(int index) {\\n        vec2 uv = vec2((float(index) + 0.5) / \"+i+\".0, 0.5);\\n        return sampleTexture(\"+t+\", uv);\\n      }\\n    \":\"\\n    float \"+n+\"(int index) {\\n      vec2 uv = UVfrom1D(\"+a+\", \"+i+\", index);\\n      return sampleTexture(\"+t+\", uv);\\n    }\\n  \"}function getBroadcastOutputCoordsSampler(e,t,n,r){var o=e.shapeInfo.logicalShape.length,a=t.logicalShape.length,i=\"int\";2===a?i=\"ivec2\":3===a?i=\"ivec3\":4===a&&(i=\"ivec4\");var s=getBroadcastDims(e.shapeInfo.logicalShape,t.logicalShape),u=a-o;return \"\\n    float \"+r+\"() {\\n      \"+i+\" coords = getOutputCoords();\\n      \"+(0===o?\"\":a<2&&s.length>=1?\"coords = 0;\":s.map(function(e){return \"coords[\"+(e+u)+\"] = 0;\"}).join(\"\\n\"))+\"\\n      return get\"+n+\"(\"+(a<2&&o>0?\"coords\":e.shapeInfo.logicalShape.map(function(e,t){return \"coords[\"+(t+u)+\"]\"}).join(\", \"))+\");\\n    }\\n  \"}function getPackedSamplerAtOutputCoords(e,t,n){var r=e.name,o=r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape,i=\"get\"+o+\"AtOutCoords\",s=t.texShape,u=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],l=u[0],c=u[1],p=getBroadcastDims(e.shapeInfo.logicalShape,t.logicalShape),d=e.shapeInfo.logicalShape.length,h=t.logicalShape.length;if(p.length)throw Error(\"Packed broadcast sampling is not implemented yet.\");if(arraysEqual(e.shapeInfo.texShape,s))return \"\\n      vec4 \"+i+\"() {\\n        return texture2D(\"+r+\", resultUV);\\n      }\\n    \";var f=\"return texture2D(\"+r+\", uv)\";return 1===d&&h>1?f=\"\\n      vec4 sample = texture2D(\"+r+\", uv);\\n      return vec4(sample.xy, sample.xy);\\n    \":0===d&&h>0&&(f=1===h?\"\\n        vec4 sample = texture2D(\"+r+\", uv);\\n        return vec4(sample.x, sample.x, 0., 0.);\\n      \":\"\\n        vec4 sample = texture2D(\"+r+\", uv);\\n        return vec4(sample.x);\\n      \"),\"\\n    vec4 \"+i+\"() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\"+u[0]+\", \"+u[1]+\"));\\n      int index = resTexRC.x * \"+u[1]+\" + resTexRC.y;\\n\\n      int texR = index / \"+c+\";\\n      int texC = index - texR * \"+c+\";\\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(\"+c+\", \"+l+\");\\n\\n      \"+f+\";\\n    }\\n  \"}function getSamplerAtOutputCoords(e,t,n){var r=e.name,o=r.charAt(0).toUpperCase()+r.slice(1),a=\"get\"+o+\"AtOutCoords\",i=getBroadcastDims(e.shapeInfo.logicalShape,t.logicalShape),s=e.shapeInfo.logicalShape.length,u=t.logicalShape.length,l=n&&(u>s||i.length>0),c=broadcastDimsAreOuter(i),p=e.shapeInfo.isUniform;if(l&&!c)return getBroadcastOutputCoordsSampler(e,t,o,a);var d=sizeFromShape(e.shapeInfo.logicalShape),h=\"\";l&&c&&(h=\"\\n        int mainPart = index / \"+d+\";\\n        index -= mainPart * \"+d+\";\\n      \");var f=t.texShape;if(p)return 1===d?\"float \"+a+\"() {return \"+r+\";}\":\"\\n      float \"+a+\"() {\\n        ivec2 resTexRC = ivec2(resultUV.yx *\\n                              vec2(\"+f[0]+\", \"+f[1]+\"));\\n        int index = resTexRC.x * \"+f[1]+\" + resTexRC.y;\\n        \"+h+\"\\n        return get\"+o+\"Flat(index);\\n      }\\n    \";var m=e.shapeInfo.texShape;return arraysEqual(m,f)?\"\\n      float \"+a+\"() {\\n        return sampleTexture(\"+r+\", resultUV);\\n      }\\n    \":\"\\n    float \"+a+\"() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\"+f[0]+\", \"+f[1]+\"));\\n      int index = resTexRC.x * \"+f[1]+\" + resTexRC.y;\\n      \"+h+\"\\n      int texR = index / \"+m[1]+\";\\n      int texC = index - texR * \"+m[1]+\";\\n      vec2 uv = (vec2(texC, texR) + halfCR) /\\n                 vec2(\"+m[1]+\".0, \"+m[0]+\".0);\\n\\n      return sampleTexture(\"+r+\", uv);\\n    }\\n  \"}function getCoordsDataType(e){if(e<=1)return \"int\";if(2===e)return \"ivec2\";if(3===e)return \"ivec3\";if(4===e)return \"ivec4\";if(5===e)return \"ivec5\";if(6===e)return \"ivec6\";throw Error(\"GPU for rank \"+e+\" is not yet supported\")}function squeezeInputInfo(e,t){var n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function getSqueezedParams(e,t){return t.map(function(t){return e[t]}).join(\", \")}var CumSumProgram=function(){return function(e,t,n){this.variableNames=[\"x\"],this.outputShape=e;var r=e.length,o=e[e.length-1],a=n?\"<\":\">\";this.userCode=\"\\n      int getIndex(int i) {\\n        \"+(n?\"return \"+o+\" -i - 1;\":\"return i;\")+\"\\n      }\\n\\n      void main() {\\n        \"+getCoordsDataType(r)+\" coords = getOutputCoords();\\n        int end = \"+getFinalCoord(r,\"coords\")+\";\\n        float val = 0.0;\\n        for (int i = \"+o+\" - 1; i >= 0; i -= 1) {\\n          int idx = getIndex(i);\\n          if (idx \"+a+\" end) {\\n            continue;\\n          }\\n          if (idx == end && \"+t+\") {\\n            continue;\\n          }\\n          \"+getFinalCoord(r,\"coords\")+\" = idx;\\n          val += getX(\"+getCoords(r,\"coords\")+\");\\n        }\\n        setOutput(val);\\n      }\\n    \";}}();function getCoords(e,t){if(1===e)return \"\"+t;if(2===e)return t+\".x, \"+t+\".y\";if(3===e)return t+\".x, \"+t+\".y, \"+t+\".z\";if(4===e)return t+\".x, \"+t+\".y, \"+t+\".z, \"+t+\".w\";throw Error(\"Cumulative sum for rank \"+e+\" is not yet supported\")}function getFinalCoord(e,t){if(1===e)return \"\"+t;if(2===e)return t+\".y\";if(3===e)return t+\".z\";if(4===e)return t+\".w\";throw Error(\"Cumulative sum for rank \"+e+\" is not yet supported\")}var DepthToSpaceProgram=function(){function e(e,t,n){this.variableNames=[\"x\"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=\"\\n    void main() {\\n      ivec4 coords = getOutputCoords();\\n      int b = coords[0];\\n      int h = \"+this.getHeightCoordString()+\";\\n      int w = \"+this.getWidthCoordString()+\";\\n      int d = \"+this.getDepthCoordString()+\";\\n\\n      int in_h = h / \"+t+\";\\n      int offset_h = imod(h, \"+t+\");\\n      int in_w = w / \"+t+\";\\n      int offset_w = imod(w, \"+t+\");\\n      int offset_d = (offset_h * \"+t+\" + offset_w) *\\n        \"+this.getOutputDepthSize()+\";\\n      int in_d = d + offset_d;\\n\\n      float result = \"+this.getInputSamplingString()+\";\\n      setOutput(result);\\n    }\\n  \";}return e.prototype.getHeightCoordString=function(){return \"NHWC\"===this.dataFormat?\"coords[1]\":\"coords[2]\"},e.prototype.getWidthCoordString=function(){return \"NHWC\"===this.dataFormat?\"coords[2]\":\"coords[3]\"},e.prototype.getDepthCoordString=function(){return \"NHWC\"===this.dataFormat?\"coords[3]\":\"coords[1]\"},e.prototype.getOutputDepthSize=function(){return \"NHWC\"===this.dataFormat?this.outputShape[3]:this.outputShape[1]},e.prototype.getInputSamplingString=function(){return \"NHWC\"===this.dataFormat?\"getX(b, in_h, in_w, in_d)\":\"getX(b, in_d, in_h, in_w)\"},e}(),EncodeFloatProgram=function(){return function(e){this.variableNames=[\"A\"],this.outputShape=e,this.userCode=\"\\n      const float FLOAT_MAX = 1.70141184e38;\\n      const float FLOAT_MIN = 1.17549435e-38;\\n\\n      lowp vec4 encode_float(highp float v) {\\n        if (isNaN(v)) {\\n          return vec4(255, 255, 255, 255);\\n        }\\n\\n        highp float av = abs(v);\\n\\n        if(av < FLOAT_MIN) {\\n          return vec4(0.0, 0.0, 0.0, 0.0);\\n        } else if(v > FLOAT_MAX) {\\n          return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\\n        } else if(v < -FLOAT_MAX) {\\n          return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\\n        }\\n\\n        highp vec4 c = vec4(0,0,0,0);\\n\\n        highp float e = floor(log2(av));\\n        highp float m = exp2(fract(log2(av))) - 1.0;\\n\\n        c[2] = floor(128.0 * m);\\n        m -= c[2] / 128.0;\\n        c[1] = floor(32768.0 * m);\\n        m -= c[1] / 32768.0;\\n        c[0] = floor(8388608.0 * m);\\n\\n        highp float ebias = e + 127.0;\\n        c[3] = floor(ebias / 2.0);\\n        ebias -= c[3] * 2.0;\\n        c[2] += floor(ebias) * 128.0;\\n\\n        c[3] += 128.0 * step(0.0, -v);\\n\\n        return c / 255.0;\\n      }\\n\\n      void main() {\\n        float x = getAAtOutCoords();\\n        gl_FragColor = encode_float(x);\\n      }\\n    \";}}(),COMPLEX_FFT={REAL:\"return real * expR - imag * expI;\",IMAG:\"return real * expI + imag * expR;\"},FFTProgram=function(){return function(e,t,n){this.variableNames=[\"real\",\"imag\"];var r=t[1];this.outputShape=t;var o=n?\"2.0 * \"+Math.PI:\"-2.0 * \"+Math.PI,a=n?r+\".0\":\"1.0\";this.userCode=\"\\n      const float exponentMultiplier = \"+o+\";\\n\\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\\n        \"+e+\"\\n      }\\n\\n      float mulMatDFT(int batch, int index) {\\n        float indexRatio = float(index) / float(\"+r+\");\\n        float exponentMultiplierTimesIndexRatio =\\n            exponentMultiplier * indexRatio;\\n\\n        float result = 0.0;\\n\\n        for (int i = 0; i < \"+r+\"; i++) {\\n          // x = (-2|2 * PI / N) * index * i;\\n          float x = exponentMultiplierTimesIndexRatio * float(i);\\n          float expR = cos(x);\\n          float expI = sin(x);\\n          float real = getReal(batch, i);\\n          float imag = getImag(batch, i);\\n\\n          result +=\\n              unaryOpComplex(real, expR, imag, expI) / \"+a+\";\\n        }\\n\\n        return result;\\n      }\\n\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        setOutput(mulMatDFT(coords[0], coords[1]));\\n      }\\n    \";}}(),FromPixelsProgram=function(){return function(e){this.variableNames=[\"A\"];var t=e[0],n=e[1];this.outputShape=e,this.userCode=\"\\n      void main() {\\n        ivec3 coords = getOutputCoords();\\n        int texR = coords[0];\\n        int texC = coords[1];\\n        int depth = coords[2];\\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(\"+n+\".0, \"+t+\".0);\\n\\n        vec4 values = texture2D(A, uv);\\n        float value;\\n        if (depth == 0) {\\n          value = values.r;\\n        } else if (depth == 1) {\\n          value = values.g;\\n        } else if (depth == 2) {\\n          value = values.b;\\n        } else if (depth == 3) {\\n          value = values.a;\\n        }\\n\\n        setOutput(floor(value * 255.0 + 0.5));\\n      }\\n    \";}}(),GatherProgram=function(){return function(e,t,n){this.variableNames=[\"A\",\"indices\"];var r=e.slice();r[n]=t,this.outputShape=r,this.rank=r.length;var o=getCoordsDataType(this.rank),a=getSourceCoords(e,n);this.userCode=\"\\n      void main() {\\n        \"+o+\" resRC = getOutputCoords();\\n        setOutput(getA(\"+a+\"));\\n      }\\n    \";}}();function getSourceCoords(e,t){var n=e.length;if(n>4)throw Error(\"Gather for rank \"+n+\" is not yet supported\");if(1===n)return \"int(getIndices(resRC))\";for(var r=[\"resRC.x\",\"resRC.y\",\"resRC.z\",\"resRC.w\"],o=[],a=0;a<e.length;a++)a===t?o.push(\"int(getIndices(\"+r[a]+\"))\"):o.push(\"\"+r[a]);return o.join()}var TextureUsage,PhysicalTextureType,GatherNDProgram=function(){return function(e,t,n){this.sliceDim=e,this.strides=t,this.variableNames=[\"x\",\"indices\"],this.outputShape=n;var r=getCoordsDataType(t.length),o=getCoordsDataType(n.length),a=this.sliceDim>1?\"strides[j]\":\"strides\";this.userCode=\"\\n        \"+r+\" strides = \"+r+\"(\"+this.strides+\");\\n         void main() {\\n          \"+o+\" coords = getOutputCoords();\\n          int flattenIndex = 0;\\n          for (int j = 0; j < \"+this.sliceDim+\"; j++) {\\n            int index = round(getIndices(coords[0], j));\\n            flattenIndex += index * \"+a+\";\\n          }\\n          setOutput(getX(flattenIndex, coords[1]));\\n        }\\n      \";}}();function getUnpackedMatrixTextureShapeWidthHeight(e,t){return [t,e]}function getUnpackedArraySizeFromMatrixSize(e,t){return e*t}function getMatrixSizeFromUnpackedArraySize(e,t){if(e%t!=0)throw new Error(\"unpackedSize (\"+e+\") must be a multiple of \"+t);return e/t}function encodeMatrixToUnpackedArray(e,t,n){var r=getUnpackedArraySizeFromMatrixSize(e.length,n);if(t.length<r)throw new Error(\"unpackedArray length (\"+t.length+\") must be >= \"+r);for(var o=0,a=0;a<e.length;++a)t[o]=e[a],o+=n;}function decodeMatrixFromUnpackedArray(e,t,n){var r=getMatrixSizeFromUnpackedArraySize(e.length,n);if(t.length<r)throw new Error(\"matrix length (\"+t.length+\") must be >= \"+r);for(var o=0,a=0;a<e.length;a+=n)t[o++]=e[a];}function getPackedMatrixTextureShapeWidthHeight(e,t){return [Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function getPackedRGBAArraySizeFromMatrixShape(e,t){var n=getPackedMatrixTextureShapeWidthHeight(e,t);return n[0]*n[1]*4}function encodeMatrixToPackedRGBA(e,t,n,r,o){var a=getPackedRGBAArraySizeFromMatrixShape(n,r);if(o.length<a)throw new Error(\"packedRGBA length (\"+o.length+\") must be >=\\n        \"+a);for(var i=r%2==1,s=n%2==1,u=Math.floor(r/2),l=Math.floor(n/2),c=Math.ceil(r/2),p=c*Math.ceil(n/2),d=nearestLargerEven(n)*nearestLargerEven(r),h=0;h<t;h++){for(var f=h*n*r,m=h*d,g=i?4:0,v=r,y=m,x=0;x<l;++x){for(var T=2*x*r,w=0;w<u;++w){var E=f+T+2*w;o[y]=e[E],o[y+1]=e[E+1],o[y+2]=e[E+v],o[y+3]=e[E+v+1],y+=4;}y+=g;}if(i){E=f+r-1,y=m+4*(c-1);var S=2*r;for(g=4*c,x=0;x<l;++x)o[y]=e[E],o[y+2]=e[E+r],E+=S,y+=g;}if(s){for(E=f+(n-1)*r,y=m+4*(p-c),w=0;w<u;++w)o[y++]=e[E++],o[y++]=e[E++],y+=2;i&&s&&(o[m+d-4]=e[E]);}}return o}function decodeMatrixFromPackedRGBA(e,t,n,r,o){var a=n*r;if(o.length<a)throw new Error(\"matrix length (\"+o.length+\") must be >= \"+a);for(var i=r%2==1,s=n%2==1,u=Math.floor(r/2),l=Math.floor(n/2),c=Math.ceil(r/2),p=c*Math.ceil(n/2),d=nearestLargerEven(n)*nearestLargerEven(r),h=0;h<t;h++){for(var f=h*n*r,m=h*d,g=i?4:0,v=r+(i?1:0),y=m,x=f,T=f+r,w=0;w<l;++w){for(var E=0;E<u;++E)o[x++]=e[y++],o[x++]=e[y++],o[T++]=e[y++],o[T++]=e[y++];y+=g,x+=v,T+=v;}if(i){y=m+4*(c-1);var S=f+r-1;for(g=4*c,v=2*r,w=0;w<l;++w)o[S]=e[y],o[S+r]=e[y+2],y+=g,S+=v;}if(s){for(y=m+4*(p-c),S=f+(n-1)*r,E=0;E<u;++E)o[S++]=e[y++],o[S++]=e[y++],y+=2;i&&(o[f+n*r-1]=e[y]);}}return o}function callAndCheck(e,t){var n=t();return checkWebGLError(e),n}!function(e){e[e.RENDER=0]=\"RENDER\",e[e.UPLOAD=1]=\"UPLOAD\",e[e.PIXELS=2]=\"PIXELS\",e[e.DOWNLOAD=3]=\"DOWNLOAD\";}(TextureUsage||(TextureUsage={})),function(e){e[e.UNPACKED_FLOAT16=0]=\"UNPACKED_FLOAT16\",e[e.UNPACKED_FLOAT32=1]=\"UNPACKED_FLOAT32\",e[e.PACKED_4X1_UNSIGNED_BYTE=2]=\"PACKED_4X1_UNSIGNED_BYTE\",e[e.PACKED_2X2_FLOAT32=3]=\"PACKED_2X2_FLOAT32\",e[e.PACKED_2X2_FLOAT16=4]=\"PACKED_2X2_FLOAT16\";}(PhysicalTextureType||(PhysicalTextureType={}));var webGLDebugErrorCheckingEnabled=!1;function enableDebugWebGLErrorChecking(e){webGLDebugErrorCheckingEnabled=e;}function checkWebGLError(e){if(webGLDebugErrorCheckingEnabled){var t=e.getError();if(t!==e.NO_ERROR)throw new Error(\"WebGL Error: \"+getWebGLErrorMessage(e,t))}}function getWebGLErrorMessage(e,t){switch(t){case e.NO_ERROR:return \"NO_ERROR\";case e.INVALID_ENUM:return \"INVALID_ENUM\";case e.INVALID_VALUE:return \"INVALID_VALUE\";case e.INVALID_OPERATION:return \"INVALID_OPERATION\";case e.INVALID_FRAMEBUFFER_OPERATION:return \"INVALID_FRAMEBUFFER_OPERATION\";case e.OUT_OF_MEMORY:return \"OUT_OF_MEMORY\";case e.CONTEXT_LOST_WEBGL:return \"CONTEXT_LOST_WEBGL\";default:return \"Unknown error code \"+t}}function getExtensionOrThrow(e,t){return throwIfNull(e,function(){return e.getExtension(t)},'Extension \"'+t+'\" not supported on this browser.')}function createVertexShader(e,t){var n=throwIfNull(e,function(){return e.createShader(e.VERTEX_SHADER)},\"Unable to create vertex WebGLShader.\");if(callAndCheck(e,function(){return e.shaderSource(n,t)}),callAndCheck(e,function(){return e.compileShader(n)}),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error(\"Failed to compile vertex shader.\");return n}function createFragmentShader(e,t){var n=throwIfNull(e,function(){return e.createShader(e.FRAGMENT_SHADER)},\"Unable to create fragment WebGLShader.\");if(callAndCheck(e,function(){return e.shaderSource(n,t)}),callAndCheck(e,function(){return e.compileShader(n)}),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw logShaderSourceAndInfoLog(t,e.getShaderInfoLog(n)),new Error(\"Failed to compile fragment shader.\");return n}var lineNumberRegex=/ERROR: [0-9]+:([0-9]+):/g;function logShaderSourceAndInfoLog(e,t){var n=lineNumberRegex.exec(t);if(null==n)return console.log(\"Couldn't parse line number in error: \"+t),void console.log(e);for(var r=+n[1],o=e.split(\"\\n\"),a=o.length.toString().length+2,i=o.map(function(e,t){return rightPad((t+1).toString(),a)+e}),s=0,u=0;u<i.length;u++)s=Math.max(i[u].length,s);var l=i.slice(0,r-1),c=i.slice(r-1,r),p=i.slice(r);console.log(l.join(\"\\n\")),console.log(t.split(\"\\n\")[0]),console.log(\"%c \"+rightPad(c[0],s),\"border:1px solid red; background-color:#e3d2d2; color:#a61717\"),console.log(p.join(\"\\n\"));}function createProgram(e){return throwIfNull(e,function(){return e.createProgram()},\"Unable to create WebGLProgram.\")}function linkProgram(e,t){if(callAndCheck(e,function(){return e.linkProgram(t)}),!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error(\"Failed to link vertex and fragment shaders.\")}function validateProgram(e,t){if(callAndCheck(e,function(){return e.validateProgram(t)}),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error(\"Shader program validation failed.\")}function createStaticVertexBuffer(e,t){var n=throwIfNull(e,function(){return e.createBuffer()},\"Unable to create WebGLBuffer\");return callAndCheck(e,function(){return e.bindBuffer(e.ARRAY_BUFFER,n)}),callAndCheck(e,function(){return e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)}),n}function createStaticIndexBuffer(e,t){var n=throwIfNull(e,function(){return e.createBuffer()},\"Unable to create WebGLBuffer\");return callAndCheck(e,function(){return e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n)}),callAndCheck(e,function(){return e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)}),n}function getNumChannels(){return 2===ENV.get(\"WEBGL_VERSION\")?1:4}function createTexture(e){return throwIfNull(e,function(){return e.createTexture()},\"Unable to create WebGLTexture.\")}function validateTextureSize(e,t){var n=ENV.get(\"WEBGL_MAX_TEXTURE_SIZE\");if(e<=0||t<=0){var r=\"[\"+e+\"x\"+t+\"]\";throw new Error(\"Requested texture size \"+r+\" is invalid.\")}if(e>n||t>n){r=\"[\"+e+\"x\"+t+\"]\";throw new Error(\"Requested texture size \"+r+\" greater than WebGL maximum on this browser / GPU \"+(\"[\"+n+\"x\"+n+\"]\")+\".\")}}function createFramebuffer(e){return throwIfNull(e,function(){return e.createFramebuffer()},\"Unable to create WebGLFramebuffer.\")}function bindVertexBufferToProgramAttribute(e,t,n,r,o,a,i){var s=e.getAttribLocation(t,n);return -1!==s&&(callAndCheck(e,function(){return e.bindBuffer(e.ARRAY_BUFFER,r)}),callAndCheck(e,function(){return e.vertexAttribPointer(s,o,e.FLOAT,!1,a,i)}),callAndCheck(e,function(){return e.enableVertexAttribArray(s)}),!0)}function bindTextureUnit(e,t,n){validateTextureUnit(e,n),callAndCheck(e,function(){return e.activeTexture(e.TEXTURE0+n)}),callAndCheck(e,function(){return e.bindTexture(e.TEXTURE_2D,t)});}function unbindTextureUnit(e,t){validateTextureUnit(e,t),callAndCheck(e,function(){return e.activeTexture(e.TEXTURE0+t)}),callAndCheck(e,function(){return e.bindTexture(e.TEXTURE_2D,null)});}function getProgramUniformLocationOrThrow(e,t,n){return throwIfNull(e,function(){return e.getUniformLocation(t,n)},'uniform \"'+n+'\" not present in program.')}function getProgramUniformLocation(e,t,n){return e.getUniformLocation(t,n)}function bindTextureToProgramUniformSampler(e,t,n,r,o){callAndCheck(e,function(){return bindTextureUnit(e,n,o)}),callAndCheck(e,function(){return e.uniform1i(r,o)});}function bindCanvasToFramebuffer(e){callAndCheck(e,function(){return e.bindFramebuffer(e.FRAMEBUFFER,null)}),callAndCheck(e,function(){return e.viewport(0,0,e.canvas.width,e.canvas.height)}),callAndCheck(e,function(){return e.scissor(0,0,e.canvas.width,e.canvas.height)});}function bindColorTextureToFramebuffer(e,t,n){callAndCheck(e,function(){return e.bindFramebuffer(e.FRAMEBUFFER,n)}),callAndCheck(e,function(){return e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)});}function unbindColorTextureFromFramebuffer(e,t){callAndCheck(e,function(){return e.bindFramebuffer(e.FRAMEBUFFER,t)}),callAndCheck(e,function(){return e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)});}function validateFramebuffer(e){var t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error(\"Error binding framebuffer: \"+getFramebufferErrorMessage(e,t))}function getFramebufferErrorMessage(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return \"FRAMEBUFFER_INCOMPLETE_ATTACHMENT\";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return \"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT\";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return \"FRAMEBUFFER_INCOMPLETE_DIMENSIONS\";case e.FRAMEBUFFER_UNSUPPORTED:return \"FRAMEBUFFER_UNSUPPORTED\";default:return \"unknown error \"+t}}function throwIfNull(e,t,n){var r=callAndCheck(e,function(){return t()});if(null==r)throw new Error(n);return r}function validateTextureUnit(e,t){var n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n)throw new Error(\"textureUnit must be in \"+(\"[gl.TEXTURE0, gl.TEXTURE\"+n+\"]\")+\".\")}function getTextureShapeFromLogicalShape(e,t){void 0===t&&(t=!1);var n=ENV.get(\"WEBGL_MAX_TEXTURE_SIZE\");if(t&&(n*=2,e=e.map(function(t,n){return n>=e.length-2?nearestLargerEven(e[n]):e[n]})),2!==e.length){var r=squeezeShape(e);e=r.newShape;}var o=sizeFromShape(e);return e.length<=1&&o<=n?[1,o]:2===e.length&&e[0]<=n&&e[1]<=n?e:3===e.length&&e[0]*e[1]<=n&&e[2]<=n?[e[0]*e[1],e[2]]:3===e.length&&e[0]<=n&&e[1]*e[2]<=n?[e[0],e[1]*e[2]]:4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n?[e[0]*e[1]*e[2],e[3]]:4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n?[e[0],e[1]*e[2]*e[3]]:sizeToSquarishShape(o)}function isEven(e){return e%2==0}function isReshapeFree(e,t){if(arraysEqual(e=e.slice(-2),t=t.slice(-2)))return !0;if(!e.length||!t.length)return !0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return !0;if(e.length!==t.length){var n=e.slice(-1)[0],r=t.slice(-1)[0];if(n===r)return !0;if(isEven(n)&&isEven(r)&&(1===e[0]||1===t[0]))return !0}else if(isEven(e[0])&&isEven(t[0])){if(isEven(e[1])&&isEven(t[1]))return !0;if(e[1]===t[1])return !0}return !1}var webgl_util=Object.freeze({callAndCheck:callAndCheck,enableDebugWebGLErrorChecking:enableDebugWebGLErrorChecking,checkWebGLError:checkWebGLError,getWebGLErrorMessage:getWebGLErrorMessage,getExtensionOrThrow:getExtensionOrThrow,createVertexShader:createVertexShader,createFragmentShader:createFragmentShader,createProgram:createProgram,linkProgram:linkProgram,validateProgram:validateProgram,createStaticVertexBuffer:createStaticVertexBuffer,createStaticIndexBuffer:createStaticIndexBuffer,getNumChannels:getNumChannels,createTexture:createTexture,validateTextureSize:validateTextureSize,createFramebuffer:createFramebuffer,bindVertexBufferToProgramAttribute:bindVertexBufferToProgramAttribute,bindTextureUnit:bindTextureUnit,unbindTextureUnit:unbindTextureUnit,getProgramUniformLocationOrThrow:getProgramUniformLocationOrThrow,getProgramUniformLocation:getProgramUniformLocation,bindTextureToProgramUniformSampler:bindTextureToProgramUniformSampler,bindCanvasToFramebuffer:bindCanvasToFramebuffer,bindColorTextureToFramebuffer:bindColorTextureToFramebuffer,unbindColorTextureFromFramebuffer:unbindColorTextureFromFramebuffer,validateFramebuffer:validateFramebuffer,getFramebufferErrorMessage:getFramebufferErrorMessage,getTextureShapeFromLogicalShape:getTextureShapeFromLogicalShape,isReshapeFree:isReshapeFree});function createVertexShader$1(e){return createVertexShader(e,\"\\n    precision highp float;\\n    attribute vec3 clipSpacePos;\\n    attribute vec2 uv;\\n    varying vec2 resultUV;\\n\\n    void main() {\\n      gl_Position = vec4(clipSpacePos, 1);\\n      resultUV = uv;\\n    }\")}function createVertexBuffer(e){return createStaticVertexBuffer(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function createIndexBuffer(e){return createStaticIndexBuffer(e,new Uint16Array([0,1,2,2,1,3]))}function getTextureConfig(e,t){var n,r,o,a,i,s,u,l=e;return 2===ENV.get(\"WEBGL_VERSION\")?(n=l.R32F,r=l.R16F,o=l.RGBA32F,a=l.RED,i=4,s=1,u=l.HALF_FLOAT):(n=e.RGBA,r=e.RGBA,o=l.RGBA,a=e.RGBA,i=4,s=4,u=null!=t?t.HALF_FLOAT_OES:null),{internalFormatFloat:n,internalFormatHalfFloat:r,internalFormatPackedFloat:o,textureFormatFloat:a,downloadTextureFormat:e.RGBA,downloadUnpackNumChannels:i,defaultNumChannels:s,textureTypeHalfFloat:u}}function createAndConfigureTexture(e,t,n,r,o,a){validateTextureSize(t,n);var i=createTexture(e),s=e.TEXTURE_2D;return callAndCheck(e,function(){return e.bindTexture(s,i)}),callAndCheck(e,function(){return e.texParameteri(s,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)}),callAndCheck(e,function(){return e.texParameteri(s,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)}),callAndCheck(e,function(){return e.texParameteri(s,e.TEXTURE_MIN_FILTER,e.NEAREST)}),callAndCheck(e,function(){return e.texParameteri(s,e.TEXTURE_MAG_FILTER,e.NEAREST)}),callAndCheck(e,function(){return e.texImage2D(s,0,r,t,n,0,o,a,null)}),callAndCheck(e,function(){return e.bindTexture(e.TEXTURE_2D,null)}),i}function createFloat32MatrixTexture(e,t,n,r){var o=getUnpackedMatrixTextureShapeWidthHeight(t,n);return createAndConfigureTexture(e,o[0],o[1],r.internalFormatFloat,r.textureFormatFloat,e.FLOAT)}function createFloat16MatrixTexture(e,t,n,r){var o=getUnpackedMatrixTextureShapeWidthHeight(t,n);return createAndConfigureTexture(e,o[0],o[1],r.internalFormatFloat,r.textureFormatFloat,r.textureTypeHalfFloat)}function createUnsignedBytesMatrixTexture(e,t,n,r){var o=getUnpackedMatrixTextureShapeWidthHeight(t,n);return createAndConfigureTexture(e,o[0],o[1],e.RGBA,e.RGBA,e.UNSIGNED_BYTE)}function createPackedMatrixTexture(e,t,n,r){var o=getPackedMatrixTextureShapeWidthHeight(t,n);return createAndConfigureTexture(e,o[0],o[1],r.internalFormatPackedFloat,e.RGBA,e.FLOAT)}function createFloat16PackedMatrixTexture(e,t,n,r){var o=getPackedMatrixTextureShapeWidthHeight(t,n);return createAndConfigureTexture(e,o[0],o[1],r.internalFormatHalfFloat,e.RGBA,r.textureTypeHalfFloat)}function bindVertexProgramAttributeStreams(e,t,n){return callAndCheck(e,function(){return e.bindBuffer(e.ARRAY_BUFFER,n)}),bindVertexBufferToProgramAttribute(e,t,\"clipSpacePos\",n,3,20,0)&&bindVertexBufferToProgramAttribute(e,t,\"uv\",n,2,20,12)}function uploadPixelDataToTexture(e,t,n){callAndCheck(e,function(){return e.bindTexture(e.TEXTURE_2D,t)}),callAndCheck(e,function(){return e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n)}),callAndCheck(e,function(){return e.bindTexture(e.TEXTURE_2D,null)});}function uploadDataToTexture(e,t,n,r,o,a){validateTextureSize(n,r),callAndCheck(e,function(){return e.bindTexture(e.TEXTURE_2D,t)}),callAndCheck(e,function(){return e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,a,e.FLOAT,o)}),callAndCheck(e,function(){return e.bindTexture(e.TEXTURE_2D,null)});}function uploadMatrixToTexture(e,t,n,r,o,a,i){var s,u=getUnpackedMatrixTextureShapeWidthHeight(n,r),l=u[0],c=u[1];1===i.defaultNumChannels?s=o:encodeMatrixToUnpackedArray(o,s=new Float32Array(getUnpackedArraySizeFromMatrixSize(o.length,a)),a),uploadDataToTexture(e,t,l,c,s,i.textureFormatFloat);}function uploadMatrixToPackedTexture(e,t,n,r,o,a,i,s,u){var l=getPackedMatrixTextureShapeWidthHeight(a,i),c=l[0],p=l[1],d=new Float32Array(n*getPackedRGBAArraySizeFromMatrixShape(r,o));encodeMatrixToPackedRGBA(s,n,r,o,d),uploadDataToTexture(e,t,c,p,d,e.RGBA);}function maybeCreateBufferFromOutputTexture(e,t,n,r,o){var a=t;if(2===ENV.get(\"WEBGL_VERSION\")){var i=e,s=i.createBuffer();callAndCheck(e,function(){return e.bindBuffer(i.PIXEL_PACK_BUFFER,s)});var u=4*getUnpackedArraySizeFromMatrixSize(n*r,o.downloadUnpackNumChannels);callAndCheck(e,function(){return e.bufferData(i.PIXEL_PACK_BUFFER,u,e.STATIC_DRAW)}),callAndCheck(e,function(){return i.readPixels(0,0,r,n,e.RGBA,e.FLOAT,0)}),callAndCheck(e,function(){return e.bindBuffer(i.PIXEL_PACK_BUFFER,null)}),a=s;}return a}function downloadFloat32MatrixFromBuffer(e,t,n,r,o){var a=e,i=new Float32Array(getUnpackedArraySizeFromMatrixSize(n*r,o.downloadUnpackNumChannels));a.bindBuffer(e.ARRAY_BUFFER,t),a.getBufferSubData(e.ARRAY_BUFFER,0,i),a.bindBuffer(e.ARRAY_BUFFER,null);var s=new Float32Array(n*r);return decodeMatrixFromUnpackedArray(i,s,o.downloadUnpackNumChannels),s}function downloadFloat32MatrixFromOutputTexture(e,t,n,r){var o=getUnpackedMatrixTextureShapeWidthHeight(t,n),a=o[0],i=o[1],s=new Float32Array(getUnpackedArraySizeFromMatrixSize(t*n,r.downloadUnpackNumChannels));callAndCheck(e,function(){return e.readPixels(0,0,a,i,r.downloadTextureFormat,e.FLOAT,s)});var u=new Float32Array(t*n);return decodeMatrixFromUnpackedArray(s,u,r.downloadUnpackNumChannels),u}function downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n,r){var o=getUnpackedMatrixTextureShapeWidthHeight(t,n),a=o[0],i=o[1],s=new Uint8Array(getUnpackedArraySizeFromMatrixSize(t*n,4));return callAndCheck(e,function(){return e.readPixels(0,0,a,i,r.downloadTextureFormat,e.UNSIGNED_BYTE,s)}),new Float32Array(s.buffer)}function downloadPackedMatrixFromBuffer(e,t,n,r,o,a,i,s){var u=e,l=new Float32Array(getPackedRGBAArraySizeFromMatrixShape(a,i));u.bindBuffer(e.ARRAY_BUFFER,t),u.getBufferSubData(e.ARRAY_BUFFER,0,l),u.bindBuffer(e.ARRAY_BUFFER,null);var c=new Float32Array(sizeFromShape([n,r,o]));return decodeMatrixFromPackedRGBA(l,n,r,o,c),c}function downloadMatrixFromPackedOutputTexture(e,t,n,r,o,a,i){var s=getPackedMatrixTextureShapeWidthHeight(o,a),u=s[0],l=s[1],c=new Float32Array(getPackedRGBAArraySizeFromMatrixShape(o,a));callAndCheck(e,function(){return e.readPixels(0,0,u,l,e.RGBA,e.FLOAT,c)});var p=new Float32Array(sizeFromShape([t,n,r]));return decodeMatrixFromPackedRGBA(c,t,n,r,p)}var gpgpu_util=Object.freeze({createVertexShader:createVertexShader$1,createVertexBuffer:createVertexBuffer,createIndexBuffer:createIndexBuffer,getTextureConfig:getTextureConfig,createFloat32MatrixTexture:createFloat32MatrixTexture,createFloat16MatrixTexture:createFloat16MatrixTexture,createUnsignedBytesMatrixTexture:createUnsignedBytesMatrixTexture,createPackedMatrixTexture:createPackedMatrixTexture,createFloat16PackedMatrixTexture:createFloat16PackedMatrixTexture,bindVertexProgramAttributeStreams:bindVertexProgramAttributeStreams,uploadPixelDataToTexture:uploadPixelDataToTexture,uploadMatrixToTexture:uploadMatrixToTexture,uploadMatrixToPackedTexture:uploadMatrixToPackedTexture,maybeCreateBufferFromOutputTexture:maybeCreateBufferFromOutputTexture,downloadFloat32MatrixFromBuffer:downloadFloat32MatrixFromBuffer,downloadFloat32MatrixFromOutputTexture:downloadFloat32MatrixFromOutputTexture,downloadByteEncodedFloatMatrixFromOutputTexture:downloadByteEncodedFloatMatrixFromOutputTexture,downloadPackedMatrixFromBuffer:downloadPackedMatrixFromBuffer,downloadMatrixFromPackedOutputTexture:downloadMatrixFromPackedOutputTexture}),GPGPUContext=function(){function e(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.autoDebugValidate=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[],this.gl=null!=e?e:getWebGLContext(ENV.get(\"WEBGL_VERSION\")),1===ENV.get(\"WEBGL_VERSION\")?(this.textureFloatExtension=getExtensionOrThrow(this.gl,\"OES_texture_float\"),this.colorBufferFloatExtension=this.gl.getExtension(\"WEBGL_color_buffer_float\"),ENV.get(\"WEBGL_RENDER_FLOAT32_ENABLED\")||(this.textureHalfFloatExtension=getExtensionOrThrow(this.gl,\"OES_texture_half_float\"),this.colorBufferHalfFloatExtension=this.gl.getExtension(\"EXT_color_buffer_half_float\"))):this.colorBufferFloatExtension=getExtensionOrThrow(this.gl,\"EXT_color_buffer_float\"),this.vertexBuffer=createVertexBuffer(this.gl),this.indexBuffer=createIndexBuffer(this.gl),this.framebuffer=createFramebuffer(this.gl),this.textureConfig=getTextureConfig(this.gl,this.textureHalfFloatExtension);}return e.prototype.dispose=function(){var e=this;if(!this.disposed){null!=this.program&&console.warn(\"Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing.\"),null!=this.outputTexture&&console.warn(\"Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.\");var t=this.gl;callAndCheck(t,function(){return t.finish()}),callAndCheck(t,function(){return t.bindFramebuffer(t.FRAMEBUFFER,null)}),callAndCheck(t,function(){return t.deleteFramebuffer(e.framebuffer)}),callAndCheck(t,function(){return t.bindBuffer(t.ARRAY_BUFFER,null)}),callAndCheck(t,function(){return t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)}),callAndCheck(t,function(){return t.deleteBuffer(e.indexBuffer)}),this.disposed=!0;}},e.prototype.enableAutomaticDebugValidation=function(e){this.autoDebugValidate=e,enableDebugWebGLErrorChecking(e);},e.prototype.createFloat32MatrixTexture=function(e,t){return this.throwIfDisposed(),createFloat32MatrixTexture(this.gl,e,t,this.textureConfig)},e.prototype.createFloat16MatrixTexture=function(e,t){return this.throwIfDisposed(),createFloat16MatrixTexture(this.gl,e,t,this.textureConfig)},e.prototype.createUnsignedBytesMatrixTexture=function(e,t){return this.throwIfDisposed(),createUnsignedBytesMatrixTexture(this.gl,e,t,this.textureConfig)},e.prototype.uploadPixelDataToTexture=function(e,t){this.throwIfDisposed(),uploadPixelDataToTexture(this.gl,e,t);},e.prototype.createFloat16PackedMatrixTexture=function(e,t){return this.throwIfDisposed(),createFloat16PackedMatrixTexture(this.gl,e,t,this.textureConfig)},e.prototype.createPackedMatrixTexture=function(e,t){return this.throwIfDisposed(),createPackedMatrixTexture(this.gl,e,t,this.textureConfig)},e.prototype.deleteMatrixTexture=function(e){var t=this;this.throwIfDisposed(),this.outputTexture===e&&(unbindColorTextureFromFramebuffer(this.gl,this.framebuffer),this.outputTexture=null),callAndCheck(this.gl,function(){return t.gl.deleteTexture(e)});},e.prototype.uploadMatrixToTexture=function(e,t,n,r){this.throwIfDisposed();var o=getNumChannels();return uploadMatrixToTexture(this.gl,e,t,n,r,o,this.textureConfig)},e.prototype.uploadMatrixToPackedTexture=function(e,t,n,r,o,a,i){return this.throwIfDisposed(),uploadMatrixToPackedTexture(this.gl,e,t,n,r,o,a,i,this.textureConfig)},e.prototype.downloadFloat32MatrixFromOutputTexture=function(e,t,n){var r=this;return this.downloadMatrixDriver(e,function(){return downloadFloat32MatrixFromOutputTexture(r.gl,t,n,r.textureConfig)})},e.prototype.downloadByteEncodedFloatMatrixFromOutputTexture=function(e,t,n){var r=this;return this.downloadMatrixDriver(e,function(){return downloadByteEncodedFloatMatrixFromOutputTexture(r.gl,t,n,r.textureConfig)})},e.prototype.downloadPackedMatrixFromBuffer=function(e,t,n,r,o,a){return downloadPackedMatrixFromBuffer(this.gl,e,t,n,r,o,a,this.textureConfig)},e.prototype.downloadFloat32MatrixFromBuffer=function(e,t,n){return downloadFloat32MatrixFromBuffer(this.gl,e,t,n,this.textureConfig)},e.prototype.maybeCreateBufferFromTexture=function(e,t,n){this.bindTextureToFrameBuffer(e);var r=maybeCreateBufferFromOutputTexture(this.gl,e,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r},e.prototype.createAndWaitForFence=function(){var e=this.createFence(this.gl);return this.pollFence(e)},e.prototype.createFence=function(e){var t,n,r=this;if(ENV.get(\"WEBGL_FENCE_API_ENABLED\")){var o=e,a=o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=function(){var e=o.clientWaitSync(a,0,0);return e===o.ALREADY_SIGNALED||e===o.CONDITION_SATISFIED},t=a;}else ENV.get(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\")>0?(t=this.beginQuery(),this.endQuery(),n=function(){return r.isQueryAvailable(t,ENV.get(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\"))}):n=function(){return !0};return {query:t,isFencePassed:n}},e.prototype.downloadMatrixFromPackedTexture=function(e,t,n,r,o,a){var i=this;return this.downloadMatrixDriver(e,function(){return downloadMatrixFromPackedOutputTexture(i.gl,t,n,r,o,a,i.textureConfig)})},e.prototype.createProgram=function(e){this.throwIfDisposed();var t=this.gl,n=createFragmentShader(t,e),r=createVertexShader$1(t),o=createProgram(t);return callAndCheck(t,function(){return t.attachShader(o,r)}),callAndCheck(t,function(){return t.attachShader(o,n)}),linkProgram(t,o),this.autoDebugValidate&&validateProgram(t,o),this.vertexAttrsAreBound||(this.setProgram(o),this.vertexAttrsAreBound=bindVertexProgramAttributeStreams(t,this.program,this.vertexBuffer)),o},e.prototype.deleteProgram=function(e){var t=this;this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&callAndCheck(this.gl,function(){return t.gl.deleteProgram(e)});},e.prototype.setProgram=function(e){var t=this;this.throwIfDisposed(),this.program=e,null!=this.program&&this.autoDebugValidate&&validateProgram(this.gl,this.program),callAndCheck(this.gl,function(){return t.gl.useProgram(e)});},e.prototype.getUniformLocation=function(e,t,n){return void 0===n&&(n=!0),this.throwIfDisposed(),n?getProgramUniformLocationOrThrow(this.gl,e,t):getProgramUniformLocation(this.gl,e,t)},e.prototype.getAttributeLocation=function(e,t){var n=this;return this.throwIfDisposed(),callAndCheck(this.gl,function(){return n.gl.getAttribLocation(e,t)})},e.prototype.getUniformLocationNoThrow=function(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)},e.prototype.setInputMatrixTexture=function(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),bindTextureToProgramUniformSampler(this.gl,this.program,e,t,n);},e.prototype.setOutputMatrixTexture=function(e,t,n){this.setOutputMatrixTextureDriver(e,n,t);},e.prototype.setOutputPackedMatrixTexture=function(e,t,n){this.throwIfDisposed();var r=getPackedMatrixTextureShapeWidthHeight(t,n),o=r[0],a=r[1];this.setOutputMatrixTextureDriver(e,o,a);},e.prototype.setOutputMatrixWriteRegion=function(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t);},e.prototype.setOutputPackedMatrixWriteRegion=function(e,t,n,r){throw new Error(\"setOutputPackedMatrixWriteRegion not implemented.\")},e.prototype.debugValidate=function(){null!=this.program&&validateProgram(this.gl,this.program),validateFramebuffer(this.gl);},e.prototype.executeProgram=function(){this.throwIfDisposed(),this.throwIfNoProgram();var e=this.gl;this.autoDebugValidate&&this.debugValidate(),callAndCheck(e,function(){return e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)});},e.prototype.blockUntilAllProgramsCompleted=function(){var e=this;this.throwIfDisposed(),callAndCheck(this.gl,function(){return e.gl.finish()});},e.prototype.getQueryTimerExtension=function(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=getExtensionOrThrow(this.gl,2===ENV.get(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\")?\"EXT_disjoint_timer_query_webgl2\":\"EXT_disjoint_timer_query\")),this.disjointQueryTimerExtension},e.prototype.getQueryTimerExtensionWebGL2=function(){return this.getQueryTimerExtension()},e.prototype.getQueryTimerExtensionWebGL1=function(){return this.getQueryTimerExtension()},e.prototype.beginQuery=function(){if(2===ENV.get(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\")){var e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}var r=this.getQueryTimerExtensionWebGL1(),o=r.createQueryEXT();return r.beginQueryEXT(r.TIME_ELAPSED_EXT,o),o},e.prototype.endQuery=function(){if(2!==ENV.get(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\")){var e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT);}else{var t=this.gl,n=this.getQueryTimerExtensionWebGL2();t.endQuery(n.TIME_ELAPSED_EXT);}},e.prototype.waitForQueryAndGetTime=function(e){return __awaiter(this,void 0,void 0,function(){var t=this;return __generator(this,function(n){switch(n.label){case 0:return [4,repeatedTry(function(){return t.disposed||t.isQueryAvailable(e,ENV.get(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\"))})];case 1:return n.sent(),[2,this.getQueryTime(e,ENV.get(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\"))]}})})},e.prototype.getQueryTime=function(e,t){if(0===t)return null;if(2===t){var n=this.gl;return n.getQueryParameter(e,n.QUERY_RESULT)/1e6}var r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(e,r.QUERY_RESULT_EXT)/1e6},e.prototype.isQueryAvailable=function(e,t){if(0===t)return !0;if(2===t){var n=this.gl,r=this.getQueryTimerExtensionWebGL2(),o=n.getQueryParameter(e,n.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),o&&!this.disjoint}o=(r=this.getQueryTimerExtensionWebGL1()).getQueryObjectEXT(e,r.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),o&&!this.disjoint},e.prototype.pollFence=function(e){var t=this;return new Promise(function(n){t.addItemToPoll(function(){return e.isFencePassed()},function(){return n()});})},e.prototype.pollItems=function(){for(var e=binSearchLastTrue(this.itemsToPoll.map(function(e){return e.isDoneFn})),t=0;t<=e;++t){(0, this.itemsToPoll[t].resolveFn)();}this.itemsToPoll=this.itemsToPoll.slice(e+1);},e.prototype.addItemToPoll=function(e,t){var n=this;this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1||repeatedTry(function(){return n.pollItems(),0===n.itemsToPoll.length});},e.prototype.bindTextureToFrameBuffer=function(e){this.throwIfDisposed(),bindColorTextureToFramebuffer(this.gl,e,this.framebuffer),this.autoDebugValidate&&validateFramebuffer(this.gl);},e.prototype.unbindTextureToFrameBuffer=function(){null!=this.outputTexture?(bindColorTextureToFramebuffer(this.gl,this.outputTexture,this.framebuffer),this.autoDebugValidate&&validateFramebuffer(this.gl)):unbindColorTextureFromFramebuffer(this.gl,this.framebuffer);},e.prototype.downloadMatrixDriver=function(e,t){this.bindTextureToFrameBuffer(e);var n=t();return this.unbindTextureToFrameBuffer(),n},e.prototype.setOutputMatrixTextureDriver=function(e,t,n){this.throwIfDisposed();var r=this.gl;bindColorTextureToFramebuffer(r,e,this.framebuffer),this.autoDebugValidate&&validateFramebuffer(r),this.outputTexture=e,callAndCheck(r,function(){return r.viewport(0,0,t,n)}),callAndCheck(r,function(){return r.scissor(0,0,t,n)});},e.prototype.setOutputMatrixWriteRegionDriver=function(e,t,n,r){var o=this;this.throwIfDisposed(),callAndCheck(this.gl,function(){return o.gl.scissor(e,t,n,r)});},e.prototype.throwIfDisposed=function(){if(this.disposed)throw new Error(\"Attempted to use disposed GPGPUContext.\")},e.prototype.throwIfNoProgram=function(){if(null==this.program)throw new Error(\"No GPU program is currently set.\")},e}();function binSearchLastTrue(e){for(var t=0,n=e.length-1,r=-1;t<=n;){var o=t+n>>1;e[o]()?(r=o,t=o+1):n=o-1;}return r}function compileProgram(e,t,n,r){for(var o=t.userCode,a=n.map(function(e,n){var r={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked};return {name:t.variableNames[n],shapeInfo:r}}),i=a.map(function(e){return e.shapeInfo}),s={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked},u=makeShader(a,s,o,!0===t.supportsBroadcasting,t.usesPackedTextures),l=e.createProgram(u),c={},p=0;p<t.variableNames.length;p++){var d=t.variableNames[p];c[d]=e.getUniformLocation(l,d,!1);}return {program:t,source:u,webGLProgram:l,uniformLocations:c,gpgpu:e,inShapeInfos:i,outShapeInfo:s}}function validateBinaryAndProgram(e,t){if(e.length!==t.length)throw Error(\"Binary was compiled with \"+e.length+\" inputs, but was executed with \"+t.length+\" inputs\");e.forEach(function(e,n){var r=e.logicalShape,o=t[n],a=o.shape;if(!arraysEqual(r,a))throw Error(\"Binary was compiled with different shapes than the current args. Shapes \"+r+\" and \"+a+\" must match\");if(!e.isUniform||!o.isUniform){var i=e.texShape,s=o.isUniform?null:o.texData.texShape;if(!arraysEqual(i,s))throw Error(\"Binary was compiled with different texture shapes than the current args. Shape \"+i+\" and \"+s+\" must match\")}});}function runProgram(e,t,n,r){validateBinaryAndProgram(e.inShapeInfos,t),validateBinaryAndProgram([e.outShapeInfo],[n]);var o=n.texData.texture,a=n.texData.texShape,i=e.gpgpu;n.texData.isPacked?i.setOutputPackedMatrixTexture(o,a[0],a[1]):i.setOutputMatrixTexture(o,a[0],a[1]),i.setProgram(e.webGLProgram),t.forEach(function(t,n){var r=e.program.variableNames[n],o=e.uniformLocations[r];if(null!=o){if(t.isUniform){if(1===sizeFromShape(t.shape))i.gl.uniform1f(o,t.uniformValues[0]);else{var a=t.uniformValues;a instanceof Float32Array||(a=new Float32Array(a)),i.gl.uniform1fv(o,a);}return}var s=t.texData.texture;i.setInputMatrixTexture(s,o,n);}}),null!=r&&r(i,e.webGLProgram),i.executeProgram();}function makeShaderKey(e,t,n){var r=\"\";t.concat(n).forEach(function(e){r+=e.shape+\"_\"+(e.isUniform?\"uniform\":e.texData.texShape);});var o=e.userCode,a=(!0===e.supportsBroadcasting).toString(),i=e.constructor.name;return i+=\"_\"+a+\"_\"+r+\"_\"+o}var Im2ColProgram=function(){return function(e,t,n){this.variableNames=[\"A\"],this.outputShape=e;var r=n.filterWidth,o=n.inChannels,a=n.strideWidth,i=n.strideHeight,s=n.padInfo,u=n.outWidth,l=n.dilationWidth,c=n.dilationHeight,p=s.left,d=s.top,h=o*r;this.userCode=\"\\n      void main() {\\n        ivec2 rc = getOutputCoords();\\n\\n        vec4 result = vec4(0);\\n\\n        for(int row=0; row<=1; row++) {\\n          for(int col=0; col<=1; col++) {\\n            int blockIndex = rc.y + col;\\n            int pos = rc.x + row;\\n\\n            if(blockIndex >= \"+e[1]+\" || pos >= \"+e[0]+\") continue;\\n\\n            int offsetY = int(blockIndex / (\"+u+\")) * \"+i+\" - \"+d+\";\\n            int d0 = offsetY + \"+c+\" * (pos / \"+h+\");\\n\\n            if(d0 >= \"+t[0]+\" || d0 < 0) continue;\\n\\n            int offsetX = int(mod(float(blockIndex), \"+u+\".) * \"+a+\". - \"+p+\".);\\n            int d1 = offsetX + \"+l+\" * (int(mod(float(pos), \"+h+\".) / \"+o+\".));\\n\\n            if(d1 >= \"+t[1]+\" || d1 < 0) continue;\\n\\n            result[row * 2 + col] = getA(d0, d1, int(mod(float(pos), \"+o+\".)));\\n          }\\n        }\\n\\n        gl_FragColor = result;\\n      }\\n    \";}}(),LRNProgram=function(){return function(e,t,n,r,o){this.variableNames=[\"x\"],this.outputShape=[];var a,i=t,s=e[3]-1;this.outputShape=e;var u=\"float(\"+n+\") + float(\"+r+\") * sum\";a=.5===o?\"inversesqrt(\"+u+\")\":1===o?\"1.0/(\"+u+\")\":\"exp(log(\"+u+\") * float(-\"+o+\"));\",this.userCode=\"\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int r = coords[1];\\n        int c = coords[2];\\n        int d = coords[3];\\n        float x = getX(b, r, c, d);\\n        float sum = 0.0;\\n        for (int j = -\"+i+\"; j <= \"+i+\"; j++) {\\n          int idx = d + j;\\n          if (idx >= 0 && idx <=  \"+s+\") {\\n            float z = getX(b, r, c, idx);\\n            sum += z * z;\\n          }\\n        }\\n        float val = x * \"+a+\";\\n        setOutput(val);\\n      }\\n    \";}}(),LRNGradProgram=function(){return function(e,t,n,r,o){this.variableNames=[\"inputImage\",\"outputImage\",\"dy\"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=o,this.userCode=\"\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int r = coords[1];\\n        int c = coords[2];\\n\\n        float result = 0.0;\\n        for (int d = 0; d < \"+this.depth+\"; ++d) {\\n          int depthBegin = int(max(0.0, float(d - \"+t+\")));\\n          int depthEnd = int(min(float(\"+this.depth+\"),\\n              float(d + \"+t+\" + 1)));\\n\\n          const int MIN_DEPTH_BEGIN = 0;\\n          const int MAX_DEPTH_END = \"+this.depth+\";\\n\\n          float norm = 0.0;\\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\\n            if (k < depthBegin){\\n              continue;\\n            }\\n            else if (k >= depthBegin && k < depthEnd) {\\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\\n            }\\n            else {\\n              break;\\n            }\\n          }\\n\\n          norm = float(\"+r+\") * norm + float(\"+n+\");\\n\\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\\n            if (k < depthBegin){\\n              continue;\\n            }\\n            else if (k >= depthBegin && k < depthEnd){\\n              float dyi = -2.0 * float(\"+r+\")\\n                * float(\"+o+\")\\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\\n                / norm;\\n              if (k == d) {\\n                dyi += pow(norm, -1.0 * \"+o+\");\\n              }\\n              if (k == coords[3]) {\\n                dyi *= getDy(b, r, c, d);\\n                result += dyi;\\n              }\\n            }\\n            else {\\n              break;\\n            }\\n          }\\n      }\\n      setOutput(result);\\n      }\\n    \";}}(),MaxPool2DBackpropProgram=function(){return function(e){this.variableNames=[\"dy\",\"maxPos\"],this.outputShape=e.inShape;var t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,o=e.effectiveFilterHeight,a=e.effectiveFilterWidth,i=o-1-e.padInfo.top,s=a-1-e.padInfo.left,u=o*a-1;this.userCode=\"\\n      const ivec2 pads = ivec2(\"+i+\", \"+s+\");\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int d = coords[3];\\n\\n        ivec2 dyRCCorner = coords.yz - pads;\\n        int dyRCorner = dyRCCorner.x;\\n        int dyCCorner = dyRCCorner.y;\\n\\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n        for (int wR = 0; wR < \"+o+\";\\n          wR += \"+r+\") {\\n          float dyR = float(dyRCorner + wR) / \"+t+\".0;\\n\\n          if (dyR < 0.0 || dyR >= \"+e.outHeight+\".0 || fract(dyR) > 0.0) {\\n            continue;\\n          }\\n          int idyR = int(dyR);\\n\\n          for (int wC = 0; wC < \"+a+\"; wC++) {\\n            float dyC = float(dyCCorner + wC) / \"+n+\".0;\\n\\n            if (dyC < 0.0 || dyC >= \"+e.outWidth+\".0 ||\\n                fract(dyC) > 0.0) {\\n              continue;\\n            }\\n            int idyC = int(dyC);\\n\\n            float dyValue = getDy(b, idyR, idyC, d);\\n            int maxPosValue = \"+u+\" - int(getMaxPos(b, idyR, idyC, d));\\n\\n            // Get the current value, check it against the value from the\\n            // position matrix.\\n            int curPosValue = wR * \"+a+\" + wC;\\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\\n\\n            dotProd += dyValue * mask;\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";}}(),MatMulProgram=function(){return function(e,t,n,r){void 0===n&&(n=!1),void 0===r&&(r=!1),this.variableNames=[\"matrixA\",\"matrixB\"];var o=e[0],a=n?e[2]:e[1],i=r?t[1]:t[2],s=n?e[1]:e[2];this.outputShape=[o,a,i];var u=function(e,t){return n?\"batch, \"+t+\" + \"+e+\", aRow\":\"batch, aRow, \"+t+\" + \"+e},l=function(e,t){return r?\"batch, bCol, \"+t+\" + \"+e:\"batch, \"+t+\" + \"+e+\", bCol\"},c=4*Math.floor(s/4),p=s%4;this.userCode=\" float dotARowBCol(int batch, int aRow, int bCol) {\\n      float result = 0.0;\\n      for (int i = 0; i < \"+c+\"; i += 4) {\\n        vec4 a = vec4(\\n          getMatrixA(\"+u(0,\"i\")+\"),\\n          getMatrixA(\"+u(1,\"i\")+\"),\\n          getMatrixA(\"+u(2,\"i\")+\"),\\n          getMatrixA(\"+u(3,\"i\")+\")\\n        );\\n        vec4 b = vec4(\\n          getMatrixB(\"+l(0,\"i\")+\"),\\n          getMatrixB(\"+l(1,\"i\")+\"),\\n          getMatrixB(\"+l(2,\"i\")+\"),\\n          getMatrixB(\"+l(3,\"i\")+\")\\n        );\\n\\n        result += dot(a, b);\\n      }\\n\\n      if (\"+(1===p)+\") {\\n        result += getMatrixA(\"+u(0,c)+\") *\\n          getMatrixB(\"+l(0,c)+\");\\n      } else if (\"+(2===p)+\") {\\n        vec2 a = vec2(\\n          getMatrixA(\"+u(0,c)+\"),\\n          getMatrixA(\"+u(1,c)+\")\\n        );\\n        vec2 b = vec2(\\n          getMatrixB(\"+l(0,c)+\"),\\n          getMatrixB(\"+l(1,c)+\")\\n        );\\n        result += dot(a, b);\\n      } else if (\"+(3===p)+\") {\\n        vec3 a = vec3(\\n          getMatrixA(\"+u(0,c)+\"),\\n          getMatrixA(\"+u(1,c)+\"),\\n          getMatrixA(\"+u(2,c)+\")\\n        );\\n        vec3 b = vec3(\\n          getMatrixB(\"+l(0,c)+\"),\\n          getMatrixB(\"+l(1,c)+\"),\\n          getMatrixB(\"+l(2,c)+\")\\n        );\\n        result += dot(a, b);\\n      }\\n\\n      return result;\\n    }\\n\\n    void main() {\\n      ivec3 resBRC = getOutputCoords();\\n      setOutput(dotARowBCol(resBRC.x, resBRC.y, resBRC.z));\\n    }\\n    \";}}(),MatMulPackedProgram=function(){return function(e,t,n,r,o){void 0===r&&(r=!1),void 0===o&&(o=!1),this.variableNames=[\"matrixA\",\"matrixB\"],this.usesPackedTextures=!0,this.outputShape=n;var a=r?e[0]:e[1],i=Math.ceil(a/2),s=r?\"i * 2, rc.x\":\"rc.x, i * 2\",u=o?\"rc.y, i * 2\":\"i * 2, rc.y\",l=r?[\"a.xxyy\",\"a.zzww\"]:[\"a.xxzz\",\"a.yyww\"],c=o?[\"b.xzxz\",\"b.ywyw\"]:[\"b.xyxy\",\"b.zwzw\"];this.userCode=\"\\n      const float sharedDimension = \"+i+\".0;\\n\\n      vec4 dot2x2ARowBCol(ivec2 rc) {\\n        vec4 result = vec4(0);\\n        for (int i = 0; i < \"+i+\"; i++) {\\n          vec4 a = getMatrixA(\"+s+\");\\n          vec4 b = getMatrixB(\"+u+\");\\n\\n          result += (\"+l[0]+\" * \"+c[0]+\") + (\"+l[1]+\" * \"+c[1]+\");\\n        }\\n        return result;\\n      }\\n\\n      void main() {\\n        ivec2 rc = getOutputCoords();\\n        setOutput(dot2x2ARowBCol(rc));\\n      }\\n    \";}}(),MultinomialProgram=function(){function e(e,t,n){this.variableNames=[\"probs\"],this.outputShape=[e,n],this.userCode=\"\\n      uniform float seed;\\n\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int batch = coords[0];\\n\\n        float r = random(seed);\\n        float cdf = 0.0;\\n\\n        for (int i = 0; i < \"+(t-1)+\"; i++) {\\n          cdf += getProbs(batch, i);\\n\\n          if (r < cdf) {\\n            setOutput(float(i));\\n            return;\\n          }\\n        }\\n\\n        // If no other event happened, last event happened.\\n        setOutput(float(\"+(t-1)+\"));\\n      }\\n    \";}return e.prototype.getCustomSetupFunc=function(e){var t=this;return function(n,r){null==t.seedLoc&&(t.seedLoc=n.getUniformLocation(r,\"seed\")),n.gl.uniform1f(t.seedLoc,e);}},e}(),OneHotProgram=function(){return function(e,t,n,r){this.variableNames=[\"indices\"],this.outputShape=[e,t],this.userCode=\"\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int index = round(getIndices(coords.x));\\n        setOutput(mix(float(\"+r+\"), float(\"+n+\"),\\n                      float(index == coords.y)));\\n      }\\n    \";}}();function getVecChannels(e,t){return [\"x\",\"y\",\"z\",\"w\",\"u\",\"v\"].slice(0,t).map(function(t){return e+\".\"+t})}function getChannels(e,t){return 1===t?[e]:getVecChannels(e,t)}function getSourceCoords$1(e,t){if(1===e)return \"rc\";for(var n=\"\",r=0;r<e;r++)n+=t[r],r<e-1&&(n+=\",\");return n}var PackProgram=function(){return function(e){this.variableNames=[\"A\"],this.isPackShader=!0,this.outputShape=e;var t=e.length;if(0===t)this.userCode=\"\\n        void main() {\\n          setOutput(vec4(getA(), 0., 0., 0.));\\n        }\\n      \";else{var n=getChannels(\"rc\",t),r=getCoordsDataType(t),o=getOutOfBoundsCondition(t,e,n),a=getSetup(t,e[e.length-1],e[e.length-2],n),i=getOutput(e,n);this.userCode=\"\\n        void main() {\\n          \"+r+\" rc = getOutputCoords();\\n\\n          if(\"+o+\") {\\n            setOutput(vec4(0));\\n          } else {\\n            \"+a+\"\\n\\n            setOutput(vec4(\"+i+\"));\\n          }\\n        }\\n      \";}}}();function getSourceCoordsArr(e,t){for(var n=[],r=0;r<=1;r++)for(var o=0;o<=1;o++){for(var a=(0===r?\"r\":\"rp1\")+\", \"+(0===o?\"c\":\"cp1\"),i=2;i<e;i++)a=t[t.length-1-i]+\",\"+a;n.push(a);}return n}function getOutOfBoundsCondition(e,t,n){if(1===e)return \"rc > \"+t[0];for(var r=\"\",o=e-2;o<e;o++)r+=n[o]+\" >= \"+t[o],o<e-1&&(r+=\"||\");return r}function getSetup(e,t,n,r){if(1===e)return \"\";var o=r.slice(-2);return \"\\n    int r = \"+o[0]+\";\\n    int c = \"+o[1]+\";\\n    int rp1 = r + 1;\\n    int cp1 = c + 1;\\n\\n    bool cEdge = cp1 >= \"+t+\";\\n    bool rEdge = rp1 >= \"+n+\";\\n  \"}function getOutput(e,t){var n=e.length,r=getSourceCoordsArr(n,t);return 1===n?\"getA(rc),\\n            rc + 1 >= \"+e[0]+\" ? 0. : getA(rc + 1),\\n            0, 0\":\"getA(\"+r[0]+\"),\\n          cEdge ? 0. : getA(\"+r[1]+\"),\\n          rEdge ? 0. : getA(\"+r[2]+\"),\\n          rEdge || cEdge ? 0. : getA(\"+r[3]+\")\"}var PadProgram=function(){return function(e,t,n){this.variableNames=[\"x\"],this.outputShape=t.map(function(t,n){return t[0]+e[n]+t[1]});var r=e.length,o=getCoordsDataType(r),a=t.map(function(e){return e[0]}).join(\",\"),i=t.map(function(t,n){return t[0]+e[n]}).join(\",\"),s=[\"coords[0]\",\"coords[1]\",\"coords[2]\",\"coords[3]\"].slice(0,r);this.userCode=1!==r?\"\\n      \"+o+\" start = \"+o+\"(\"+a+\");\\n      \"+o+\" end = \"+o+\"(\"+i+\");\\n\\n      void main() {\\n        \"+o+\" outC = getOutputCoords();\\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\\n          setOutput(float(\"+n+\"));\\n        } else {\\n          \"+o+\" coords = outC - start;\\n          setOutput(getX(\"+s+\"));\\n        }\\n      }\\n    \":\"\\n        int start = \"+a+\";\\n        int end = \"+i+\";\\n\\n        void main() {\\n          int outC = getOutputCoords();\\n          if (outC < start || outC >= end) {\\n            setOutput(float(\"+n+\"));\\n          } else {\\n            setOutput(getX(outC - start));\\n          }\\n        }\\n      \";}}(),Pool2DProgram=function(){return function(e,t,n){if(this.variableNames=[\"x\"],\"avg\"===t&&n)throw new Error(\"Cannot compute positions for average pool.\");var r=e.filterWidth,o=e.strideHeight,a=e.strideWidth,i=e.dilationHeight,s=e.dilationWidth,u=e.effectiveFilterHeight,l=e.effectiveFilterWidth,c=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;var d=\"avg\"===t,h=\"0.0\";if(d||(h=\"-1.0 / 0.0\"),n)this.userCode=\"\\n        const ivec2 strides = ivec2(\"+o+\", \"+a+\");\\n        const ivec2 pads = ivec2(\"+c+\", \"+p+\");\\n\\n        void main() {\\n          ivec4 coords = getOutputCoords();\\n          int batch = coords[0];\\n          int d = coords[3];\\n\\n          ivec2 xRCCorner = coords.yz * strides - pads;\\n          int xRCorner = xRCCorner.x;\\n          int xCCorner = xRCCorner.y;\\n\\n          // max/min x(?, ?, d) to get y(yR, yC, d).\\n          // ? = to be determined\\n          float minMaxValue = 0.0;\\n          float minMaxValueFound = 0.0;\\n          int minMaxPosition = 0;\\n          float avgValue = 0.0;\\n\\n          for (int wR = 0; wR < \"+u+\";\\n              wR += \"+i+\") {\\n            int xR = xRCorner + wR;\\n\\n            if (xR < 0 || xR >= \"+e.inHeight+\") {\\n              continue;\\n            }\\n\\n            for (int wC = 0; wC < \"+l+\";\\n                wC += \"+s+\") {\\n              int xC = xCCorner + wC;\\n\\n              if (xC < 0 || xC >= \"+e.inWidth+\") {\\n                continue;\\n              }\\n\\n              float value = getX(batch, xR, xC, d);\\n\\n              // If a min / max value has already been found, use it. If not,\\n              // use the current value.\\n              float currMinMaxValue = mix(\\n                  value, minMaxValue, minMaxValueFound);\\n              if (value >= currMinMaxValue) {\\n                minMaxValue = value;\\n                minMaxValueFound = 1.0;\\n                minMaxPosition = wR * \"+l+\" + wC;\\n              }\\n            }\\n          }\\n          setOutput(float(minMaxPosition));\\n        }\\n      \";else{var f=t+\"(\"+t+\"(\"+t+\"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])\";\"avg\"===t&&(f=\"avgValue / count\");var m=4*Math.floor(r/4),g=r%4,v=\"\\n      if (\"+d+\") {\\n        avgValue += dot(values, ones);\\n      } else {\\n        minMaxValue = max(values, minMaxValue);\\n      }\\n    \";this.userCode=\"\\n      const ivec2 strides = ivec2(\"+o+\", \"+a+\");\\n      const ivec2 pads = ivec2(\"+c+\", \"+p+\");\\n      const float initializationValue = \"+h+\";\\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\\n\\n      float count = 0.0;\\n\\n      float getValue(int batch, int xR, int xC, int d) {\\n        if (xC < 0 || xC >= \"+e.inWidth+\") {\\n          return initializationValue;\\n        }\\n        count += 1.0;\\n        return getX(batch, xR, xC, d);\\n      }\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int d = coords[3];\\n\\n        ivec2 xRCCorner = coords.yz * strides - pads;\\n        int xRCorner = xRCCorner.x;\\n        int xCCorner = xRCCorner.y;\\n\\n        // max/min x(?, ?, d) to get y(yR, yC, d).\\n        // ? = to be determined\\n        vec4 minMaxValue = vec4(\"+h+\");\\n        float avgValue = 0.0;\\n        count = 0.0;\\n\\n        for (int wR = 0; wR < \"+u+\";\\n            wR += \"+i+\") {\\n          int xR = xRCorner + wR;\\n\\n          if (xR < 0 || xR >= \"+e.inHeight+\") {\\n            continue;\\n          }\\n\\n          for (int wC = 0; wC < \"+m+\"; wC += 4) {\\n            int xC = xCCorner + wC * \"+s+\";\\n\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              getValue(batch, xR, xC + \"+s+\", d),\\n              getValue(batch, xR, xC + 2 * \"+s+\", d),\\n              getValue(batch, xR, xC + 3 * \"+s+\", d)\\n            );\\n\\n            \"+v+\"\\n          }\\n\\n          int xC = xCCorner + \"+m+\";\\n          if (\"+(1===g)+\") {\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              initializationValue,\\n              initializationValue,\\n              initializationValue\\n            );\\n\\n            \"+v+\"\\n          } else if (\"+(2===g)+\") {\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              getValue(batch, xR, xC + \"+s+\", d),\\n              initializationValue,\\n              initializationValue\\n            );\\n\\n            \"+v+\"\\n          } else if (\"+(3===g)+\") {\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              getValue(batch, xR, xC + \"+s+\", d),\\n              getValue(batch, xR, xC + 2 * \"+s+\", d),\\n              initializationValue\\n            );\\n\\n            \"+v+\"\\n          }\\n        }\\n        setOutput(\"+f+\");\\n      }\\n    \";}}}(),ReduceProgram=function(){return function(e,t){this.variableNames=[\"x\"];var n=e.windowSize,r=e.batchSize,o=e.inSize,a=Math.ceil(o/n);this.outputShape=[r,a];var i=\"0.0\",s=\"\";\"prod\"===t?i=\"1.0\":\"min\"===t?(i=\"1.0 / 0.0\",s=\"min\"):\"max\"===t&&(i=\"-1.0 / 0.0\",s=\"max\");var u=t+\"(\"+t+\"(\"+t+\"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])\";\"sum\"===t?u=\"sumValue\":\"prod\"===t?u=\"prodValue\":\"all\"===t?u=\"allValue\":\"any\"===t&&(u=\"anyValue\");var l=4*Math.floor(n/4),c=n%4,p=\"\\n      if (\"+(\"sum\"===t)+\") {\\n        sumValue += dot(values, ones);\\n      } else if (\"+(\"prod\"===t)+\") {\\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\\n        prodValue *= tmp[0] * tmp[1];\\n      } else {\\n        minMaxValue = \"+s+\"(values, minMaxValue);\\n      }\\n    \",d=\"vec4\";\"all\"===t?(i=\"1.0\",p=\"\\n        bool reducedAllValue = all(values);\\n        float floatedReducedAllValue = float(reducedAllValue);\\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\\n      \",d=\"bvec4\"):\"any\"===t&&(i=\"0.0\",p=\"\\n        bool reducedAnyValue = any(values);\\n        float floatedReducedAnyValue = float(reducedAnyValue);\\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\\n      \",d=\"bvec4\");var h=\"\";o%n>0&&(h=\"\\n        if (inIdx < 0 || inIdx >= \"+o+\") {\\n          return initializationValue;\\n        }\\n      \"),this.userCode=\"\\n      const float initializationValue = \"+i+\";\\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\\n\\n      float getValue(int batch, int inIdx) {\\n        \"+h+\"\\n        return getX(batch, inIdx);\\n      }\\n\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int outIdx = coords[1];\\n        int inOffset = outIdx * \"+n+\";\\n\\n        vec4 minMaxValue = vec4(\"+i+\");\\n        float prodValue = 1.0;\\n        float sumValue = 0.0;\\n        float allValue = 1.0;\\n        float anyValue = 0.0;\\n\\n        for (int i = 0; i < \"+l+\"; i += 4) {\\n          int inIdx = inOffset + i;\\n          \"+d+\" values = \"+d+\"(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            getValue(batch, inIdx + 2),\\n            getValue(batch, inIdx + 3)\\n          );\\n\\n          \"+p+\"\\n        }\\n\\n        int inIdx = inOffset + \"+l+\";\\n        if (\"+(1===c)+\") {\\n          \"+d+\" values = \"+d+\"(\\n            getValue(batch, inIdx),\\n            initializationValue,\\n            initializationValue,\\n            initializationValue\\n          );\\n\\n          \"+p+\"\\n        } else if (\"+(2===c)+\") {\\n          \"+d+\" values = \"+d+\"(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            initializationValue,\\n            initializationValue\\n          );\\n\\n          \"+p+\"\\n        } else if (\"+(3===c)+\") {\\n          \"+d+\" values = \"+d+\"(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            getValue(batch, inIdx + 2),\\n            initializationValue\\n          );\\n\\n          \"+p+\"\\n        }\\n        setOutput(\"+u+\");\\n      }\\n    \";}}(),ReshapePackedProgram=function(){return function(e,t){this.variableNames=[\"A\"],this.usesPackedTextures=!0,this.outputShape=e;for(var n=\"\",r=0;r<4;r++){var o=\"thisRC = rc;\";r%2==1&&(o+=\"thisRC.z += 1;\"),r>1&&(o+=\"thisRC.y += 1;\"),n+=\"\\n        \"+o+\"\\n        \"+(r>0?\"if(thisRC.y < rows && thisRC.z < cols){\":\"\")+\"\\n          int flatIndex = getFlatIndex(thisRC);\\n\\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\\n\\n          result[\"+r+\"] =\\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\\n        \"+(r>0?\"}\":\"\")+\"\\n      \";}this.userCode=\"\\n      \"+getReshapedInputCoords(t)+\"\\n      \"+getFlatIndex(e)+\"\\n\\n      void main() {\\n        ivec3 rc = getOutputCoords();\\n\\n        vec4 result = vec4(0.);\\n\\n        ivec3 thisRC;\\n        int rows = \"+e[1]+\";\\n        int cols = \"+e[2]+\";\\n\\n        \"+n+\"\\n\\n        setOutput(result);\\n      }\\n    \";}}();function getFlatIndex(e){return \"\\n    int getFlatIndex(ivec3 coords) {\\n      return round(\"+dotify([\"coords.x\",\"coords.y\",\"coords.z\"],computeStrides(e).map(function(e){return e.toString()}).concat([\"1.\"]))+\");\\n    }\\n  \"}function getReshapedInputCoords(e){return \"\\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\\n      \"+getLogicalCoordinatesFromFlatIndex([\"r\",\"c\",\"d\"],e)+\"\\n      return ivec3(r, c, d);\\n    }\\n  \"}var ResizeBilinearBackpropProgram=function(){return function(e,t,n){this.variableNames=[\"dy\"],this.outputShape=[],this.outputShape=t.shape;var r=t.shape,o=r[1],a=r[2],i=e.shape,s=i[1],u=i[2],l=[n&&s>1?o-1:o,n&&u>1?a-1:a],c=[n&&s>1?s-1:s,n&&u>1?u-1:u],p=l[0]/c[0],d=l[1]/c[1],h=1/p,f=1/d,m=2*Math.ceil(h)+2,g=2*Math.ceil(f)+2;this.userCode=\"\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int d = coords[3];\\n        int r = coords[1];\\n        int c = coords[2];\\n\\n        float accumulator = 0.0;\\n\\n        const float heightScale = float(\"+p+\");\\n        const float widthScale = float(\"+d+\");\\n\\n        const float invHeightScale = float(\"+h+\");\\n        const float invWidthScale = float(\"+f+\");\\n\\n        const int winHeight = int(\"+m+\");\\n        const int winWidth = int(\"+g+\");\\n\\n        // Compute bounds for where in dy we will look\\n        float startRLerp = floor(float(r) * invHeightScale);\\n        int startDyR = int(startRLerp - float(winHeight / 2));\\n\\n        float startCLerp = floor(float(c) * invWidthScale);\\n        int startDyC = int(startCLerp - float(winWidth / 2));\\n\\n        // Loop over dy\\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\\n          int dyR = dyROffset + startDyR;\\n\\n          // Guard against the window exceeding the bounds of dy\\n          if (dyR < 0 || dyR >= \"+s+\") {\\n            continue;\\n          }\\n\\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\\n            int dyC = dyCOffset + startDyC;\\n\\n            // Guard against the window exceeding the bounds of dy\\n            if (dyC < 0 || dyC >= \"+u+\") {\\n              continue;\\n            }\\n\\n            float dxR = float(dyR) * heightScale;\\n            int topDxRIndex = int(floor(dxR));\\n            int bottomDxRIndex = int(min(ceil(dxR), \"+(o-1)+\".0));\\n            float dxRLerp = dxR - float(topDxRIndex);\\n            float inverseDxRLerp = 1.0 - dxRLerp;\\n\\n            float dxC = float(dyC) * widthScale;\\n            int leftDxCIndex = int(floor(dxC));\\n            int rightDxCIndex = int(min(ceil(dxC), \"+(a-1)+\".0));\\n            float dxCLerp = dxC - float(leftDxCIndex);\\n            float inverseDxCLerp = 1.0 - dxCLerp;\\n\\n            if (r == topDxRIndex && c == leftDxCIndex) {\\n              // topLeft\\n              accumulator +=\\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\\n            }\\n\\n            if (r == topDxRIndex && c == rightDxCIndex) {\\n              // topRight\\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\\n            }\\n\\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\\n              // bottomLeft\\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\\n            }\\n\\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\\n              // bottomRight\\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\\n            }\\n          }\\n        }\\n        // End loop over dy\\n\\n        setOutput(accumulator);\\n      }\\n    \";}}(),ResizeBilinearProgram=function(){return function(e,t,n,r){this.variableNames=[\"A\"],this.outputShape=[];var o=e[0],a=e[1],i=e[2],s=e[3];this.outputShape=[o,t,n,s];var u=[r&&t>1?a-1:a,r&&n>1?i-1:i],l=[r&&t>1?t-1:t,r&&n>1?n-1:n];this.userCode=\"\\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\\n          \"+u[0]/l[0]+\",\\n          \"+u[1]/l[1]+\");\\n      const vec2 inputShapeRC = vec2(\"+a+\".0, \"+i+\".0);\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int d = coords[3];\\n        ivec2 yRC = coords.yz;\\n\\n        // Fractional source index.\\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\\n\\n        // Compute the four integer indices.\\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\\n        ivec2 sourceCeilRC = ivec2(\\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\\n\\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\\n\\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\\n\\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\\n        float newValue = top + (bottom - top) * fracRC.x;\\n\\n        setOutput(newValue);\\n      }\\n    \";}}(),ResizeNearestNeigborBackpropProgram=function(){return function(e,t,n){this.variableNames=[\"dy\"],this.outputShape=[],this.outputShape=t.shape;var r=t.shape,o=r[1],a=r[2],i=e.shape,s=i[1],u=i[2],l=[n&&s>1?o-1:o,n&&u>1?a-1:a],c=[n&&s>1?s-1:s,n&&u>1?u-1:u],p=l[0]/c[0],d=l[1]/c[1],h=1/p,f=1/d,m=2*Math.ceil(h)+2,g=2*Math.ceil(f)+2;this.userCode=\"\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int d = coords[3];\\n        int r = coords[1];\\n        int c = coords[2];\\n\\n        float accumulator = 0.0;\\n\\n        const float heightScale = float(\"+p+\");\\n        const float widthScale = float(\"+d+\");\\n\\n        const float invHeightScale = float(\"+h+\");\\n        const float invWidthScale = float(\"+f+\");\\n\\n        const int winHeight = int(\"+m+\");\\n        const int winWidth = int(\"+g+\");\\n\\n        // Compute bounds for where in dy we will look\\n        float startRLerp = floor(float(r) * invHeightScale);\\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\\n\\n        float startCLerp = floor(float(c) * invWidthScale);\\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\\n\\n        // Loop over dy\\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\\n          int dyR = dyROffset + startDyR;\\n\\n          // Guard against the window exceeding the bounds of dy\\n          if (dyR < 0 || dyR >= \"+s+\") {\\n            continue;\\n          }\\n\\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\\n            int dyC = dyCOffset + startDyC;\\n\\n            // Guard against the window exceeding the bounds of dy\\n            if (dyC < 0 || dyC >= \"+u+\") {\\n              continue;\\n            }\\n\\n            float sourceFracRow =\\n              float(\"+l[0]+\") *\\n                (float(dyR) / float(\"+c[0]+\"));\\n\\n            float sourceFracCol =\\n                float(\"+l[1]+\") *\\n                  (float(dyC) / float(\"+c[1]+\"));\\n\\n            int sourceNearestRow = int(min(\\n                float(int(\"+o+\") - 1),\\n                \"+n+\" ? float(round(sourceFracRow)) :\\n                                  float(floor(sourceFracRow))));\\n\\n            int sourceNearestCol = int(min(\\n                float(int(\"+a+\") - 1),\\n                \"+n+\" ? float(round(sourceFracCol)) :\\n                                  float(floor(sourceFracCol))));\\n\\n            if (r == sourceNearestRow && c == sourceNearestCol) {\\n              accumulator += getDy(b, dyR, dyC, d);\\n            }\\n          }\\n        }\\n        // End loop over dy\\n\\n        setOutput(accumulator);\\n      }\\n    \";}}(),ResizeNearestNeighborProgram=function(){return function(e,t,n,r){this.variableNames=[\"A\"],this.outputShape=[];var o=e[0],a=e[1],i=e[2],s=e[3];this.outputShape=[o,t,n,s];var u=[r&&t>1?a-1:a,r&&n>1?i-1:i],l=[r&&t>1?t-1:t,r&&n>1?n-1:n],c=r?\"0.5\":\"0.0\";this.userCode=\"\\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\\n          \"+u[0]/l[0]+\",\\n          \"+u[1]/l[1]+\");\\n      const vec2 inputShapeRC = vec2(\"+a+\".0, \"+i+\".0);\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int d = coords[3];\\n        ivec2 yRC = coords.yz;\\n\\n        // Fractional source index.\\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\\n\\n        // Compute the coordinators of nearest neighbor point.\\n        ivec2 sourceNearestRC = ivec2(\\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + \"+c+\")));\\n\\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\\n\\n        setOutput(newValue);\\n      }\\n    \";}}(),ReverseProgram=function(){return function(e,t){this.variableNames=[\"x\"];var n=e.length;if(n>4)throw new Error(\"WebGL backend: Reverse of rank-\"+n+\" tensor is not yet supported\");if(this.outputShape=e,1!==n){var r=e.map(function(n,r){return function(n){return -1!==t.indexOf(n)&&1!==e[n]?e[n]+\" - coords[\"+n+\"] - 1\":\"coords[\"+n+\"]\"}(r)}).join(\",\"),o=getCoordsDataType(n);this.userCode=\"\\n      void main() {\\n        \"+o+\" coords = getOutputCoords();\\n        setOutput(getX(\"+r+\"));\\n      }\\n    \";}else this.userCode=\"\\n        void main() {\\n          int coord = getOutputCoords();\\n          setOutput(getX(\"+e[0]+\" - coord - 1));\\n        }\\n      \";}}(),ScatterProgram=function(){return function(e,t,n,r,o,a,i){void 0===i&&(i=!0),this.variableNames=[\"updates\",\"indices\",\"defaultValue\"],this.outputShape=a;var s=getCoordsDataType(o.length),u=getCoordsDataType(a.length),l=\"\";1===n?l=\"i\":2===n&&(l=\"i, j\");var c=\"getIndices(\"+l+\")\",p=\"\";1===r?p=\"i\":2===r&&(p=\"i, coords[1]\");var d=\"getUpdates(\"+p+\")\",h=t>1?\"strides[j]\":\"strides\";this.userCode=\"\\n        \"+s+\" strides = \"+s+\"(\"+o+\");\\n\\n        void main() {\\n          \"+u+\" coords = getOutputCoords();\\n          float sum = 0.0;\\n          bool found = false;\\n          for (int i = 0; i < \"+e+\"; i++) {\\n            int flattenedIndex = 0;\\n            for (int j = 0; j < \"+t+\"; j++) {\\n              int index = round(\"+c+\");\\n              flattenedIndex += index * \"+h+\";\\n            }\\n            if (flattenedIndex == coords[0]) {\\n              sum += \"+d+\";\\n              found = true;\\n            }\\n          }\\n          setOutput(mix(getDefaultValue(), sum, float(found)));\\n        }\\n      \";}}(),SegmentOpProgram=function(){return function(e,t){this.variableNames=[\"x\",\"segmentIds\"];var n=e.windowSize,r=e.batchSize,o=e.inSize,a=e.numSegments,i=a*Math.ceil(o/n);this.outputShape=[r,i];var s=4*Math.floor(n/4),u=n%4,l=\"\\n        sumValue += dot(values, filter);\\n    \",c=\"\";o%n>0&&(c=\"\\n        if (inIdx < 0 || inIdx >= \"+o+\") {\\n          return initializationValue;\\n        }\\n      \");var p=\"\";o%n>0&&(p=\"\\n        if (inIdx < 0 || inIdx >= \"+o+\") {\\n          return -1.0;\\n        }\\n      \"),this.userCode=\"\\n      const float initializationValue = 0.0;\\n\\n      float getValue(int batch, int inIdx) {\\n        \"+c+\"\\n        return getX(batch, inIdx);\\n      }\\n\\n      float getSegmentIdAtIndex(int inIdx) {\\n        \"+p+\"\\n        return getSegmentIds(inIdx);\\n      }\\n\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int outIdx = coords[1];\\n        int inOffset = int(floor(float(outIdx) / float(\\n          \"+a+\")) * float(\"+n+\"));\\n        int currentSeg = int(mod(float(outIdx), float(\"+a+\")));\\n\\n        float sumValue = 0.0;\\n\\n        for (int i = 0; i < \"+s+\"; i += 4) {\\n          int inIdx = inOffset + i;\\n          vec4 values = vec4(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            getValue(batch, inIdx + 2),\\n            getValue(batch, inIdx + 3)\\n          );\\n\\n          vec4 filter = vec4(\\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\\n          );\\n\\n          \"+l+\"\\n        }\\n\\n        int inIdx = inOffset + \"+s+\";\\n        if (\"+(1===u)+\") {\\n          vec4 values = vec4(\\n            getValue(batch, inIdx),\\n            initializationValue,\\n            initializationValue,\\n            initializationValue\\n          );\\n\\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\\n\\n          vec4 filter = vec4(\\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\\n            0,\\n            0,\\n            0\\n          );\\n\\n          \"+l+\"\\n        } else if (\"+(2===u)+\") {\\n          vec4 values = vec4(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            initializationValue,\\n            initializationValue\\n          );\\n\\n          vec4 filter = vec4(\\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\\n              0,\\n              0\\n          );\\n\\n          \"+l+\"\\n        } else if (\"+(3===u)+\") {\\n          vec4 values = vec4(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            getValue(batch, inIdx + 2),\\n            initializationValue\\n          );\\n\\n          vec4 filter = vec4(\\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\\n            0\\n          );\\n\\n          \"+l+\"\\n        }\\n        setOutput(sumValue);\\n      }\\n    \";}}(),SelectProgram=function(){return function(e,t,n){var r,o;if(this.variableNames=[\"c\",\"a\",\"b\"],this.outputShape=t,n>4)throw Error(\"Where for rank \"+n+\" is not yet supported\");if(1===n)o=\"resRC\",r=\"resRC\";else{for(var a=[\"resRC.x\",\"resRC.y\",\"resRC.z\",\"resRC.w\"],i=[],s=[],u=0;u<t.length;u++)s.push(\"\"+a[u]),u<e&&i.push(\"\"+a[u]);r=i.join(),o=s.join();}var l=getCoordsDataType(n);this.userCode=\"\\n      void main() {\\n        \"+l+\" resRC = getOutputCoords();\\n        float cVal = getC(\"+r+\");\\n        if (cVal >= 1.0) {\\n          setOutput(getA(\"+o+\"));\\n        } else {\\n          setOutput(getB(\"+o+\"));\\n        }\\n      }\\n    \";}}(),SliceProgram=function(){function e(e){this.variableNames=[\"source\"],this.outputShape=e,this.rank=e.length;var t=getCoordsDataType(this.rank),n=getCoords$1(this.rank);this.userCode=\"\\n      uniform \"+t+\" start;\\n\\n      void main() {\\n        \"+t+\" sourceLoc = start + getOutputCoords();\\n        setOutput(getSource(\"+n+\"));\\n      }\\n    \";}return e.prototype.getCustomSetupFunc=function(e){var t=this;if(e.length!==this.rank)throw Error(\"The rank (\"+this.rank+\") of the program must match the length of start (\"+e.length+\")\");return function(n,r){if(null!=t.startLoc||(t.startLoc=n.getUniformLocationNoThrow(r,\"start\"),null!=t.startLoc))if(1===t.rank)n.gl.uniform1i(t.startLoc,e[0]);else if(2===t.rank)n.gl.uniform2i(t.startLoc,e[0],e[1]);else if(3===t.rank)n.gl.uniform3i(t.startLoc,e[0],e[1],e[2]);else{if(4!==t.rank)throw Error(\"Slicing for rank \"+t.rank+\" is not yet supported\");n.gl.uniform4i(t.startLoc,e[0],e[1],e[2],e[3]);}}},e}();function getCoords$1(e){if(1===e)return \"sourceLoc\";if(2===e)return \"sourceLoc.x, sourceLoc.y\";if(3===e)return \"sourceLoc.x, sourceLoc.y, sourceLoc.z\";if(4===e)return \"sourceLoc.x, sourceLoc.y, sourceLoc.z, sourceLoc.w\";throw Error(\"Slicing for rank \"+e+\" is not yet supported\")}var StridedSliceProgram=function(){return function(e,t,n,r){this.variableNames=[\"x\"];var o=n.filter(function(e,t){return -1===r.indexOf(t)});this.outputShape=o;var a=n.length,i=getCoordsDataType(n.length),s=getCoordsDataType(o.length),u=\"\";if(1===a)u=\"coords * strides + begin\";else{var l=0;u=n.map(function(e,t){return -1===r.indexOf(t)?(l++,1===o.length?\"coords * strides[\"+t+\"] + begin[\"+t+\"]\":\"coords[\"+(l-1)+\"] * strides[\"+t+\"] + begin[\"+t+\"]\"):\"begin[\"+t+\"]\"}).join(\",\");}this.userCode=\"\\n      \"+i+\" begin = \"+i+\"(\"+e+\");\\n      \"+i+\" strides = \"+i+\"(\"+t+\");\\n\\n      void main() {\\n        \"+s+\" coords = getOutputCoords();\\n        setOutput(getX(\"+u+\"));\\n      }\\n    \";}}(),TextureManager=function(){function e(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={};}return e.prototype.acquireTexture=function(e,t,n){var r,o=getPhysicalFromLogicalTextureType(t,n),a=getKeyFromTextureShape(e,o,n);if(a in this.freeTextures||(this.freeTextures[a]=[]),a in this.usedTextures||(this.usedTextures[a]=[]),this.freeTextures[a].length>0){this.numFreeTextures--,this.numUsedTextures++,this.log();var i=this.freeTextures[a].shift();return this.usedTextures[a].push(i),i}return this.numUsedTextures++,this.log(),o===PhysicalTextureType.PACKED_2X2_FLOAT32?r=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):o===PhysicalTextureType.PACKED_2X2_FLOAT16?r=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):o===PhysicalTextureType.UNPACKED_FLOAT32?r=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):o===PhysicalTextureType.UNPACKED_FLOAT16?r=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):o===PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE&&(r=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[a].push(r),r},e.prototype.releaseTexture=function(e,t,n,r){if(null!=this.freeTextures){var o=getKeyFromTextureShape(t,getPhysicalFromLogicalTextureType(n,r),r);o in this.freeTextures||(this.freeTextures[o]=[]),this.freeTextures[o].push(e),this.numFreeTextures++,this.numUsedTextures--;var a=this.usedTextures[o],i=a.indexOf(e);if(i<0)throw new Error(\"Cannot release a texture that was never provided by this texture manager\");a.splice(i,1),this.log();}},e.prototype.log=function(){if(this.logEnabled){var e=this.numFreeTextures+this.numUsedTextures;console.log(\"Free/Used\",this.numFreeTextures+\" / \"+this.numUsedTextures,\"(\"+e+\")\");}},e.prototype.getNumUsedTextures=function(){return this.numUsedTextures},e.prototype.getNumFreeTextures=function(){return this.numFreeTextures},e.prototype.dispose=function(){var e=this;if(null!=this.freeTextures){for(var t in this.freeTextures)this.freeTextures[t].forEach(function(t){e.gpgpu.deleteMatrixTexture(t);});for(var t in this.usedTextures)this.usedTextures[t].forEach(function(t){e.gpgpu.deleteMatrixTexture(t);});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0;}},e}();function getPhysicalFromLogicalTextureType(e,t){if(e===TextureUsage.UPLOAD)return t?PhysicalTextureType.PACKED_2X2_FLOAT32:PhysicalTextureType.UNPACKED_FLOAT32;if(e===TextureUsage.RENDER||null==e)return t?ENV.get(\"WEBGL_RENDER_FLOAT32_ENABLED\")?PhysicalTextureType.PACKED_2X2_FLOAT32:PhysicalTextureType.PACKED_2X2_FLOAT16:ENV.get(\"WEBGL_RENDER_FLOAT32_ENABLED\")?PhysicalTextureType.UNPACKED_FLOAT32:PhysicalTextureType.UNPACKED_FLOAT16;if(e===TextureUsage.DOWNLOAD||e===TextureUsage.PIXELS)return PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE;throw new Error(\"Unknown logical texture type \"+e)}function getKeyFromTextureShape(e,t,n){return e[0]+\"_\"+e[1]+\"_\"+t+\"_\"+n}var TileProgram=function(){return function(e,t){this.variableNames=[\"A\"];for(var n=new Array(e.length),r=0;r<n.length;r++)n[r]=e[r]*t[r];this.outputShape=n,this.rank=n.length;var o=getCoordsDataType(this.rank),a=getSourceCoords$2(e);this.userCode=\"\\n      void main() {\\n        \"+o+\" resRC = getOutputCoords();\\n        setOutput(getA(\"+a+\"));\\n      }\\n    \";}}();function getSourceCoords$2(e){var t=e.length;if(t>5)throw Error(\"Tile for rank \"+t+\" is not yet supported\");if(1===t)return \"imod(resRC, \"+e[0]+\")\";for(var n=[\"resRC.x\",\"resRC.y\",\"resRC.z\",\"resRC.w\",\"resRC.u\"],r=[],o=0;o<e.length;o++)r.push(\"imod(\"+n[o]+\", \"+e[o]+\")\");return r.join()}var TransposeProgram=function(){return function(e,t){this.variableNames=[\"A\"];for(var n=new Array(e.length),r=0;r<n.length;r++)n[r]=e[t[r]];this.outputShape=n,this.rank=n.length;var o=getCoordsDataType(this.rank),a=getSwitchedCoords(t);this.userCode=\"\\n    void main() {\\n      \"+o+\" resRC = getOutputCoords();\\n      setOutput(getA(\"+a+\"));\\n    }\\n    \";}}();function getSwitchedCoords(e){var t=e.length;if(t>6)throw Error(\"Transpose for rank \"+t+\" is not yet supported\");for(var n=[\"resRC.x\",\"resRC.y\",\"resRC.z\",\"resRC.w\",\"resRC.u\",\"resRC.v\"],r=new Array(t),o=0;o<e.length;o++)r[e[o]]=n[o];return r.join()}var ERF_P=.3275911,ERF_A1=.254829592,ERF_A2=-.284496736,ERF_A3=1.421413741,ERF_A4=-1.453152027,ERF_A5=1.061405429,SELU_SCALEALPHA=1.7580993408473768,SELU_SCALE=1.0507009873554805,UnaryOpProgram=function(){function e(e,t){this.variableNames=[\"A\"],this.outputShape=e,this.userCode=\"\\n      uniform float NAN;\\n      float unaryOperation(float x) {\\n        \"+t+\"\\n      }\\n\\n      void main() {\\n        float x = getAAtOutCoords();\\n        float y = unaryOperation(x);\\n\\n        setOutput(y);\\n      }\\n    \";}return e.prototype.getCustomSetupFunc=function(){var e=this;return function(t,n){null==e.startLoc&&(e.startLoc=t.getUniformLocationNoThrow(n,\"NAN\"),null==e.startLoc)||t.gl.uniform1f(e.startLoc,NaN);}},e}(),CHECK_NAN_SNIPPET$1=\"if (isNaN(x)) return x;\",ABS=\"return abs(x);\",RELU=CHECK_NAN_SNIPPET$1+\"\\n  return (x < 0.0) ? 0.0 : x;\\n\",ELU=\"return (x >= 0.0) ? x : (exp(x) - 1.0);\",SELU=\"\\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\\n  // see: https://arxiv.org/abs/1706.02515\\n  float scaleAlpha = \"+SELU_SCALEALPHA+\";\\n  float scale = \"+SELU_SCALE+\";\\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\\n\";function STEP(e){return void 0===e&&(e=0),CHECK_NAN_SNIPPET$1+\"\\n    return x > 0.0 ? 1.0 : float(\"+e+\");\\n  \"}var NEG=\"return -x;\",CEIL=\"return ceil(x);\",FLOOR=\"return floor(x);\",SIGN=\"\\n  if (isNaN(x)) { return 0.0; }\\n  return sign(x);\\n\",ROUND=\"\\n  // OpenGL ES does not support round function.\\n  // The algorithm is based on banker's rounding.\\n  float base = floor(x);\\n  if ((x - base) < 0.5) {\\n    return floor(x);\\n  } else if ((x - base) > 0.5) {\\n    return ceil(x);\\n  } else {\\n    if (mod(base, 2.0) == 0.0) {\\n      return base;\\n    } else {\\n      return base + 1.0;\\n    }\\n  }\\n\",EXP=\"return exp(x);\",EXPM1=\"return exp(x) - 1.0;\",LOG=\"if (x < 0.0) return NAN;\\n  return log(x);\",LOG1P=\"return log(1.0 + x);\",SQRT=\"return sqrt(x);\",RSQRT=\"return inversesqrt(x);\",SIGMOID=\"return 1.0 / (1.0 + exp(-1.0 * x));\",SOFTPLUS=\"\\n  float epsilon = 1.1920928955078125e-7;\\n  float threshold = log(epsilon) + 2.0;\\n\\n  bool too_large = x > -threshold;\\n  bool too_small = x < threshold;\\n\\n  float result;\\n  float exp_x = exp(x);\\n\\n  if (too_large){\\n    result = x;\\n  }\\n  else if (too_small){\\n    result = exp_x;\\n  }\\n  else{\\n    result = log(exp_x + 1.0);\\n  }\\n  return result;\\n\",SIN=CHECK_NAN_SNIPPET$1+\"\\n  return sin(x);\\n\",COS=CHECK_NAN_SNIPPET$1+\"\\n  return cos(x);\\n\",TAN=\"return tan(x);\",ASIN=\"return asin(x);\",ACOS=\"return acos(x);\",ATAN=CHECK_NAN_SNIPPET$1+\"\\n  return atan(x);\\n\",SINH=\"\\n  float e2x = exp(x);\\n  return (e2x - 1.0 / e2x) / 2.0;\\n\",COSH=\"\\n  float e2x = exp(-x);\\n  return (e2x + 1.0 / e2x) / 2.0;\\n\",TANH=\"\\n  float e2x = exp(-2.0 * abs(x));\\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\\n\",ASINH=\"return log(x + sqrt(x * x + 1.0));\",ACOSH=CHECK_NAN_SNIPPET$1+\"\\n  if (x < 1.0) return NAN;\\n  return log(x + sqrt(x * x - 1.0));\",ATANH=CHECK_NAN_SNIPPET$1+\"\\n  if ((x < -1.0) || (x > 1.0)) return NAN;\\n  return (log(1.0 + x) - log(1.0 - x)) / 2.0;\",ERF='\\n  // Error function is calculated approximately with elementary function.\\n  // See \"Handbook of Mathematical Functions with Formulas,\\n  // Graphs, and Mathematical Tables\", Abramowitz and Stegun.\\n  float p = '+ERF_P+\";\\n  float a1 = \"+ERF_A1+\";\\n  float a2 = \"+ERF_A2+\";\\n  float a3 = \"+ERF_A3+\";\\n  float a4 = \"+ERF_A4+\";\\n  float a5 = \"+ERF_A5+\";\\n\\n  float t = 1.0 / (1.0 + p * x);\\n  return 1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x);\\n\",SQUARE=\"return x * x;\",RECIPROCAL=\"return 1.0 / x;\",LOGICAL_NOT=\"return float(!(x >= 1.0));\",TO_INT=\"return float(int(x));\",UnpackProgram=function(){return function(e){this.variableNames=[\"A\"],this.usesPackedTextures=!0,this.outputShape=e;var t=e.length,n=getChannels(\"rc\",t),r=getCoordsDataType(t),o=getSourceCoords$1(t,n),a=n.slice(-2),i=t<=1?\"rc\":\"vec2(\"+a.join(\",\")+\")\";this.userCode=\"\\n      void main() {\\n        \"+r+\" rc = getOutputCoords();\\n        vec4 packedInput = getA(\"+o+\");\\n\\n        setOutput(getChannel(packedInput, \"+i+\"));\\n      }\\n    \";}}();function concat1d_(e){return concat(e,0)}function concat2d_(e,t){return concat(e,t)}function concat3d_(e,t){return concat(e,t)}function concat4d_(e,t){return concat(e,t)}function concat_(e,t){void 0===t&&(t=0),assert(e.length>=1,\"Pass at least one tensor to concat\");var n=convertToTensorArray(e,\"tensors\",\"concat\");t=parseAxisParam(t,n[0].shape)[0];var r=computeOutShape(n.map(function(e){return e.shape}),t);if(0===sizeFromShape(r))return tensor([],r);if(1===(n=n.filter(function(e){return e.size>0})).length)return n[0];var o=n.map(function(e){return e.shape});assertParamsConsistent(o,t);var a=n;return ENV.engine.runKernel(function(e){return e.concat(n,t)},a,function(e){var n=o.map(function(e){return e[t]});return split$1(e,n,t).map(function(e){return function(){return e}})})}function split_(e,t,n){void 0===n&&(n=0);var r,o=convertToTensor(e,\"x\",\"split\");n=parseAxisParam(n,o.shape)[0],\"number\"==typeof t?(assert(o.shape[n]%t==0,\"Number of splits must evenly divide the axis.\"),r=Array(t).fill(o.shape[n]/t)):(assert(o.shape[n]===t.reduce(function(e,t){return e+t}),\"The sum of sizes must match the size of the axis dimension.\"),r=t);return ENV.engine.runKernel(function(e){return e.split(o,r,n)},{$x:o},function(e){return {$x:function(){return concat(e,n)}}})}var concat=op({concat_:concat_}),concat1d=op({concat1d_:concat1d_}),concat2d=op({concat2d_:concat2d_}),concat3d=op({concat3d_:concat3d_}),concat4d=op({concat4d_:concat4d_}),split$1=op({split_:split_});function createCommonjsModule(e,t){return e(t={exports:{}},t.exports),t.exports}var alea=createCommonjsModule(function(e){!function(e,t,n){function r(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function o(e,t){var n=new function(e){var t,n=this,r=(t=4022871197,function(e){e=e.toString();for(var n=0;n<e.length;n++){var r=.02519603282416938*(t+=e.charCodeAt(n));r-=t=r>>>0,t=(r*=t)>>>0,t+=4294967296*(r-=t);}return 2.3283064365386963e-10*(t>>>0)});n.next=function(){var e=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=e-(n.c=0|e)},n.c=1,n.s0=r(\" \"),n.s1=r(\" \"),n.s2=r(\" \"),n.s0-=r(e),n.s0<0&&(n.s0+=1),n.s1-=r(e),n.s1<0&&(n.s1+=1),n.s2-=r(e),n.s2<0&&(n.s2+=1),r=null;}(e),o=t&&t.state,a=n.next;return a.int32=function(){return 4294967296*n.next()|0},a.double=function(){return a()+1.1102230246251565e-16*(2097152*a()|0)},a.quick=a,o&&(\"object\"==typeof o&&r(o,n),a.state=function(){return r(n,{})}),a}t&&t.exports?t.exports=o:n&&n.amd?n(function(){return o}):this.alea=o;}(0,e,!1);}),xor128=createCommonjsModule(function(e){!function(e,t,n){function r(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function o(e,t){var n=new function(e){var t=this,n=\"\";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next();}(e),o=t&&t.state,a=function(){return (n.next()>>>0)/4294967296};return a.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21);}while(0===e);return e},a.int32=n.next,a.quick=a,o&&(\"object\"==typeof o&&r(o,n),a.state=function(){return r(n,{})}),a}t&&t.exports?t.exports=o:n&&n.amd?n(function(){return o}):this.xor128=o;}(0,e,!1);}),xorwow=createCommonjsModule(function(e){!function(e,t,n){function r(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function o(e,t){var n=new function(e){var t=this,n=\"\";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next();}(e),o=t&&t.state,a=function(){return (n.next()>>>0)/4294967296};return a.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21);}while(0===e);return e},a.int32=n.next,a.quick=a,o&&(\"object\"==typeof o&&r(o,n),a.state=function(){return r(n,{})}),a}t&&t.exports?t.exports=o:n&&n.amd?n(function(){return o}):this.xorwow=o;}(0,e,!1);}),xorshift7=createCommonjsModule(function(e){!function(e,t,n){function r(e,t){return t.x=e.x.slice(),t.i=e.i,t}function o(e,t){null==e&&(e=+new Date);var n=new function(e){var t=this;t.next=function(){var e,n,r=t.x,o=t.i;return e=r[o],n=(e^=e>>>7)^e<<24,n^=(e=r[o+1&7])^e>>>10,n^=(e=r[o+3&7])^e>>>3,n^=(e=r[o+4&7])^e<<7,e=r[o+7&7],n^=(e^=e<<13)^e<<9,r[o]=n,t.i=o+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=\"\"+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next();}(t,e);}(e),o=t&&t.state,a=function(){return (n.next()>>>0)/4294967296};return a.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21);}while(0===e);return e},a.int32=n.next,a.quick=a,o&&(o.x&&r(o,n),a.state=function(){return r(n,{})}),a}t&&t.exports?t.exports=o:n&&n.amd?n(function(){return o}):this.xorshift7=o;}(0,e,!1);}),xor4096=createCommonjsModule(function(e){!function(e,t,n){function r(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function o(e,t){null==e&&(e=+new Date);var n=new function(e){var t=this;t.next=function(){var e,n,r=t.w,o=t.X,a=t.i;return t.w=r=r+1640531527|0,n=o[a+34&127],e=o[a=a+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=o[a]=n^e,t.i=a,n+(r^r>>>16)|0},function(e,t){var n,r,o,a,i,s=[],u=128;for(t===(0|t)?(r=t,t=null):(t+=\"\\0\",r=0,u=Math.max(u,t.length)),o=0,a=-32;a<u;++a)t&&(r^=t.charCodeAt((a+32)%t.length)),0===a&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,a>=0&&(i=i+1640531527|0,o=0==(n=s[127&a]^=r+i)?o+1:0);for(o>=128&&(s[127&(t&&t.length||0)]=-1),o=127,a=512;a>0;--a)r=s[o+34&127],n=s[o=o+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,s[o]=r^n;e.w=i,e.X=s,e.i=o;}(t,e);}(e),o=t&&t.state,a=function(){return (n.next()>>>0)/4294967296};return a.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21);}while(0===e);return e},a.int32=n.next,a.quick=a,o&&(o.X&&r(o,n),a.state=function(){return r(n,{})}),a}t&&t.exports?t.exports=o:n&&n.amd?n(function(){return o}):this.xor4096=o;}(0,e,!1);}),tychei=createCommonjsModule(function(e){!function(e,t,n){function r(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function o(e,t){var n=new function(e){var t=this,n=\"\";t.next=function(){var e=t.b,n=t.c,r=t.d,o=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^o,o=o-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^o,t.a=o-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next();}(e),o=t&&t.state,a=function(){return (n.next()>>>0)/4294967296};return a.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21);}while(0===e);return e},a.int32=n.next,a.quick=a,o&&(\"object\"==typeof o&&r(o,n),a.state=function(){return r(n,{})}),a}t&&t.exports?t.exports=o:n&&n.amd?n(function(){return o}):this.tychei=o;}(0,e,!1);}),seedrandom=createCommonjsModule(function(e){!function(t,n){var r,o=this,a=256,i=6,s=\"random\",u=n.pow(a,i),l=n.pow(2,52),c=2*l,p=a-1;function d(e,d,g){var v=[],y=f(function e(t,n){var r,o=[],a=typeof t;if(n&&\"object\"==a)for(r in t)try{o.push(e(t[r],n-1));}catch(e){}return o.length?o:\"string\"==a?t:t+\"\\0\"}((d=1==d?{entropy:!0}:d||{}).entropy?[e,m(t)]:null==e?function(){try{var e;return r&&(e=r.randomBytes)?e=e(a):(e=new Uint8Array(a),(o.crypto||o.msCrypto).getRandomValues(e)),m(e)}catch(e){var n=o.navigator,i=n&&n.plugins;return [+new Date,o,i,o.screen,m(t)]}}():e,3),v),x=new function(e){var t,n=e.length,r=this,o=0,i=r.i=r.j=0,s=r.S=[];n||(e=[n++]);for(;o<a;)s[o]=o++;for(o=0;o<a;o++)s[o]=s[i=p&i+e[o%n]+(t=s[o])],s[i]=t;(r.g=function(e){for(var t,n=0,o=r.i,i=r.j,s=r.S;e--;)t=s[o=p&o+1],n=n*a+s[p&(s[o]=s[i=p&i+t])+(s[i]=t)];return r.i=o,r.j=i,n})(a);}(v),T=function(){for(var e=x.g(i),t=u,n=0;e<l;)e=(e+n)*a,t*=a,n=x.g(1);for(;e>=c;)e/=2,t/=2,n>>>=1;return (e+n)/t};return T.int32=function(){return 0|x.g(4)},T.quick=function(){return x.g(4)/4294967296},T.double=T,f(m(x.S),t),(d.pass||g||function(e,t,r,o){return o&&(o.S&&h(o,x),e.state=function(){return h(x,{})}),r?(n[s]=e,t):e})(T,y,\"global\"in d?d.global:this==n,d.state)}function h(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function f(e,t){for(var n,r=e+\"\",o=0;o<r.length;)t[p&o]=p&(n^=19*t[p&o])+r.charCodeAt(o++);return m(t)}function m(e){return String.fromCharCode.apply(0,e)}if(n[\"seed\"+s]=d,f(n.random(),t),e.exports){e.exports=d;try{r=require(\"crypto\");}catch(e){}}}([],Math);});seedrandom.alea=alea,seedrandom.xor128=xor128,seedrandom.xorwow=xorwow,seedrandom.xorshift7=xorshift7,seedrandom.xor4096=xor4096,seedrandom.tychei=tychei;var seedrandom$1=seedrandom,seedrandom_1=seedrandom$1.alea,MPRandGauss=function(){function e(e,t,n,r,o){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);var a=o||Math.random();this.random=seedrandom_1(a.toString());}return e.prototype.nextValue=function(){if(!isNaN(this.nextVal)){var e=this.nextVal;return this.nextVal=NaN,e}for(var t,n,r=!1;!r;){var o=void 0,a=void 0,i=void 0;do{i=(o=2*this.random()-1)*o+(a=2*this.random()-1)*a;}while(i>=1||0===i);var s=Math.sqrt(-2*Math.log(i)/i);t=this.mean+this.stdDev*o*s,n=this.mean+this.stdDev*a*s,this.truncated&&!this.isValidTruncated(t)||(r=!0);}return this.truncated&&!this.isValidTruncated(n)||(this.nextVal=this.convertValue(n)),this.convertValue(t)},e.prototype.convertValue=function(e){return null==this.dtype||\"float32\"===this.dtype?e:Math.round(e)},e.prototype.isValidTruncated=function(e){return e<=this.upper&&e>=this.lower},e}();function clone_(e){var t=convertToTensor(e,\"x\",\"clone\",null);return ENV.engine.runKernel(function(e){return Tensor.make(t.shape,{dataId:t.dataId},t.dtype)},{$x:t},function(e){return {$x:function(){return e.toFloat()}}})}function eye_(e,t,n,r){void 0===r&&(r=\"float32\"),null==t&&(t=e);for(var o=buffer([e,t],r),a=e<=t?e:t,i=0;i<a;++i)o.set(1,i,i);var s=o.toTensor().as2D(e,t);if(null==n)return s;if(1===n.length)return tile(expandDims(s,0),[n[0],1,1]);if(2===n.length)return tile(expandDims(expandDims(s,0),0),[n[0],n[1],1,1]);if(3===n.length)return tile(expandDims(expandDims(expandDims(s,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(\"eye() currently supports only 1D and 2D batchShapes, but received \"+n.length+\"D.\")}function randomNormal_(e,t,n,r,o){if(void 0===t&&(t=0),void 0===n&&(n=1),null!=r&&\"bool\"===r)throw new Error(\"Unsupported data type \"+r);for(var a=new MPRandGauss(t,n,r,!1,o),i=buffer(e,r),s=0;s<i.values.length;s++)i.values[s]=a.nextValue();return i.toTensor()}function truncatedNormal_(e,t,n,r,o){if(void 0===t&&(t=0),void 0===n&&(n=1),null!=r&&\"bool\"===r)throw new Error(\"Unsupported data type \"+r);for(var a=new MPRandGauss(t,n,r,!0,o),i=buffer(e,r),s=0;s<i.values.length;s++)i.values[s]=a.nextValue();return i.toTensor()}function randomUniform_(e,t,n,r){void 0===t&&(t=0),void 0===n&&(n=1),void 0===r&&(r=\"float32\");for(var o=buffer(e,r),a=0;a<o.values.length;a++)o.values[a]=randUniform(t,n);return o.toTensor()}function rand_(e,t,n){var r=sizeFromShape(e),o=null;if(null==n||\"float32\"===n)o=new Float32Array(r);else if(\"int32\"===n)o=new Int32Array(r);else{if(\"bool\"!==n)throw new Error(\"Unknown data type \"+n);o=new Uint8Array(r);}for(var a=0;a<r;a++)o[a]=t();return Tensor.make(e,{values:o},n)}function multinomial_(e,t,n,r){void 0===r&&(r=!1);var o=convertToTensor(e,\"logits\",\"multinomial\"),a=o.size,i=o.rank;if(a<2)throw new Error(\"Error in multinomial: you need at least 2 outcomes, but got \"+a+\".\");if(i>2)throw new Error(\"Rank of probabilities must be 1 or 2, but is \"+i);n=n||Math.random();var s=1===i?o.as2D(1,-1):o,u=ENV.engine.runKernel(function(e){return e.multinomial(s,r,t,n)},{logits2D:s});return 1===i?u.as1D():u}function oneHot_(e,t,n,r){void 0===n&&(n=1),void 0===r&&(r=0);var o=convertToTensor(e,\"indices\",\"oneHot\",\"int32\");if(t<2)throw new Error(\"Error in oneHot: depth must be >=2, but it is \"+t);return ENV.engine.runKernel(function(e){return e.oneHot(o,t,n,r)},{$indices:o},function(e){return {$indices:function(){return zeros(o.shape,\"float32\")}}})}function fromPixels_(e,t){if(void 0===t&&(t=3),t>4)throw new Error(\"Cannot construct Tensor with more than 4 channels from pixels.\");return ENV.engine.fromPixels(e,t)}function toPixels(e,t){return __awaiter(this,void 0,void 0,function(){var n,r,o,a,i,s,u,l,c,p,d,h,f,m,g,v,y,x,T,w;return __generator(this,function(E){switch(E.label){case 0:if(n=convertToTensor(e,\"img\",\"toPixels\"),e instanceof Tensor||(n=n.toInt()),2!==n.rank&&3!==n.rank)throw new Error(\"toPixels only supports rank 2 or 3 tensors, got rank \"+n.rank+\".\");if(r=n.shape.slice(0,2),o=r[0],a=r[1],(i=2===n.rank?1:n.shape[2])>4||2===i)throw new Error(\"toPixels only supports depth of size 1, 3 or 4 but got \"+i);return s=n.min(),u=n.max(),[4,s.data()];case 1:return l=E.sent()[0],[4,u.data()];case 2:if(c=E.sent()[0],s.dispose(),u.dispose(),\"float32\"===n.dtype){if(l<0||c>1)throw new Error(\"Tensor values for a float32 Tensor must be in the range [0 - 1] but got range [\"+l+\" - \"+c+\"].\")}else{if(\"int32\"!==n.dtype)throw new Error(\"Unsupported type for toPixels: \"+n.dtype+\". Please use float32 or int32 tensors.\");if(l<0||c>255)throw new Error(\"Tensor values for a int32 Tensor must be in the range [0 - 255] but got range [\"+l+\" - \"+c+\"].\")}return [4,n.data()];case 3:for(p=E.sent(),d=\"float32\"===n.dtype?255:1,h=new Uint8ClampedArray(a*o*4),f=0;f<o*a;++f)m=void 0,g=void 0,v=void 0,y=void 0,1===i?(m=p[f]*d,g=p[f]*d,v=p[f]*d,y=255):3===i?(m=p[3*f]*d,g=p[3*f+1]*d,v=p[3*f+2]*d,y=255):4===i&&(m=p[4*f]*d,g=p[4*f+1]*d,v=p[4*f+2]*d,y=p[4*f+3]*d),h[(x=4*f)+0]=Math.round(m),h[x+1]=Math.round(g),h[x+2]=Math.round(v),h[x+3]=Math.round(y);return null!=t&&(t.width=a,t.height=o,T=t.getContext(\"2d\"),w=new ImageData(h,a,o),T.putImageData(w,0,0)),n!==e&&n.dispose(),[2,h]}})})}function reshape_(e,t){var n=convertToTensor(e,\"x\",\"reshape\",null);t=inferFromImplicitShape(t,n.size),assert(n.size===sizeFromShape(t),\"new shape and old shape must have the same number of elements.\");return ENV.engine.runKernel(function(e){return e.reshape(n,t)},{$x:n},function(e){return {$x:function(){return e.reshape(n.shape)}}})}function squeeze_(e,t){var n=convertToTensor(e,\"x\",\"squeeze\");return reshape(n,squeezeShape(n.shape,t).newShape)}function cast_(e,t){var n=convertToTensor(e,\"x\",\"cast\");return ENV.engine.runKernel(function(e){return e.cast(n,t)},{$x:n},function(e){return {$x:function(){return e.clone()}}})}function tile_(e,t){var n=convertToTensor(e,\"x\",\"tile\");assert(n.rank===t.length,\"Error in transpose: rank of input \"+n.rank+\" must match length of reps \"+t+\".\");return ENV.engine.runKernel(function(e){return e.tile(n,t)},{$x:n},function(e){return {$x:function(){var r=zerosLike(n);if(1===n.rank)for(var o=0;o<t[0];++o)r=r.add(e.slice([o*n.shape[0]],[n.shape[0]]));else if(2===n.rank)for(o=0;o<t[0];++o)for(var a=0;a<t[1];++a)r=r.add(e.slice([o*n.shape[0],a*n.shape[1]],[n.shape[0],n.shape[1]]));else if(3===n.rank)for(o=0;o<t[0];++o)for(a=0;a<t[1];++a)for(var i=0;i<t[2];++i)r=r.add(e.slice([o*n.shape[0],a*n.shape[1],i*n.shape[2]],[n.shape[0],n.shape[1],n.shape[2]]));else{if(4!==n.rank)throw new Error(\"Gradient for tile operation is not implemented for rank-\"+n.rank+\" tensors yet.\");for(o=0;o<t[0];++o)for(a=0;a<t[1];++a)for(i=0;i<t[2];++i)for(var s=0;s<t[3];++s)r=r.add(e.slice([o*n.shape[0],a*n.shape[1],i*n.shape[2],s*n.shape[3]],[n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));}return r}}})}function pad1d_(e,t,n){return void 0===n&&(n=0),assert(2===t.length,\"Invalid number of paddings. Must be length of 2.\"),pad(e,[t],n)}function pad2d_(e,t,n){return void 0===n&&(n=0),assert(2===t.length&&2===t[0].length&&2===t[1].length,\"Invalid number of paddings. Must be length of 2 each.\"),pad(e,t,n)}function pad3d_(e,t,n){return void 0===n&&(n=0),assert(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,\"Invalid number of paddings. Must be length of 2 each.\"),pad(e,t,n)}function pad4d_(e,t,n){return void 0===n&&(n=0),assert(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,\"Invalid number of paddings. Must be length of 2 each.\"),pad(e,t,n)}function pad_(e,t,n){void 0===n&&(n=0);var r=convertToTensor(e,\"x\",\"pad\");if(0===r.rank)throw new Error(\"pad(scalar) is not defined. Pass non-scalar to pad\");var o=t.map(function(e){return e[0]});return ENV.engine.runKernel(function(e){return e.pad(r,t,n)},{$x:r},function(e){return {$x:function(){return e.slice(o,r.shape)}}})}function stack_(e,t){void 0===t&&(t=0);var n=convertToTensorArray(e,\"tensors\",\"stack\");if(assert(n.length>=1,\"Pass at least one tensor to tf.stack\"),1===n.length)return n[0].expandDims(t);var r=n[0].rank,o=n[0].shape,a=n[0].dtype;assert(t<=r,\"Axis must be <= rank of the tensor\"),n.forEach(function(e){assertShapesMatch(o,e.shape,\"All tensors passed to stack must have matching shapes\");}),n.forEach(function(e){assert(a===e.dtype,\"All tensors passed to stack must have matching dtypes\");});var i=n.map(function(e){return e.expandDims(t)});return concat(i,t)}function batchToSpaceND_(e,t,n){var r=convertToTensor(e,\"x\",\"batchToSpaceND\"),o=t.reduce(function(e,t){return e*t});assert(r.rank>=1+t.length,\"input rank is \"+r.rank+\" but should be > than blockShape.length \"+t.length),assert(n.length===t.length,\"crops.length is \"+n.length+\" but should be equal to blockShape.length  \"+t.length),assert(r.shape[0]%o==0,\"input tensor batch is \"+r.shape[0]+\" but is not divisible by the product of the elements of blockShape \"+t.join(\" * \")+\" === \"+o);return ENV.engine.runKernel(function(e){return e.batchToSpaceND(r,t,n)},{$x:r},function(e){return {$x:function(){return e.spaceToBatchND(t,n)}}})}function spaceToBatchND_(e,t,n){var r=convertToTensor(e,\"x\",\"spaceToBatchND\");assert(r.rank>=1+t.length,\"input rank \"+r.rank+\" should be > than [blockShape] \"+t.length),assert(n.length===t.length,\"paddings.shape[0] \"+n.length+\" must be equal to [blockShape] \"+t.length),assert(r.shape.reduce(function(e,r,o){return o>0&&o<=t.length?e&&(r+n[o-1][0]+n[o-1][1])%t[o-1]==0:e},!0),\"input spatial dimensions \"+r.shape.slice(1)+\" with paddings \"+n.toString()+\" must be divisible by blockShapes \"+t.toString());return ENV.engine.runKernel(function(e){return e.spaceToBatchND(r,t,n)},{$x:r},function(e){return {$x:function(){return e.batchToSpaceND(t,n)}}})}function unstack_(e,t){void 0===t&&(t=0);for(var n,r=convertToTensor(e,\"x\",\"unstack\"),o=r.shape[t],a=Array(r.rank-1).fill(0),i=0,s=0;s<r.rank;s++)s!==t&&(a[i]=r.shape[s],i++);n=Array(o).fill(1);var u=Array(r.rank).fill(0),l=r.shape.slice();return n.map(function(e){l[t]=e;var n=r.slice(u,l);return u[t]+=e,n.reshape(a)})}function cumsum_(e,t,n,r){void 0===t&&(t=0),void 0===n&&(n=!1),void 0===r&&(r=!1);var o=convertToTensor(e,\"x\",\"cumsum\"),a=getAxesPermutation([t|=0],o.rank),i=o;null!=a&&(i=o.transpose(a));var s=getInnerMostAxes(1,o.rank)[0],u=ENV.engine.runKernel(function(e){return e.cumsum(i,s,n,r)},{permutedX:i},function(e){return {permutedX:function(){return e.cumsum(t,n,!r)}}});return null!=a&&(u=u.transpose(a)),u}function expandDims_(e,t){void 0===t&&(t=0);var n=convertToTensor(e,\"x\",\"expandDims\");assert(t<=n.rank,\"Axis must be <= rank of the tensor\");var r=n.shape.slice();return t<0&&(assert(-(n.rank+1)<=t,\"Axis must be in the interval [\"+-(n.rank+1)+\", \"+n.rank+\"]\"),t=n.rank+t+1),r.splice(t,0,1),reshape(n,r)}function depthToSpace_(e,t,n){void 0===n&&(n=\"NHWC\");var r=convertToTensor(e,\"x\",\"depthToSpace\"),o=\"NHWC\"===n?r.shape[1]:r.shape[2],a=\"NHWC\"===n?r.shape[2]:r.shape[3],i=\"NHWC\"===n?r.shape[3]:r.shape[1];return assert(o*t>=0,\"Negative dimension size caused by overflow when multiplying\\n      \"+o+\" and \"+t+\"  for depthToSpace with input shape\\n      \"+r.shape),assert(a*t>=0,\"Negative dimension size caused by overflow when multiplying\\n      \"+a+\" and \"+t+\" for depthToSpace with input shape\\n          \"+r.shape),assert(i%(t*t)==0,\"Dimension size must be evenly divisible by \"+t*t+\" but is \"+i+\" for depthToSpace with input shape \"+r.shape),ENV.engine.runKernel(function(e){return e.depthToSpace(r,t,n)},{$x:r})}function setdiff1dAsync_(e,t){return __awaiter(this,void 0,void 0,function(){var n,r,o,a,i,s,u,l,c,p;return __generator(this,function(d){switch(d.label){case 0:return n=convertToTensor(e,\"x\",\"setdiff1d\"),r=convertToTensor(t,\"y\",\"setdiff1d\"),assert(n.dtype===r.dtype,\"x and y should have the same dtype, but got x (\"+n.dtype+\") and y (\"+r.dtype+\").\"),assert(1===n.rank,\"x should be 1D tensor, but got x (\"+n.shape+\").\"),assert(1===r.rank,\"y should be 1D tensor, but got y (\"+r.shape+\").\"),[4,n.data()];case 1:return o=d.sent(),[4,r.data()];case 2:for(a=d.sent(),i=new Set(a),s=0,c=0;c<o.length;c++)i.has(o[c])||s++;for(u=new TensorBuffer([s],n.dtype),l=new TensorBuffer([s],\"int32\"),c=0,p=0;c<o.length;c++)i.has(o[c])||(u.values[p]=o[c],l.values[p]=c,p++);return [2,[u.toTensor(),l.toTensor()]]}})})}function buffer(e,t,n){return void 0===t&&(t=\"float32\"),new TensorBuffer(e,t=t||\"float32\",n)}function print(e,t){void 0===t&&(t=!1),console.log(e.toString(t));}var batchToSpaceND=op({batchToSpaceND_:batchToSpaceND_}),cast=op({cast_:cast_}),clone=op({clone_:clone_}),cumsum=op({cumsum_:cumsum_}),depthToSpace=op({depthToSpace_:depthToSpace_}),expandDims=op({expandDims_:expandDims_}),eye=op({eye_:eye_}),fromPixels=op({fromPixels_:fromPixels_}),multinomial=op({multinomial_:multinomial_}),oneHot=op({oneHot_:oneHot_}),pad=op({pad_:pad_}),pad1d=op({pad1d_:pad1d_}),pad2d=op({pad2d_:pad2d_}),pad3d=op({pad3d_:pad3d_}),pad4d=op({pad4d_:pad4d_}),rand=op({rand_:rand_}),randomNormal=op({randomNormal_:randomNormal_}),randomUniform=op({randomUniform_:randomUniform_}),reshape=op({reshape_:reshape_}),spaceToBatchND=op({spaceToBatchND_:spaceToBatchND_}),squeeze=op({squeeze_:squeeze_}),stack=op({stack_:stack_}),tile=op({tile_:tile_}),truncatedNormal=op({truncatedNormal_:truncatedNormal_}),unstack=op({unstack_:unstack_}),setdiff1dAsync=setdiff1dAsync_;function whereImpl(e,t){for(var n=[],r=0;r<t.length;r++)t[r]&&n.push(r);var o=buffer(e,\"int32\"),a=buffer([n.length,e.length],\"int32\");for(r=0;r<n.length;r++){var i=o.indexToLoc(n[r]),s=r*e.length;a.values.set(i,s);}return a.toTensor()}var CPU_HANDOFF_SIZE_THRESHOLD=10,BEFORE_PAGING_CONSTANT=300,MATMUL_SHARED_DIM_THRESHOLD=1e3,MathBackendWebGL=function(){function e(e,t){if(void 0===t&&(t=!0),this.gpgpu=e,this.delayedStorage=t,this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.lruDataGPU=[],this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.binaryCache={},this.disposed=!1,ENV.get(\"WEBGL_VERSION\")<1)throw new Error(\"WebGL is not supported on this device\");if(null==e){var n=getWebGLContext(ENV.get(\"WEBGL_VERSION\"));this.gpgpu=new GPGPUContext(n),this.canvas=n.canvas,this.gpgpuCreatedLocally=!0;}else this.gpgpuCreatedLocally=!1,this.canvas=e.gl.canvas;ENV.get(\"WEBGL_PAGING_ENABLED\")&&(this.NUM_BYTES_BEFORE_PAGING=window.screen.height*window.screen.width*window.devicePixelRatio*BEFORE_PAGING_CONSTANT),this.textureManager=new TextureManager(this.gpgpu);}return e.prototype.register=function(e,t,n){if(this.texData.has(e))throw new Error(\"Data buffer is already registered\");this.texData.set(e,{shape:t,dtype:n});},e.prototype.setDataMover=function(e){this.texData=new DataStorage(e);},e.prototype.fromPixels=function(e,t){if(null==e)throw new Error(\"pixels passed to tf.fromPixels() can not be null\");var n=[e.height,e.width],r=[e.height,e.width,t];if(!(e instanceof HTMLVideoElement||e instanceof HTMLImageElement||e instanceof HTMLCanvasElement||e instanceof ImageData))throw new Error(\"pixels passed to tf.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement or ImageData, but was \"+e.constructor.name);if(e instanceof HTMLVideoElement){if(null==this.fromPixels2DContext){if(!ENV.get(\"IS_BROWSER\"))throw new Error(\"Can't read pixels from HTMLImageElement outside the browser.\");if(\"complete\"!==document.readyState)throw new Error(\"The DOM is not ready yet. Please call tf.fromPixels() once the DOM is ready. One way to do that is to add an event listener for `DOMContentLoaded` on the document object\");this.fromPixels2DContext=document.createElement(\"canvas\").getContext(\"2d\");}this.fromPixels2DContext.canvas.width=e.width,this.fromPixels2DContext.canvas.height=e.height,this.fromPixels2DContext.drawImage(e,0,0,e.width,e.height),e=this.fromPixels2DContext.canvas;}var o=this.makeTensorHandle(n,\"int32\");this.texData.get(o.dataId).usage=TextureUsage.PIXELS,this.gpgpu.uploadPixelDataToTexture(this.getTexture(o.dataId),e);var a=new FromPixelsProgram(r),i=this.compileAndRun(a,[o]);return this.disposeData(o.dataId),i},e.prototype.makeTensorHandle=function(e,t){var n={};return this.register(n,e,t),{dataId:n,shape:e,dtype:t}},e.prototype.write=function(e,t){if(null==t)throw new Error(\"MathBackendWebGL.write(): values can not be null\");var n=this.texData.get(e),r=n.texture,o=n.texShape,a=n.usage,i=n.dtype,s=n.isPacked;if(\"complex64\"===i)throw new Error(\"Cannot write to a complex64 dtype. Please use tf.complex(real, imag).\");null!=r&&(this.releaseTexture(e,r,o,a,s),n.texture=null,n.texShape=null),n.usage=TextureUsage.UPLOAD,n.values=t,this.delayedStorage||this.uploadToGPU(e);},e.prototype.readSync=function(e){var t=this.texData.get(e),n=t.values,r=t.dtype,o=t.complexTensors;if(null!=n)return this.convertAndCacheOnCPU(e);if(\"string\"===r)return n;var a,i,s=null!=this.activeTimers;(s&&(a=performance.now()),\"complex64\"===r)?i=mergeRealAndImagArrays(o.real.dataSync(),o.imag.dataSync()):i=this.getValuesFromTexture(e);return s&&(this.downloadWaitMs+=performance.now()-a),this.convertAndCacheOnCPU(e,i)},e.prototype.read=function(e){return __awaiter(this,void 0,void 0,function(){var t,n,r,o,a,i,s,u,l,c,p,d,h,f,m,g,v,y;return __generator(this,function(x){switch(x.label){case 0:if(this.pendingRead.has(e))return r=this.pendingRead.get(e),[2,new Promise(function(e){return r.push(e)})];if(o=this.texData.get(e),a=o.texture,i=o.values,s=o.texShape,u=o.isPacked,l=o.shape,null!=i)return [2,this.convertAndCacheOnCPU(e)];if(this.pendingRead.set(e,[]),!ENV.get(\"WEBGL_DOWNLOAD_FLOAT_ENABLED\")&&2===ENV.get(\"WEBGL_VERSION\"))throw new Error(\"tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.\");return c=s[1],p=s[0],u&&(t=getPackedMatrixTextureShapeWidthHeight(s[0],s[1]),c=t[0],p=t[1]),d=this.gpgpu.maybeCreateBufferFromTexture(a,p,c),[4,this.gpgpu.createAndWaitForFence()];case 1:return x.sent(),d instanceof WebGLTexture?h=this.getValuesFromTexture(e):u?(f=this.getBatchDim(l),m=1,g=1,l.length&&(n=this.getRowsCols(l),m=n[0],g=n[1]),h=this.gpgpu.downloadPackedMatrixFromBuffer(d,f,m,g,s[0],s[1])):h=this.gpgpu.downloadFloat32MatrixFromBuffer(d,s[0],s[1]),v=this.convertAndCacheOnCPU(e,h),y=this.pendingRead.get(e),this.pendingRead.delete(e),y.forEach(function(e){return e(v)}),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)),[2,v]}})})},e.prototype.getValuesFromTexture=function(e){var t,n=this.texData.get(e),r=n.shape,o=n.dtype,a=n.texture,i=n.texShape;if(ENV.get(\"WEBGL_DOWNLOAD_FLOAT_ENABLED\")){if(this.texData.get(e).isPacked){var s=this.getBatchDim(r),u=1,l=1;return r.length&&(u=(t=this.getRowsCols(r))[0],l=t[1]),this.gpgpu.downloadMatrixFromPackedTexture(a,s,u,l,i[0],i[1])}return this.gpgpu.downloadFloat32MatrixFromOutputTexture(a,i[0],i[1])}var c=this.makeTensorHandle(r,\"float32\");c.size=sizeFromShape(r),this.texData.get(c.dataId).usage=TextureUsage.DOWNLOAD;var p=new EncodeFloatProgram(r);this.compileAndRun(p,[{shape:r,dtype:o,dataId:e}],c,null,!1);var d=this.texData.get(c.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(d.texture,d.texShape[0],d.texShape[1]);return this.disposeData(c.dataId),h},e.prototype.time=function(e){return __awaiter(this,void 0,void 0,function(){var t,n,r,o,a,i,s;return __generator(this,function(u){switch(u.label){case 0:return t=this.activeTimers,n=[],r=!1,null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,e(),o=flatten(this.activeTimers.map(function(e){return e.query})).filter(function(e){return null!=e}),a=flatten(this.activeTimers.map(function(e){return e.name})).filter(function(e){return null!=e}),this.activeTimers=t,r&&(this.programTimersStack=null),[4,Promise.all(o)];case 1:return i=u.sent(),s={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:sum(i),getExtraProfileInfo:function(){return i.map(function(e,t){return {name:a[t],ms:e}}).map(function(e){return e.name+\": \"+e.ms}).join(\", \")},wallMs:null},this.uploadWaitMs=0,this.downloadWaitMs=0,[2,s]}})})},e.prototype.memory=function(){return {unreliable:!1,numBytesInGPU:this.numBytesInGPU}},e.prototype.startTimer=function(){return ENV.get(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\")>0?this.gpgpu.beginQuery():{startMs:performance.now(),endMs:null}},e.prototype.endTimer=function(e){return ENV.get(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\")>0?(this.gpgpu.endQuery(),e):(e.endMs=performance.now(),e)},e.prototype.getQueryTime=function(e){return __awaiter(this,void 0,void 0,function(){var t;return __generator(this,function(n){return ENV.get(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\")>0?[2,this.gpgpu.waitForQueryAndGetTime(e)]:[2,(t=e).endMs-t.startMs]})})},e.prototype.disposeData=function(e){if(!this.pendingDisposal.has(e))if(this.pendingRead.has(e))this.pendingDisposal.add(e);else if(this.texData.has(e)){var t=this.texData.get(e),n=t.texture,r=t.texShape,o=t.usage,a=t.complexTensors,i=t.isPacked;null!=n&&this.releaseTexture(e,n,r,o,i),null!=a&&(a.real.dispose(),a.imag.dispose()),this.texData.delete(e);}},e.prototype.getTexture=function(e){return this.uploadToGPU(e),this.texData.get(e).texture},e.prototype.getCPUBackend=function(){return ENV.get(\"WEBGL_CPU_FORWARD\")?(null==this.cpuBackend&&(this.cpuBackend=ENV.findBackend(\"cpu\")),this.cpuBackend):null},e.prototype.shouldExecuteOnCPU=function(e,t){var n=this;return void 0===t&&(t=CPU_HANDOFF_SIZE_THRESHOLD),null!=this.getCPUBackend()&&e.every(function(e){return null==n.texData.get(e.dataId).texture&&e.size<t})},e.prototype.getGPGPUContext=function(){return this.gpgpu},e.prototype.getCanvas=function(){return this.canvas},e.prototype.complex=function(e,t){var n=this.makeOutputArray(e.shape,\"complex64\");return this.texData.get(n.dataId).complexTensors={real:ENV.engine.keep(e.clone()),imag:ENV.engine.keep(t.clone())},n},e.prototype.real=function(e){return this.texData.get(e.dataId).complexTensors.real.clone()},e.prototype.imag=function(e){return this.texData.get(e.dataId).complexTensors.imag.clone()},e.prototype.slice=function(e,t,n){if(this.shouldExecuteOnCPU([e]))return this.cpuBackend.slice(e,t,n);var r=new SliceProgram(n),o=r.getCustomSetupFunc(t);return this.compileAndRun(r,[e],null,o)},e.prototype.stridedSlice=function(e,t,n,r,o,a,i,s,u){if(this.shouldExecuteOnCPU([e]))return this.cpuBackend.stridedSlice(e,t,n,r,o,a,i,s,u);var l=getStridedSlicedInfo(e.shape,t,n,r,o,a,i,s,u),c=l[0],p=l[1],d=l[2],h=p.filter(function(e,t){return -1===d.indexOf(t)});if(h.some(function(e){return 0===e}))return tensor([],h);var f=new StridedSliceProgram(c,r,p,d);return this.compileAndRun(f,[e])},e.prototype.reverse=function(e,t){var n=new ReverseProgram(e.shape,t);return this.compileAndRun(n,[e])},e.prototype.concat2Tensors=function(e,t,n){var r=computeOutShape([e.shape,t.shape],n),o=e.as2D(-1,sizeFromShape(e.shape.slice(n))),a=t.as2D(-1,sizeFromShape(t.shape.slice(n))),i=new ConcatProgram(o.shape,a.shape);return this.compileAndRun(i,[o,a]).reshape(r)},e.prototype.concat=function(e,t){if(this.shouldExecuteOnCPU(e))return this.cpuBackend.concat(e,t);if(1===e.length)return e[0];for(var n=e[0],r=1;r<e.length;++r)n=this.concat2Tensors(n,e[r],t);return n},e.prototype.neg=function(e){var t=new UnaryOpProgram(e.shape,NEG);return this.compileAndRun(t,[e])},e.prototype.batchMatMul=function(e,t,n,r){var o=n?e.shape[2]:e.shape[1],a=r?t.shape[1]:t.shape[2],i=n?e.shape[1]:e.shape[2],s=e.shape[0];if((1===o||1===a)&&i>MATMUL_SHARED_DIM_THRESHOLD){n&&(e=e.transpose([0,2,1])),r&&(t=t.transpose([0,2,1]));var u=1===a?e:e.as3D(s,i,1),l=1===a?2:1,c=1===a?t.as3D(s,1,i):t;return this.multiply(u,c).sum(l,!0)}var p=upcastType(e.dtype,t.dtype);if(1===s){var d=e.as2D(e.shape[1],e.shape[2]),h=t.as2D(t.shape[1],t.shape[2]),f=new MatMulPackedProgram(d.shape,h.shape,[o,a],n,r),m=this.makePackedTensor(f.outputShape,p),g=this.compileAndRun(f,[d,h],m);return g.reshape([1,g.shape[0],g.shape[1]])}f=new MatMulProgram(e.shape,t.shape,n,r),m=this.makeOutputArray(f.outputShape,p);return this.compileAndRun(f,[e,t],m)},e.prototype.multiply=function(e,t){if(\"complex64\"===e.dtype){var n=this.texData.get(e.dataId),r=this.texData.get(t.dataId),o=new BinaryOpComplexProgram(COMPLEX_MULTIPLY.REAL,e.shape,t.shape),a=new BinaryOpComplexProgram(COMPLEX_MULTIPLY.IMAG,e.shape,t.shape),i=[this.makeComplexComponentTensorHandle(e,n.complexTensors.real),this.makeComplexComponentTensorHandle(e,n.complexTensors.imag),this.makeComplexComponentTensorHandle(t,r.complexTensors.real),this.makeComplexComponentTensorHandle(t,r.complexTensors.imag)],s=this.compileAndRun(o,i),u=this.compileAndRun(a,i),l=this.complex(s,u);return s.dispose(),u.dispose(),l}if(this.shouldExecuteOnCPU([e,t]))return this.cpuBackend.multiply(e,t);var c=new BinaryOpProgram(MUL,e.shape,t.shape),p=this.makeOutputArray(c.outputShape,e.dtype);return this.compileAndRun(c,[e,t],p)},e.prototype.batchNormalization=function(e,t,n,r,o,a){var i=[e,t,n],s=null;null!=a&&(s=a.shape,i.push(a));var u=null;if(null!=o&&(u=o.shape,i.push(o)),ENV.get(\"WEBGL_PACK_BATCHNORMALIZATION\")){var l=new BatchNormPackedProgram(e.shape,t.shape,n.shape,s,u,r);return this.compileAndRun(l,i)}var c=new BatchNormProgram(e.shape,t.shape,n.shape,s,u,r);return this.compileAndRun(c,i)},e.prototype.localResponseNormalization4D=function(e,t,n,r,o){var a=new LRNProgram(e.shape,t,n,r,o);return this.compileAndRun(a,[e])},e.prototype.LRNGrad=function(e,t,n,r,o,a,i){var s=new LRNGradProgram(t.shape,r,o,a,i);return this.compileAndRun(s,[t,n,e])},e.prototype.tile=function(e,t){var n=new TileProgram(e.shape,t);return this.compileAndRun(n,[e])},e.prototype.pad=function(e,t,n){var r=new PadProgram(e.shape,t,n);return this.compileAndRun(r,[e])},e.prototype.transpose=function(e,t){var n=new TransposeProgram(e.shape,t);return this.compileAndRun(n,[e])},e.prototype.gather=function(e,t,n){var r=new GatherProgram(e.shape,t.size,n);return this.compileAndRun(r,[e,t])},e.prototype.batchToSpaceND=function(e,t,n){assert(e.rank<=4,\"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet\");var r=t.reduce(function(e,t){return e*t}),o=getReshaped(e.shape,t,r),a=getPermuted(o.length,t.length),i=getReshapedPermuted(e.shape,t,r),s=getSliceBeginCoords(n,t.length),u=getSliceSize(i,n,t.length);return e.reshape(o).transpose(a).reshape(i).slice(s,u)},e.prototype.spaceToBatchND=function(e,t,n){assert(e.rank<=4,\"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet\");var r=t.reduce(function(e,t){return e*t}),o=[[0,0]];o.push.apply(o,n);for(var a=1+t.length;a<e.shape.length;++a)o.push([0,0]);var i=e.pad(o),s=getReshaped(i.shape,t,r,!1),u=getPermuted(s.length,t.length,!1),l=getReshapedPermuted(i.shape,t,r,!1);return i.reshape(s).transpose(u).reshape(l)},e.prototype.reduce=function(e,t,n){var r=e.shape[0],o=e.shape[1],a=computeOptimalWindowSize(o),i=new ReduceProgram({windowSize:a,inSize:o,batchSize:r},t),s=i.outputShape,u=s[0],l=s[1],c=this.makeOutputArray([u,l],n);return this.compileAndRun(i,[e],c),1===c.shape[1]?c:this.reduce(c,t,n)},e.prototype.argReduce=function(e,t,n){void 0===n&&(n=null);var r=e.shape[0],o=e.shape[1];null!=n&&(r=n.shape[0],o=n.shape[1]);var a=computeOptimalWindowSize(o),i=new ArgMinMaxProgram({windowSize:a,inSize:o,batchSize:r},t,null==n),s=i.outputShape,u=s[0],l=s[1],c=this.makeOutputArray([u,l],\"int32\"),p=[e];return null!=n&&p.push(n),this.compileAndRun(i,p,c),1===c.shape[1]?c:this.argReduce(e,t,c)},e.prototype.sum=function(e,t){assertAxesAreInnerMostDims(\"sum\",t,e.rank);var n=computeOutAndReduceShapes(e.shape,t),r=n[0],o=sizeFromShape(n[1]),a=e.as2D(-1,o),i=sumOutType(e.dtype);return this.reduce(a,\"sum\",i).reshape(r)},e.prototype.prod=function(e,t){var n=computeOutAndReduceShapes(e.shape,t),r=n[0],o=sizeFromShape(n[1]),a=e.as2D(-1,o),i=sumOutType(e.dtype);return this.reduce(a,\"prod\",i).reshape(r)},e.prototype.unsortedSegmentSum=function(e,t,n){var r=0,o=getAxesPermutation([r],e.rank),a=e;null!=o&&(a=e.transpose(o),r=getInnerMostAxes(1,e.rank)[0]);var i=computeOutShape$1(a.shape,r,n),s=sizeFromShape([a.shape[r]]),u=a.as2D(-1,s),l=sumOutType(e.dtype),c=this.segOpCompute(u,\"unsortedSegmentSum\",t,l,n).reshape(i);return null!=o&&(c=c.transpose(getUndoAxesPermutation(o))),c},e.prototype.segOpCompute=function(e,t,n,r,o){var a=e.shape[0],i=e.shape[1],s=segOpComputeOptimalWindowSize(i,o),u=new SegmentOpProgram({windowSize:s,inSize:i,batchSize:a,numSegments:o},t),l=u.outputShape,c=l[0],p=l[1],d=this.makeOutputArray([c,p],r);return this.compileAndRun(u,[e,n],d),d.shape[1]===o?d:(n=range(0,o).tile([i/s]),this.segOpCompute(d,t,n,r,o))},e.prototype.argMin=function(e,t){var n=[t];assertAxesAreInnerMostDims(\"argMin\",n,e.rank);var r=computeOutAndReduceShapes(e.shape,n),o=r[0],a=sizeFromShape(r[1]),i=e.as2D(-1,a);return this.argReduce(i,\"min\").reshape(o)},e.prototype.argMax=function(e,t){var n=[t];assertAxesAreInnerMostDims(\"argMax\",n,e.rank);var r=computeOutAndReduceShapes(e.shape,n),o=r[0],a=sizeFromShape(r[1]),i=e.as2D(-1,a);return this.argReduce(i,\"max\").reshape(o)},e.prototype.cumsum=function(e,t,n,r){if(t!==e.rank-1)throw new Error(\"WebGL cumsum shader expects an inner-most axis=\"+(e.rank-1)+\" but got axis=\"+t);var o=new CumSumProgram(e.shape,n,r);return this.compileAndRun(o,[e])},e.prototype.equal=function(e,t){var n=new BinaryOpProgram(EQUAL,e.shape,t.shape),r=this.makeOutputArray(n.outputShape,\"bool\");return this.compileAndRun(n,[e,t],r)},e.prototype.notEqual=function(e,t){var n=new BinaryOpProgram(NOT_EQUAL,e.shape,t.shape),r=this.makeOutputArray(n.outputShape,\"bool\");return this.compileAndRun(n,[e,t],r)},e.prototype.less=function(e,t){if(this.shouldExecuteOnCPU([e,t]))return this.cpuBackend.less(e,t);var n=new BinaryOpProgram(LESS,e.shape,t.shape),r=this.makeOutputArray(n.outputShape,\"bool\");return this.compileAndRun(n,[e,t],r)},e.prototype.lessEqual=function(e,t){var n=new BinaryOpProgram(LESS_EQUAL,e.shape,t.shape),r=this.makeOutputArray(n.outputShape,\"bool\");return this.compileAndRun(n,[e,t],r)},e.prototype.greater=function(e,t){if(this.shouldExecuteOnCPU([e,t]))return this.cpuBackend.greater(e,t);var n=new BinaryOpProgram(GREATER,e.shape,t.shape),r=this.makeOutputArray(n.outputShape,\"bool\");return this.compileAndRun(n,[e,t],r)},e.prototype.greaterEqual=function(e,t){var n=new BinaryOpProgram(GREATER_EQUAL,e.shape,t.shape),r=this.makeOutputArray(n.outputShape,\"bool\");return this.compileAndRun(n,[e,t],r)},e.prototype.logicalNot=function(e){var t=new UnaryOpProgram(e.shape,LOGICAL_NOT);return this.compileAndRun(t,[e])},e.prototype.logicalAnd=function(e,t){var n=new BinaryOpProgram(LOGICAL_AND,e.shape,t.shape),r=this.makeOutputArray(n.outputShape,\"bool\");return this.compileAndRun(n,[e,t],r)},e.prototype.logicalOr=function(e,t){var n=new BinaryOpProgram(LOGICAL_OR,e.shape,t.shape),r=this.makeOutputArray(n.outputShape,\"bool\");return this.compileAndRun(n,[e,t],r)},e.prototype.select=function(e,t,n){var r=new SelectProgram(e.rank,t.shape,t.rank),o=this.makeOutputArray(r.outputShape,upcastType(t.dtype,n.dtype));return this.compileAndRun(r,[e,t,n],o)},e.prototype.where=function(e){warn(\"tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead\");var t=e.dataSync();return whereImpl(e.shape,t)},e.prototype.topk=function(e,t,n){return topkImpl(e.dataSync(),e.shape,e.dtype,t,n)},e.prototype.min=function(e,t){assertAxesAreInnerMostDims(\"min\",t,e.rank);var n=computeOutAndReduceShapes(e.shape,t),r=n[0],o=sizeFromShape(n[1]),a=e.as2D(-1,o);return this.reduce(a,\"min\",a.dtype).reshape(r)},e.prototype.minimum=function(e,t){if(this.shouldExecuteOnCPU([e,t]))return this.cpuBackend.minimum(e,t);var n=new BinaryOpProgram(MIN,e.shape,t.shape);return this.compileAndRun(n,[e,t])},e.prototype.mod=function(e,t){var n=new BinaryOpProgram(MOD,e.shape,t.shape),r=n.getCustomSetupFunc();return this.compileAndRun(n,[e,t],null,r)},e.prototype.max=function(e,t){assertAxesAreInnerMostDims(\"max\",t,e.rank);var n=computeOutAndReduceShapes(e.shape,t),r=n[0],o=sizeFromShape(n[1]),a=e.as2D(-1,o);return this.reduce(a,\"max\",a.dtype).reshape(r)},e.prototype.maximum=function(e,t){if(this.shouldExecuteOnCPU([e,t]))return this.cpuBackend.maximum(e,t);var n=new BinaryOpProgram(MAX,e.shape,t.shape);return this.compileAndRun(n,[e,t])},e.prototype.all=function(e,t){assertAxesAreInnerMostDims(\"all\",t,e.rank);var n=computeOutAndReduceShapes(e.shape,t),r=n[0],o=sizeFromShape(n[1]),a=e.as2D(-1,o);return this.reduce(a,\"all\",a.dtype).reshape(r)},e.prototype.any=function(e,t){assertAxesAreInnerMostDims(\"any\",t,e.rank);var n=computeOutAndReduceShapes(e.shape,t),r=n[0],o=sizeFromShape(n[1]),a=e.as2D(-1,o);return this.reduce(a,\"any\",a.dtype).reshape(r)},e.prototype.squaredDifference=function(e,t){var n=new BinaryOpProgram(SQUARED_DIFFERENCE,e.shape,t.shape);return this.compileAndRun(n,[e,t])},e.prototype.realDivide=function(e,t){var n=new BinaryOpProgram(DIV,e.shape,t.shape),r=this.makeOutputArray(n.outputShape,\"float32\");return this.compileAndRun(n,[e,t],r)},e.prototype.floorDiv=function(e,t){var n=new BinaryOpProgram(INT_DIV,e.shape,t.shape),r=this.makeOutputArray(n.outputShape,\"int32\");return this.compileAndRun(n,[e,t],r)},e.prototype.add=function(e,t){if(\"complex64\"===e.dtype&&\"complex64\"===t.dtype)return this.complexSeparableBinaryOp(e,t,ADD);var n=new BinaryOpProgram(ADD,e.shape,t.shape),r=this.makeOutputArray(n.outputShape,upcastType(e.dtype,t.dtype));return this.compileAndRun(n,[e,t],r)},e.prototype.complexSeparableBinaryOp=function(e,t,n){var r=this,o=this.texData.get(e.dataId),a=this.texData.get(t.dataId),i=[[o.complexTensors.real,a.complexTensors.real],[o.complexTensors.imag,a.complexTensors.imag]].map(function(o){var a=o[0],i=o[1],s=new BinaryOpProgram(n,e.shape,t.shape),u=r.makeOutputArray(s.outputShape,upcastType(a.dtype,i.dtype)),l=r.makeComplexComponentTensorHandle(e,a),c=r.makeComplexComponentTensorHandle(t,i);return r.compileAndRun(s,[l,c],u)}),s=i[0],u=i[1],l=this.complex(s,u);return s.dispose(),u.dispose(),l},e.prototype.makeComplexComponentTensorHandle=function(e,t){return {dataId:t.dataId,dtype:t.dtype,shape:e.shape}},e.prototype.addN=function(e){for(var t=e[0],n=1;n<e.length;n++)t=this.add(t,e[n]);return t},e.prototype.subtract=function(e,t){if(\"complex64\"===e.dtype&&\"complex64\"===t.dtype)return this.complexSeparableBinaryOp(e,t,SUB);if(this.shouldExecuteOnCPU([e,t]))return this.cpuBackend.subtract(e,t);var n=new BinaryOpProgram(SUB,e.shape,t.shape),r=this.makeOutputArray(n.outputShape,upcastType(e.dtype,t.dtype));return this.compileAndRun(n,[e,t],r)},e.prototype.pow=function(e,t){var n=new BinaryOpProgram(POW,e.shape,t.shape),r=n.getCustomSetupFunc(),o=this.makeOutputArray(n.outputShape,upcastType(e.dtype,t.dtype));return this.compileAndRun(n,[e,t],o,r)},e.prototype.ceil=function(e){var t=new UnaryOpProgram(e.shape,CEIL);return this.compileAndRun(t,[e])},e.prototype.floor=function(e){var t=new UnaryOpProgram(e.shape,FLOOR);return this.compileAndRun(t,[e])},e.prototype.sign=function(e){var t=new UnaryOpProgram(e.shape,SIGN);return this.compileAndRun(t,[e])},e.prototype.round=function(e){var t=new UnaryOpProgram(e.shape,ROUND);return this.compileAndRun(t,[e])},e.prototype.exp=function(e){var t=new UnaryOpProgram(e.shape,EXP);return this.compileAndRun(t,[e])},e.prototype.expm1=function(e){var t=new UnaryOpProgram(e.shape,EXPM1);return this.compileAndRun(t,[e])},e.prototype.log=function(e){var t=new UnaryOpProgram(e.shape,LOG),n=t.getCustomSetupFunc();return this.compileAndRun(t,[e],null,n)},e.prototype.log1p=function(e){var t=new UnaryOpProgram(e.shape,LOG1P);return this.compileAndRun(t,[e])},e.prototype.sqrt=function(e){var t=new UnaryOpProgram(e.shape,SQRT);return this.compileAndRun(t,[e])},e.prototype.rsqrt=function(e){var t=new UnaryOpProgram(e.shape,RSQRT);return this.compileAndRun(t,[e])},e.prototype.square=function(e){var t=new UnaryOpProgram(e.shape,SQUARE);return this.compileAndRun(t,[e])},e.prototype.reciprocal=function(e){var t=new UnaryOpProgram(e.shape,RECIPROCAL);return this.compileAndRun(t,[e])},e.prototype.relu=function(e){var t=new UnaryOpProgram(e.shape,RELU);return this.compileAndRun(t,[e])},e.prototype.elu=function(e){var t=new UnaryOpProgram(e.shape,ELU);return this.compileAndRun(t,[e])},e.prototype.eluDer=function(e,t){var n=new BinaryOpProgram(ELU_DER,e.shape,t.shape);return this.compileAndRun(n,[e,t])},e.prototype.selu=function(e){var t=new UnaryOpProgram(e.shape,SELU);return this.compileAndRun(t,[e])},e.prototype.int=function(e){var t=new UnaryOpProgram(e.shape,TO_INT),n=this.makeOutputArray(t.outputShape,\"int32\");return this.compileAndRun(t,[e],n)},e.prototype.clip=function(e,t,n){var r;return r=ENV.get(\"WEBGL_PACK_CLIP\")?new ClipPackedProgram(e.shape,t,n):new ClipProgram(e.shape,t,n),this.compileAndRun(r,[e])},e.prototype.abs=function(e){var t=new UnaryOpProgram(e.shape,ABS);return this.compileAndRun(t,[e])},e.prototype.complexAbs=function(e){var t=this.texData.get(e.dataId),n=new ComplexAbsProgram(e.shape),r=[this.makeComplexComponentTensorHandle(e,t.complexTensors.real),this.makeComplexComponentTensorHandle(e,t.complexTensors.imag)];return this.compileAndRun(n,r)},e.prototype.sigmoid=function(e){var t=new UnaryOpProgram(e.shape,SIGMOID);return this.compileAndRun(t,[e])},e.prototype.softplus=function(e){var t=new UnaryOpProgram(e.shape,SOFTPLUS);return this.compileAndRun(t,[e])},e.prototype.sin=function(e){var t=new UnaryOpProgram(e.shape,SIN);return this.compileAndRun(t,[e])},e.prototype.cos=function(e){var t=new UnaryOpProgram(e.shape,COS);return this.compileAndRun(t,[e])},e.prototype.tan=function(e){var t=new UnaryOpProgram(e.shape,TAN);return this.compileAndRun(t,[e])},e.prototype.asin=function(e){var t=new UnaryOpProgram(e.shape,ASIN);return this.compileAndRun(t,[e])},e.prototype.acos=function(e){var t=new UnaryOpProgram(e.shape,ACOS);return this.compileAndRun(t,[e])},e.prototype.atan=function(e){var t=new UnaryOpProgram(e.shape,ATAN);return this.compileAndRun(t,[e])},e.prototype.atan2=function(e,t){var n=new BinaryOpProgram(ATAN2,e.shape,t.shape);return this.compileAndRun(n,[e,t])},e.prototype.sinh=function(e){var t=new UnaryOpProgram(e.shape,SINH);return this.compileAndRun(t,[e])},e.prototype.cosh=function(e){var t=new UnaryOpProgram(e.shape,COSH);return this.compileAndRun(t,[e])},e.prototype.tanh=function(e){var t=new UnaryOpProgram(e.shape,TANH);return this.compileAndRun(t,[e])},e.prototype.asinh=function(e){var t=new UnaryOpProgram(e.shape,ASINH);return this.compileAndRun(t,[e])},e.prototype.acosh=function(e){var t=new UnaryOpProgram(e.shape,ACOSH),n=t.getCustomSetupFunc();return this.compileAndRun(t,[e],null,n)},e.prototype.atanh=function(e){var t=new UnaryOpProgram(e.shape,ATANH),n=t.getCustomSetupFunc();return this.compileAndRun(t,[e],null,n)},e.prototype.erf=function(e){var t=new UnaryOpProgram(e.shape,ERF);return this.compileAndRun(t,[e])},e.prototype.step=function(e,t){var n=new UnaryOpProgram(e.shape,STEP(t));return this.compileAndRun(n,[e])},e.prototype.conv2dWithIm2Row=function(e,t,n){var r=n.filterWidth,o=n.filterHeight,a=n.inChannels,i=n.outWidth,s=n.outHeight,u=r*o*a,l=s*i,c=[u,l],p=e.squeeze([0]),d=t.reshape([u,-1]),h=new Im2ColProgram(c,p.shape,n),f=this.compileAndRun(h,[p]),m=new MatMulPackedProgram(f.shape,d.shape,[l,n.outChannels],!0,!1);return this.compileAndRun(m,[f,d]).reshape([1,s,i,n.outChannels])},e.prototype.conv2d=function(e,t,n){if(ENV.get(\"WEBGL_CONV_IM2COL\")&&1===e.shape[0])return this.conv2dWithIm2Row(e,t,n);var r=new Conv2DProgram(n);return this.compileAndRun(r,[e,t])},e.prototype.conv2dDerInput=function(e,t,n){var r=new Conv2DDerInputProgram(n);return this.compileAndRun(r,[e,t])},e.prototype.conv2dDerFilter=function(e,t,n){var r=new Conv2DDerFilterProgram(n);return this.compileAndRun(r,[e,t])},e.prototype.depthwiseConv2D=function(e,t,n){var r;return ENV.get(\"WEBGL_PACK_DEPTHWISECONV\")&&1===n.dilationWidth&&1===n.dilationHeight&&n.padInfo.left<=1&&n.strideWidth<=2&&n.outChannels/n.inChannels==1?(r=new DepthwiseConvPacked2DProgram(n),this.compileAndRun(r,[e,t],this.makePackedTensor(n.outShape,e.dtype))):(r=new DepthwiseConv2DProgram(n),this.compileAndRun(r,[e,t]))},e.prototype.depthwiseConv2DDerInput=function(e,t,n){var r=new DepthwiseConv2DDerInputProgram(n);return this.compileAndRun(r,[e,t])},e.prototype.depthwiseConv2DDerFilter=function(e,t,n){var r=new DepthwiseConv2DDerFilterProgram(n);return this.compileAndRun(r,[e,t])},e.prototype.conv3d=function(e,t,n){var r=new Conv3DProgram(n);return this.compileAndRun(r,[e,t])},e.prototype.conv3dDerInput=function(e,t,n){var r=new Conv3DDerInputProgram(n);return this.compileAndRun(r,[e,t])},e.prototype.conv3dDerFilter=function(e,t,n){var r=new Conv3DDerFilterProgram(n);return this.compileAndRun(r,[e,t])},e.prototype.maxPool=function(e,t){var n=new Pool2DProgram(t,\"max\",!1),r=this.makeOutputArray(n.outputShape,e.dtype);return this.compileAndRun(n,[e],r)},e.prototype.avgPool=function(e,t){var n=new Pool2DProgram(t,\"avg\",!1),r=this.makeOutputArray(n.outputShape,\"float32\");return this.compileAndRun(n,[e],r)},e.prototype.maxPoolBackprop=function(e,t,n,r){var o=new Pool2DProgram(r,\"max\",!0),a=this.compileAndRun(o,[t]),i=new MaxPool2DBackpropProgram(r),s=this.makeOutputArray(i.outputShape,t.dtype),u=this.compileAndRun(i,[e,a],s);return a.dispose(),u},e.prototype.avgPoolBackprop=function(e,t,n){var r=new AvgPool2DBackpropProgram(n),o=this.makeOutputArray(r.outputShape,t.dtype);return this.compileAndRun(r,[e],o)},e.prototype.cast=function(e,t){return castTensor(e,t,this)},e.prototype.reshape=function(e,t){return this.texData.get(e.dataId).isPacked&&!isReshapeFree(e.shape,t)?this.packedReshape(e,t):reshapeTensor(e,t)},e.prototype.resizeBilinear=function(e,t,n,r){var o=new ResizeBilinearProgram(e.shape,t,n,r);return this.compileAndRun(o,[e])},e.prototype.resizeBilinearBackprop=function(e,t,n){var r=new ResizeBilinearBackpropProgram(e,t,n);return this.compileAndRun(r,[e])},e.prototype.resizeNearestNeighbor=function(e,t,n,r){var o=new ResizeNearestNeighborProgram(e.shape,t,n,r);return this.compileAndRun(o,[e])},e.prototype.resizeNearestNeighborBackprop=function(e,t,n){var r=new ResizeNearestNeigborBackpropProgram(e,t,n);return this.compileAndRun(r,[e])},e.prototype.multinomial=function(e,t,n,r){var o=t?e:softmax(e),a=o.shape[0],i=o.shape[1],s=new MultinomialProgram(a,i,n),u=this.makeOutputArray(s.outputShape,\"int32\"),l=s.getCustomSetupFunc(r);return this.compileAndRun(s,[o],u,l)},e.prototype.oneHot=function(e,t,n,r){var o=new OneHotProgram(e.size,t,n,r);return this.compileAndRun(o,[e])},e.prototype.nonMaxSuppression=function(e,t,n,r,o){return warn(\"tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead\"),nonMaxSuppressionImpl(e.dataSync(),t.dataSync(),n,r,o)},e.prototype.cropAndResize=function(e,t,n,r,o,a){var i=new CropAndResizeProgram(e.shape,t.shape,r,o,a);return this.compileAndRun(i,[e,t,n])},e.prototype.depthToSpace=function(e,t,n){assert(t>1,\"blockSize should be > 1 for depthToSpace, but was: \"+t);var r=e.shape[0],o=(\"NHWC\"===n?e.shape[1]:e.shape[2])*t,a=(\"NHWC\"===n?e.shape[2]:e.shape[3])*t,i=(\"NHWC\"===n?e.shape[3]:e.shape[1])/(t*t),s=new DepthToSpaceProgram(\"NHWC\"===n?[r,o,a,i]:[r,i,o,a],t,n);return this.compileAndRun(s,[e])},e.prototype.split=function(e,t,n){return split(e,t,n)},e.prototype.scatterND=function(e,t,n){var r=calculateShapes(t,e,n),o=r.sliceRank,a=r.numUpdates,i=r.sliceSize,s=r.strides,u=r.outputSize,l=[u/i,i],c=e.reshape([a,o]),p=t.reshape([a,i]);if(0===u)return reshapeTensor(tensor([]),n);var d=scalar(0),h=new ScatterProgram(a,o,c.rank,p.rank,s,l);return this.compileAndRun(h,[p,c,d]).reshape(n)},e.prototype.sparseToDense=function(e,t,n,r){var o=calculateShapes(t,e,n),a=o.sliceRank,i=o.numUpdates,s=o.strides,u=o.outputSize,l=new ScatterProgram(i,a,e.rank,t.rank,s,[u,1],!1);return this.compileAndRun(l,[t,e,r]).reshape(n)},e.prototype.fft=function(e){return this.fftImpl(e,!1)},e.prototype.ifft=function(e){return this.fftImpl(e,!0)},e.prototype.fftImpl=function(e,t){var n=this.texData.get(e.dataId),r=new FFTProgram(COMPLEX_FFT.REAL,e.shape,t),o=new FFTProgram(COMPLEX_FFT.IMAG,e.shape,t),a=[this.makeComplexComponentTensorHandle(e,n.complexTensors.real),this.makeComplexComponentTensorHandle(e,n.complexTensors.imag)],i=this.compileAndRun(r,a),s=this.compileAndRun(o,a),u=this.complex(i,s).as2D(e.shape[0],e.shape[1]);return i.dispose(),s.dispose(),u},e.prototype.gatherND=function(e,t){var n=t.shape,r=n[n.length-1],o=prepareAndValidate(e,t),a=o[0],i=o[1],s=o[2],u=o[3],l=t.reshape([i,r]),c=e.reshape([e.size/s,s]),p=new GatherNDProgram(r,u,[i,s]);return this.compileAndRun(p,[c,l]).reshape(a)},e.prototype.makeOutputArray=function(e,t){return Tensor.make(e,{},t)},e.prototype.makePackedTensor=function(e,t){var n=Tensor.make(e,{},t);return this.texData.get(n.dataId).isPacked=!0,n},e.prototype.unpackTensor=function(e){var t=new UnpackProgram(e.shape);return this.compileAndRun(t,[e],Tensor.make(t.outputShape,{},e.dtype))},e.prototype.getBatchDim=function(e,t){return void 0===t&&(t=2),sizeFromShape(e.slice(0,e.length-t))},e.prototype.getRowsCols=function(e){if(0===e.length)throw Error(\"Cannot get rows and columns of an empty shape array.\");return [e.length>1?e[e.length-2]:1,e[e.length-1]]},e.prototype.packedReshape=function(e,t){var n=e.reshape([this.getBatchDim(e.shape)].concat(this.getRowsCols(e.shape))),r=[this.getBatchDim(t)].concat(this.getRowsCols(t)),o=new ReshapePackedProgram(r,n.shape);return this.compileAndRun(o,[n]).reshape(t)},e.prototype.compileAndRun=function(e,t,n,r,o){var a=this;if(void 0===o&&(o=!0),null==n&&(n=e.usesPackedTextures?this.makePackedTensor(e.outputShape,t[0].dtype):this.makeOutputArray(e.outputShape,t[0].dtype)),0===n.size)return this.texData.get(n.dataId).values=getTypedArrayFromDType(n.dtype,0),n;var i=t.map(function(t){if(\"complex64\"===t.dtype)throw new Error(\"GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.\");var n=a.texData.get(t.dataId);if(null==n.texture){if(!e.usesPackedTextures&&sizeFromShape(t.shape)<=ENV.get(\"WEBGL_SIZE_UPLOAD_UNIFORM\"))return {shape:t.shape,texData:null,isUniform:!0,uniformValues:a.readSync(t.dataId)};e.usesPackedTextures&&(n.isPacked=!0,n.shape=t.shape);}else if(!!n.isPacked!=!!e.usesPackedTextures){var r=void 0,o=void 0;n.isPacked?(r=new UnpackProgram(t.shape),o=a.compileAndRun(r,[t],Tensor.make(r.outputShape,{},t.dtype))):(r=new PackProgram(t.shape),o=a.compileAndRun(r,[t],a.makePackedTensor(t.shape,t.dtype))),n=a.texData.get(o.dataId),t=o;}else if(n.isPacked&&!isReshapeFree(n.shape,t.shape)){a.delayedStorage=!1;var i=t.dataSync();a.delayedStorage=!0,t=Tensor.make(t.shape,{values:i},t.dtype),(n=a.texData.get(t.dataId)).isPacked=!0;}return a.uploadToGPU(t.dataId),{shape:t.shape,texData:n,isUniform:!1}});this.uploadToGPU(n.dataId);var s,u={shape:n.shape,texData:this.texData.get(n.dataId),isUniform:!1},l=makeShaderKey(e,i,u),c=this.getAndSaveBinary(l,function(){return compileProgram(a.gpgpu,e,i,u)}),p=null!=this.activeTimers;if(p&&(s=this.startTimer()),runProgram(c,i,u,r),ENV.get(\"WEBGL_PAGING_ENABLED\")&&o&&this.numBytesInGPU>this.NUM_BYTES_BEFORE_PAGING)for(var d=this.numBytesInGPU-this.NUM_BYTES_BEFORE_PAGING;d>0&&this.lruDataGPU.length>0;){var h=this.lruDataGPU.shift(),f=this.texData.get(h),m=f.shape,g=f.dtype;d-=this.computeBytes(m,g),this.read(h);}return p&&(s=this.endTimer(s),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(s)})),ENV.get(\"WEBGL_LAZILY_UNPACK\")||!this.texData.get(n.dataId).isPacked||e.isPackShader?n:this.unpackTensor(n)},e.prototype.getAndSaveBinary=function(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]},e.prototype.getTextureManager=function(){return this.textureManager},e.prototype.dispose=function(){if(!this.disposed){for(var e in this.binaryCache)this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram);this.textureManager.dispose(),this.canvas.remove(),null!=this.fromPixels2DContext&&this.fromPixels2DContext.canvas.remove(),this.gpgpuCreatedLocally&&this.gpgpu.dispose(),this.disposed=!0;}},e.prototype.floatPrecision=function(){var e=this;return tidy(function(){return e.abs(scalar(1e-8)).get()>0?32:16})},e.prototype.uploadToGPU=function(e){var t,n=this.texData.get(e),r=n.shape,o=n.values,a=n.texture,i=n.usage,s=n.isPacked;if(null==a){var u,l=null!=this.activeTimers;l&&(u=performance.now());var c=getTextureShapeFromLogicalShape(r,s);n.texShape=c;var p=this.acquireTexture(e,c,i,s);if(n.texture=p,null!=o){if(s){var d=this.getBatchDim(r),h=1,f=1;r.length&&(h=(t=this.getRowsCols(r))[0],f=t[1]),this.gpgpu.uploadMatrixToPackedTexture(p,d,h,f,c[0],c[1],typedArrayToFloat32(o));}else this.gpgpu.uploadMatrixToTexture(p,c[0],c[1],typedArrayToFloat32(o));n.values=null,l&&(this.uploadWaitMs+=performance.now()-u);}}else{ENV.get(\"WEBGL_PAGING_ENABLED\")&&this.lruDataGPU.indexOf(e)>=0&&(this.lruDataGPU.splice(this.lruDataGPU.indexOf(e),1),this.lruDataGPU.push(e));}},e.prototype.convertAndCacheOnCPU=function(e,t){var n=this.delayedStorage,r=this.texData.get(e),o=r.texture,a=r.texShape,i=r.dtype,s=r.usage,u=r.isPacked;return n&&null!=o&&(this.releaseTexture(e,o,a,s,u),r.texture=null,r.texShape=null),r.usage=TextureUsage.UPLOAD,null!=t&&(r.values=float32ToTypedArray(t,i)),r.values},e.prototype.releaseTexture=function(e,t,n,r,o){var a=this.texData.get(e),i=a.shape,s=a.dtype;if(ENV.get(\"WEBGL_PAGING_ENABLED\")){var u=this.lruDataGPU.indexOf(e);u>=0&&this.lruDataGPU.splice(u,1);}this.numBytesInGPU-=this.computeBytes(i,s),this.textureManager.releaseTexture(t,n,r,o);},e.prototype.acquireTexture=function(e,t,n,r){var o=this.texData.get(e),a=o.shape,i=o.dtype;return ENV.get(\"WEBGL_PAGING_ENABLED\")&&this.lruDataGPU.push(e),this.numBytesInGPU+=this.computeBytes(a,i),this.textureManager.acquireTexture(t,n,r)},e.prototype.computeBytes=function(e,t){return sizeFromShape(e)*bytesPerElement(t)},e}();function float32ToTypedArray(e,t){if(\"float32\"===t||\"complex64\"===t)return e;if(\"int32\"===t||\"bool\"===t){for(var n=\"int32\"===t?new Int32Array(e.length):new Uint8Array(e.length),r=0;r<n.length;++r)n[r]=Math.round(e[r]);return n}throw new Error(\"Unknown dtype \"+t)}function typedArrayToFloat32(e){return e instanceof Float32Array?e:new Float32Array(e)}function neg_(e){var t=convertToTensor(e,\"x\",\"neg\");return ENV.engine.runKernel(function(e){return e.neg(t)},{$x:t},function(e){return {$x:function(){return e.neg()}}})}function ceil_(e){var t=convertToTensor(e,\"x\",\"ceil\");return ENV.engine.runKernel(function(e){return e.ceil(t)},{$x:t},function(e){return {$x:function(){return zerosLike(e)}}})}function floor_(e){var t=convertToTensor(e,\"x\",\"floor\");return ENV.engine.runKernel(function(e){return e.floor(t)},{$x:t},function(e){return {$x:function(){return zerosLike(e)}}})}function sign_(e){var t=convertToTensor(e,\"x\",\"sign\");return ENV.engine.runKernel(function(e){return e.sign(t)},{$x:t},function(e){return {$x:function(){return zerosLike(e)}}})}function round_(e){var t=convertToTensor(e,\"x\",\"round\");return ENV.engine.runKernel(function(e){return e.round(t)},{$x:t},function(e){return {$x:function(){return zerosLike(e)}}})}function exp_(e){var t=convertToTensor(e,\"x\",\"exp\");return ENV.engine.runKernel(function(e,n){return n(e.exp(t))},{$x:t},function(e,t){var n=t[0];return {$x:function(){return e.mulStrict(n)}}})}function expm1_(e){var t=convertToTensor(e,\"x\",\"expm1\");return ENV.engine.runKernel(function(e){return e.expm1(t)},{$x:t},function(e){return {$x:function(){return e.mulStrict(t.exp())}}})}function log_(e){var t=convertToTensor(e,\"x\",\"log\");return ENV.engine.runKernel(function(e){return e.log(t)},{$x:t},function(e){return {$x:function(){return e.divStrict(t.toFloat())}}})}function log1p_(e){var t=convertToTensor(e,\"x\",\"log1p\");return ENV.engine.runKernel(function(e){return e.log1p(t)},{$x:t},function(e){return {$x:function(){return e.div(t.add(1))}}})}function sqrt_(e){var t=convertToTensor(e,\"x\",\"sqrt\");return ENV.engine.runKernel(function(e){return e.sqrt(t)},{$x:t},function(e){return {$x:function(){return e.div(t.toFloat().sqrt().mul(2))}}})}function rsqrt_(e){var t=convertToTensor(e,\"x\",\"rsqrt\");return ENV.engine.runKernel(function(e){return e.rsqrt(t)},{$x:t},function(e){return {$x:function(){return e.div(t.pow(1.5).mul(2)).neg()}}})}function square_(e){var t=convertToTensor(e,\"x\",\"square\");return ENV.engine.runKernel(function(e){return e.square(t)},{$x:t},function(e){return {$x:function(){return e.mul(t.toFloat().mul(2))}}})}function reciprocal_(e){var t=convertToTensor(e,\"x\",\"reciprocal\");return ENV.engine.runKernel(function(e){return e.reciprocal(t)},{$x:t},function(e){return {$x:function(){return e.divStrict(t.square().neg())}}})}function abs_(e){var t=convertToTensor(e,\"x\",\"abs\");if(\"complex64\"===t.dtype)return ENV.engine.runKernel(function(e){return e.complexAbs(t)},{$x:t});return ENV.engine.runKernel(function(e){return e.abs(t)},{$x:t},function(e){return {$x:function(){return e.mulStrict(t.toFloat().step(-1))}}})}function clipByValue_(e,t,n){var r=convertToTensor(e,\"x\",\"clipByValue\");assert(t<=n,\"Error in clip: min (\"+t+\") must be less than or equal to max (\"+n+\").\");return ENV.engine.runKernel(function(e){return e.clip(r,t,n)},{$x:r},function(e){return {$x:function(){return e.where(r.greaterEqual(t).logicalAnd(r.lessEqual(n)),zerosLike(e))}}})}function sigmoid_(e){var t=convertToTensor(e,\"x\",\"sigmoid\");return ENV.engine.runKernel(function(e,n){return n(e.sigmoid(t))},{$x:t},function(e,t){var n=t[0];return {$x:function(){return e.mul(n.mul(scalar(1).sub(n)))}}})}function logSigmoid_(e){var t=convertToTensor(e,\"x\",\"logSigmoid\");return ENV.engine.runKernel(function(e){return e.softplus(t.neg()).neg()},{$x:t},function(e){return {$x:function(){return e.mulStrict(t.neg().sigmoid())}}})}function softplus_(e){var t=convertToTensor(e,\"x\",\"softplus\");return ENV.engine.runKernel(function(e){return e.softplus(t)},{$x:t},function(e){return {$x:function(){return e.mulStrict(t.sigmoid())}}})}function sin_(e){var t=convertToTensor(e,\"x\",\"sin\");return ENV.engine.runKernel(function(e){return e.sin(t)},{$x:t},function(e){return {$x:function(){return t.toFloat().cos().mulStrict(e)}}})}function cos_(e){var t=convertToTensor(e,\"x\",\"cos\");return ENV.engine.runKernel(function(e){return e.cos(t)},{$x:t},function(e){return {$x:function(){return t.toFloat().sin().neg().mulStrict(e)}}})}function tan_(e){var t=convertToTensor(e,\"x\",\"tan\");return ENV.engine.runKernel(function(e){return e.tan(t)},{$x:t},function(e){return {$x:function(){return e.divStrict(t.cos().square())}}})}function asin_(e){var t=convertToTensor(e,\"x\",\"asin\");return ENV.engine.runKernel(function(e){return e.asin(t)},{$x:t},function(e){return {$x:function(){return e.divStrict(scalar(1).sub(t.toFloat().square()).sqrt())}}})}function acos_(e){var t=convertToTensor(e,\"x\",\"acos\");return ENV.engine.runKernel(function(e){return e.acos(t)},{$x:t},function(e){return {$x:function(){return e.divStrict(scalar(1).sub(t.toFloat().square()).sqrt()).neg()}}})}function atan_(e){var t=convertToTensor(e,\"x\",\"atan\");return ENV.engine.runKernel(function(e){return e.atan(t)},{$x:t},function(e){return {$x:function(){return e.div(t.toFloat().square().add(1))}}})}function sinh_(e){var t=convertToTensor(e,\"x\",\"sinh\");return ENV.engine.runKernel(function(e){return e.sinh(t)},{$x:t},function(e){return {$x:function(){return t.toFloat().cosh().mulStrict(e)}}})}function cosh_(e){var t=convertToTensor(e,\"x\",\"cosh\");return ENV.engine.runKernel(function(e){return e.cosh(t)},{$x:t},function(e){return {$x:function(){return t.toFloat().sinh().mulStrict(e)}}})}function tanh_(e){var t=convertToTensor(e,\"x\",\"tanh\");return ENV.engine.runKernel(function(e,n){return n(e.tanh(t))},{$x:t},function(e,t){var n=t[0];return {$x:function(){return scalar(1).sub(n.square()).mulStrict(e)}}})}function asinh_(e){var t=convertToTensor(e,\"x\",\"asinh\");return ENV.engine.runKernel(function(e){return e.asinh(t)},{$x:t},function(e){return {$x:function(){return e.divStrict(scalar(1).add(t.toFloat().square()).sqrt())}}})}function acosh_(e){var t=convertToTensor(e,\"x\",\"acosh\");return ENV.engine.runKernel(function(e){return e.acosh(t)},{$x:t},function(e){return {$x:function(){return e.divStrict(t.toFloat().square().sub(1).sqrt())}}})}function atanh_(e){var t=convertToTensor(e,\"x\",\"atanh\");return ENV.engine.runKernel(function(e){return e.atanh(t)},{$x:t},function(e){return {$x:function(){return e.div(scalar(1).sub(t.toFloat().square()))}}})}function erf_(e){var t=convertToTensor(e,\"x\",\"erf\");assert(\"int32\"===t.dtype||\"float32\"===t.dtype,\"Input dtype must be `int32` or `float32`.\"),\"int32\"===t.dtype&&(t=t.toFloat());return ENV.engine.runKernel(function(e){return e.erf(t)},{$x:t},function(e){return {$x:function(){return e.mul(t.square().neg().exp().mul(2/Math.sqrt(Math.PI)))}}})}function step_(e,t){void 0===t&&(t=0);var n=convertToTensor(e,\"x\",\"step\");return ENV.engine.runKernel(function(e){return e.step(n,t)},{$x:n},function(e){return {$x:function(){return zerosLike(e)}}})}ENV.get(\"IS_BROWSER\")&&ENV.registerBackend(\"webgl\",function(){return new MathBackendWebGL},2,setTensorTracker);var abs=op({abs_:abs_}),acos=op({acos_:acos_}),acosh=op({acosh_:acosh_}),asin=op({asin_:asin_}),asinh=op({asinh_:asinh_}),atan=op({atan_:atan_}),atanh=op({atanh_:atanh_}),ceil=op({ceil_:ceil_}),clipByValue=op({clipByValue_:clipByValue_}),cos=op({cos_:cos_}),cosh=op({cosh_:cosh_}),erf=op({erf_:erf_}),exp=op({exp_:exp_}),expm1=op({expm1_:expm1_}),floor=op({floor_:floor_}),log$1=op({log_:log_}),log1p=op({log1p_:log1p_}),logSigmoid=op({logSigmoid_:logSigmoid_}),neg=op({neg_:neg_}),reciprocal=op({reciprocal_:reciprocal_}),round=op({round_:round_}),rsqrt=op({rsqrt_:rsqrt_}),sigmoid=op({sigmoid_:sigmoid_}),sign=op({sign_:sign_}),sin=op({sin_:sin_}),sinh=op({sinh_:sinh_}),softplus=op({softplus_:softplus_}),sqrt=op({sqrt_:sqrt_}),square=op({square_:square_}),step=op({step_:step_}),tan=op({tan_:tan_}),tanh$1=op({tanh_:tanh_});function batchNormalization2d_(e,t,n,r,o,a){void 0===r&&(r=.001);var i,s,u=convertToTensor(e,\"x\",\"batchNormalization\"),l=convertToTensor(t,\"mean\",\"batchNormalization\"),c=convertToTensor(n,\"variance\",\"batchNormalization\");return null!=o&&(i=convertToTensor(o,\"scale\",\"batchNormalization\")),null!=a&&(s=convertToTensor(a,\"offset\",\"batchNormalization\")),assert(2===u.rank,\"Error in batchNormalization3D: x must be rank 3 but got rank \"+u.rank+\".\"),assert(2===l.rank||1===l.rank,\"Error in batchNormalization2D: mean must be rank 2 or rank 1 but got rank \"+l.rank+\".\"),assert(2===c.rank||1===c.rank,\"Error in batchNormalization2D: variance must be rank 2 or rank 1 but got rank \"+c.rank+\".\"),null!=i&&assert(2===i.rank||1===i.rank,\"Error in batchNormalization2D: scale must be rank 2 or rank 1 but got rank \"+i.rank+\".\"),null!=s&&assert(2===s.rank||1===s.rank,\"Error in batchNormalization2D: offset must be rank 2 or rank 1 but got rank \"+s.rank+\".\"),batchNormalization(u,l,c,r,i,s)}function batchNormalization3d_(e,t,n,r,o,a){void 0===r&&(r=.001);var i,s,u=convertToTensor(e,\"x\",\"batchNormalization\"),l=convertToTensor(t,\"mean\",\"batchNormalization\"),c=convertToTensor(n,\"variance\",\"batchNormalization\");return null!=o&&(i=convertToTensor(o,\"scale\",\"batchNormalization\")),null!=a&&(s=convertToTensor(a,\"offset\",\"batchNormalization\")),assert(3===u.rank,\"Error in batchNormalization3D: x must be rank 3 but got rank \"+u.rank+\".\"),assert(3===l.rank||1===l.rank,\"Error in batchNormalization3D: mean must be rank 3 or rank 1 but got rank \"+l.rank+\".\"),assert(3===c.rank||1===c.rank,\"Error in batchNormalization3D: variance must be rank 3 or rank 1 but got rank \"+c.rank+\".\"),null!=i&&assert(3===i.rank||1===i.rank,\"Error in batchNormalization3D: scale must be rank 3 or rank 1 but got rank \"+i.rank+\".\"),null!=s&&assert(3===s.rank||1===s.rank,\"Error in batchNormalization3D: offset must be rank 3 or rank 1 but got rank \"+s.rank+\".\"),batchNormalization(u,l,c,r,i,s)}function batchNormalization4d_(e,t,n,r,o,a){void 0===r&&(r=.001);var i,s,u=convertToTensor(e,\"x\",\"batchNormalization\"),l=convertToTensor(t,\"mean\",\"batchNormalization\"),c=convertToTensor(n,\"variance\",\"batchNormalization\");return null!=o&&(i=convertToTensor(o,\"scale\",\"batchNormalization\")),null!=a&&(s=convertToTensor(a,\"offset\",\"batchNormalization\")),assert(4===u.rank,\"Error in batchNormalization4D: x must be rank 4 but got rank \"+u.rank+\".\"),assert(4===l.rank||1===l.rank,\"Error in batchNormalization4D: mean must be rank 4 or rank 1 but got rank \"+l.rank+\".\"),assert(4===c.rank||1===c.rank,\"Error in batchNormalization4D: variance must be rank 4 or rank 1 but got rank \"+c.rank+\".\"),null!=i&&assert(4===i.rank||1===i.rank,\"Error in batchNormalization4D: scale must be rank 4 or rank 1 but got rank \"+i.rank+\".\"),null!=s&&assert(4===s.rank||1===s.rank,\"Error in batchNormalization4D: offset must be rank 4 or rank 1 but got rank \"+s.rank+\".\"),batchNormalization(u,l,c,r,i,s)}function batchNormalization_(e,t,n,r,o,a){void 0===r&&(r=.001);var i,s,u,l=convertToTensor(e,\"x\",\"batchNormalization\"),c=convertToTensor(t,\"mean\",\"batchNormalization\"),p=convertToTensor(n,\"variance\",\"batchNormalization\");null!=o&&(i=convertToTensor(o,\"scale\",\"batchNormalization\")),null!=a&&(s=convertToTensor(a,\"offset\",\"batchNormalization\")),assert(c.rank===p.rank,\"Batch normalization gradient requires mean and variance to have equal ranks.\"),assert(null==s||c.rank===s.rank,\"Batch normalization gradient requires mean and offset to have equal ranks.\"),assert(null==i||c.rank===i.rank,\"Batch normalization gradient requires mean and scale to have equal ranks.\"),u=0===l.rank||1===l.rank?l.as4D(1,1,1,l.size):2===l.rank?l.as4D(1,1,l.shape[0],l.shape[1]):3===l.rank?l.as4D(1,l.shape[0],l.shape[1],l.shape[2]):l;return ENV.engine.runKernel(function(e){return e.batchNormalization(u,batchnormReshape4D(c),batchnormReshape4D(p),r,batchnormReshape4D(i),batchnormReshape4D(s))},{$x:l,$mean:c,$variance:p,$scale:i,$offset:s},function(e){var t=null==i?scalar(1):i,n=getReductionAxes(c.shape,u.shape),o=[];if(1===c.rank){for(var a=0;a<u.shape.length-1;++a)o.push(u.shape[a]);o.push(1);}var s=l.sub(c),d=e.mul(t),h=rsqrt(p.add(scalar(r))),f=h.mul(h).mul(h).mul(scalar(-.5));return {$x:function(){return 1===c.rank?e.mul(tile(h.as4D(1,1,1,c.shape[0]),o)).mul(t).reshape(l.shape):e.mul(h).mul(t).reshape(l.shape)},$mean:function(){var e=h.mul(scalar(-1)).mul(d);return 1===c.rank&&(e=e.sum(n)),e.reshape(c.shape)},$variance:function(){var e=f.mul(s).mul(d);return 1===c.rank&&(e=e.sum(n)),e.reshape(c.shape)},$scale:function(){var t=s.mul(h),r=e.mul(t);return 1===c.rank&&(r=r.sum(n)),r.reshape(c.shape)},$offset:function(){var t=e;return 1===c.rank&&(t=t.sum(n)),t.reshape(c.shape)}}}).reshape(l.shape)}function batchnormReshape4D(e){return null==e?null:0===e.rank?e.as1D():1===e.rank?e:2===e.rank?e.as4D(1,1,e.shape[0],e.shape[1]):3===e.rank?e.as4D(1,e.shape[0],e.shape[1],e.shape[2]):e}var batchNormalization2d=op({batchNormalization2d_:batchNormalization2d_}),batchNormalization3d=op({batchNormalization3d_:batchNormalization3d_}),batchNormalization4d=op({batchNormalization4d_:batchNormalization4d_}),batchNormalization=op({batchNormalization_:batchNormalization_});function computePool2DInfo(e,t,n,r,o,a,i){void 0===i&&(i=\"channelsLast\");var s,u=parseTupleParam(t),l=u[0],c=u[1];if(\"channelsLast\"===i)s=[l,c,e[3],e[3]];else{if(\"channelsFirst\"!==i)throw new Error(\"Unknown dataFormat \"+i);s=[l,c,e[1],e[1]];}return computeConv2DInfo(e,s,n,r,o,a,!1,i)}function computeConv2DInfo(e,t,n,r,o,a,i,s){void 0===i&&(i=!1),void 0===s&&(s=\"channelsLast\");var u=[-1,-1,-1,-1],l=u[0],c=u[1],p=u[2],d=u[3];if(\"channelsLast\"===s)l=e[0],c=e[1],p=e[2],d=e[3];else{if(\"channelsFirst\"!==s)throw new Error(\"Unknown dataFormat \"+s);l=e[0],d=e[1],c=e[2],p=e[3];}var h,f=t[0],m=t[1],g=t[3],v=parseTupleParam(n),y=v[0],x=v[1],T=parseTupleParam(r),w=T[0],E=T[1],S=getEffectiveFilterSize(f,w),b=getEffectiveFilterSize(m,E),C=getPadAndOutInfo(o,c,p,y,x,S,b,a),A=C.padInfo,_=C.outHeight,N=C.outWidth,R=i?g*d:g;return \"channelsFirst\"===s?h=[l,R,_,N]:\"channelsLast\"===s&&(h=[l,_,N,R]),{batchSize:l,dataFormat:s,inHeight:c,inWidth:p,inChannels:d,outHeight:_,outWidth:N,outChannels:R,padInfo:A,strideHeight:y,strideWidth:x,filterHeight:f,filterWidth:m,effectiveFilterHeight:S,effectiveFilterWidth:b,dilationHeight:w,dilationWidth:E,inShape:e,outShape:h,filterShape:t}}function computeConv3DInfo(e,t,n,r,o,a,i){void 0===a&&(a=!1),void 0===i&&(i=\"channelsLast\");var s=[-1,-1,-1,-1,-1],u=s[0],l=s[1],c=s[2],p=s[3],d=s[4];if(\"channelsLast\"===i)u=e[0],l=e[1],c=e[2],p=e[3],d=e[4];else{if(\"channelsFirst\"!==i)throw new Error(\"Unknown dataFormat \"+i);u=e[0],d=e[1],l=e[2],c=e[3],p=e[4];}var h,f=t[0],m=t[1],g=t[2],v=t[4],y=parse3TupleParam(n),x=y[0],T=y[1],w=y[2],E=parse3TupleParam(r),S=E[0],b=E[1],C=E[2],A=get3DPadAndOutInfo(o,l,c,p,x,T,w,getEffectiveFilterSize(f,S),getEffectiveFilterSize(m,b),getEffectiveFilterSize(g,C)),_=A.padInfo,N=A.outDepth,R=A.outHeight,k=A.outWidth,I=a?v*d:v;return \"channelsFirst\"===i?h=[u,I,N,R,k]:\"channelsLast\"===i&&(h=[u,N,R,k,I]),{batchSize:u,dataFormat:i,inDepth:l,inHeight:c,inWidth:p,inChannels:d,outDepth:N,outHeight:R,outWidth:k,outChannels:I,padInfo:_,strideDepth:x,strideHeight:T,strideWidth:w,filterDepth:f,filterHeight:m,filterWidth:g,dilationDepth:S,dilationHeight:b,dilationWidth:C,inShape:e,outShape:h,filterShape:t}}function computeOutputShape3D(e,t,n,r,o,a){null==o&&(o=computeDefaultPad(e,t,r));var i=e[0],s=e[1],u=conditionalRound((i-t+2*o)/r+1,a);assert(isInt(u),\"The output # of rows (\"+u+\") must be an integer. Change the stride and/or zero pad parameters\");var l=conditionalRound((s-t+2*o)/r+1,a);return assert(isInt(l),\"The output # of columns (\"+l+\") must be an integer. Change the stride and/or zero pad parameters\"),[u,l,n]}function computeDefaultPad(e,t,n,r){void 0===r&&(r=1);var o=getEffectiveFilterSize(t,r);return Math.floor((e[0]*(n-1)-n+o)/2)}function parseTupleParam(e){return \"number\"==typeof e?[e,e]:e}function parse3TupleParam(e){return \"number\"==typeof e?[e,e,e]:e}function getEffectiveFilterSize(e,t){return t<=1?e:e+(e-1)*(t-1)}function getPadAndOutInfo(e,t,n,r,o,a,i,s){var u,l,c;if(\"number\"==typeof e){u={top:e,bottom:e,left:e,right:e,type:0===e?\"VALID\":\"NUMBER\"};var p=computeOutputShape3D([t,n,1],a,1,r,e,s);l=p[0],c=p[1];}else if(\"same\"===e){var d=((l=Math.ceil(t/r))-1)*r+a-t,h=((c=Math.ceil(n/o))-1)*o+i-n,f=Math.floor(d/2),m=d-f,g=Math.floor(h/2);u={top:f,bottom:m,left:g,right:h-g,type:\"SAME\"};}else{if(\"valid\"!==e)throw Error(\"Unknown padding parameter: \"+e);u={top:0,bottom:0,left:0,right:0,type:\"VALID\"},l=Math.ceil((t-a+1)/r),c=Math.ceil((n-i+1)/o);}return {padInfo:u,outHeight:l,outWidth:c}}function get3DPadAndOutInfo(e,t,n,r,o,a,i,s,u,l){var c,p,d,h;if(\"same\"===e){var f=((p=Math.ceil(t/o))-1)*o+s-t,m=((d=Math.ceil(n/a))-1)*a+u-n,g=((h=Math.ceil(r/i))-1)*i+l-r,v=Math.floor(f/2),y=f-v,x=Math.floor(m/2),T=m-x,w=Math.floor(g/2);c={top:x,bottom:T,left:w,right:g-w,front:v,back:y,type:\"SAME\"};}else{if(\"valid\"!==e)throw Error(\"Unknown padding parameter: \"+e);c={top:0,bottom:0,left:0,right:0,front:0,back:0,type:\"VALID\"},p=Math.ceil((t-s+1)/o),d=Math.ceil((n-u+1)/a),h=Math.ceil((r-l+1)/i);}return {padInfo:c,outDepth:p,outHeight:d,outWidth:h}}function conditionalRound(e,t){if(!t)return e;switch(t){case\"round\":return Math.round(e);case\"ceil\":return Math.ceil(e);case\"floor\":return Math.floor(e);default:throw new Error(\"Unknown roundingMode \"+t)}}function tupleValuesAreOne(e){var t=parseTupleParam(e),n=t[0],r=t[1];return 1===n&&1===r}function eitherStridesOrDilationsAreOne(e,t){return tupleValuesAreOne(e)||tupleValuesAreOne(t)}function matMul_(e,t,n,r){var o;void 0===n&&(n=!1),void 0===r&&(r=!1);var a=convertToTensor(e,\"a\",\"matMul\"),i=convertToTensor(t,\"b\",\"matMul\");a=(o=makeTypesMatch(a,i))[0],i=o[1];var s=n?a.shape[a.rank-2]:a.shape[a.rank-1],u=r?i.shape[i.rank-1]:i.shape[i.rank-2],l=n?a.shape[a.rank-1]:a.shape[a.rank-2],c=r?i.shape[i.rank-2]:i.shape[i.rank-1],p=a.shape.slice(0,-2),d=i.shape.slice(0,-2),h=sizeFromShape(p),f=sizeFromShape(d);assert(a.rank>=2&&i.rank>=2&&a.rank===i.rank,\"Error in matMul: inputs must have the same rank of at least 2, got ranks \"+a.rank+\" and \"+i.rank+\".\"),assert(arraysEqual(p,d),\"Error in matMul: outer dimensions (\"+p+\") and (\"+d+\") of Tensors with shapes \"+a.shape+\" and \"+i.shape+\" must match.\"),assert(s===u,\"Error in matMul: inner shapes (\"+s+\") and (\"+u+\") of Tensors with shapes \"+a.shape+\" and \"+i.shape+\" and transposeA=\"+n+\" and transposeB=\"+r+\" must match.\");var m=a.shape.slice(0,-2).concat([l,c]),g=n?a.as3D(h,s,l):a.as3D(h,l,s),v=r?i.as3D(f,c,u):i.as3D(f,u,c);return ENV.engine.runKernel(function(e){return e.batchMatMul(g,v,n,r)},{$a:g,$b:v},function(e){return n||r?!n&&r?{$a:function(){return e.matMul(v,!1,!1)},$b:function(){return e.matMul(g,!0,!1)}}:n&&!r?{$a:function(){return v.matMul(e,!1,!0)},$b:function(){return g.matMul(e,!1,!1)}}:{$a:function(){return v.matMul(e,!0,!0)},$b:function(){return e.matMul(g,!0,!0)}}:{$a:function(){return e.matMul(v,!1,!0)},$b:function(){return g.matMul(e,!0,!1)}}}).reshape(m)}function outerProduct_(e,t){var n=convertToTensor(e,\"v1\",\"outerProduct\"),r=convertToTensor(t,\"v2\",\"outerProduct\");return assert(1===n.rank&&1===r.rank,\"Error in outerProduct: inputs must be rank 1, but got ranks \"+n.rank+\" and \"+r.rank+\".\"),n.as2D(-1,1).matMul(r.as2D(1,-1))}function dot_(e,t){var n=convertToTensor(e,\"t1\",\"dot\"),r=convertToTensor(t,\"t2\",\"dot\");assert(!(1!==n.rank&&2!==n.rank||1!==r.rank&&2!==r.rank),\"Error in dot: inputs must all be rank 1 or 2, but got ranks \"+n.rank+\" and \"+r.rank+\".\");var o=1===n.rank?n.size:n.shape[1],a=1===r.rank?r.size:r.shape[0];return assert(o===a,\"Error in dot: inner dimensions of inputs must match, but got \"+o+\" and \"+a+\".\"),1===n.rank&&1===r.rank?n.as2D(1,-1).matMul(r.as2D(-1,1)).asScalar():1===n.rank&&2===r.rank?n.as2D(1,-1).matMul(r.as2D(r.shape[0],r.shape[1])).as1D():2===n.rank&&1===r.rank?n.matMul(r.as2D(-1,1)).as1D():n.matMul(r.as2D(r.shape[0],r.shape[1]))}var matMul=op({matMul_:matMul_}),dot=op({dot_:dot_}),outerProduct=op({outerProduct_:outerProduct_});function conv1d_(e,t,n,r,o,a,i){void 0===o&&(o=\"NWC\"),void 0===a&&(a=1);var s=convertToTensor(e,\"x\",\"conv1d\"),u=convertToTensor(t,\"filter\",\"conv1d\"),l=s,c=!1;2===s.rank&&(c=!0,l=s.as3D(1,s.shape[0],s.shape[1])),assert(3===l.rank,\"Error in conv1d: input must be rank 3, but got rank \"+l.rank+\".\"),assert(3===u.rank,\"Error in conv1d: filter must be rank 3, but got rank \"+u.rank+\".\"),null!=i&&assert(isInt(r),\"Error in conv1d: pad must be an integer when using, dimRoundingMode \"+i+\" but got pad \"+r+\".\"),assert(l.shape[2]===u.shape[1],\"Error in conv1d: depth of input (\"+l.shape[2]+\") must match input depth for filter \"+u.shape[1]+\".\"),assert(eitherStridesOrDilationsAreOne(n,a),\"Error in conv1D: Either stride or dilation must be 1. Got stride \"+n+\" and dilation '\"+a+\"'\"),assert(\"NWC\"===o,\"Error in conv1d: got dataFormat of \"+o+\" but only NWC is currently supported.\");var p=u.as4D(1,u.shape[0],u.shape[1],u.shape[2]),d=l.as4D(l.shape[0],1,l.shape[1],l.shape[2]),h=conv2d(d,p,[1,n],r,\"NHWC\",[1,a],i);return c?h.as2D(h.shape[2],h.shape[3]):h.as3D(h.shape[0],h.shape[2],h.shape[3])}function conv2d_(e,t,n,r,o,a,i){void 0===o&&(o=\"NHWC\"),void 0===a&&(a=[1,1]);var s=convertToTensor(e,\"x\",\"conv2d\"),u=convertToTensor(t,\"filter\",\"conv2d\"),l=s,c=!1;3===s.rank&&(c=!0,l=s.as4D(1,s.shape[0],s.shape[1],s.shape[2])),assert(4===l.rank,\"Error in conv2d: input must be rank 4, but got rank \"+l.rank+\".\"),assert(4===u.rank,\"Error in conv2d: filter must be rank 4, but got rank \"+u.rank+\".\"),null!=i&&assert(isInt(r),\"Error in conv2d: pad must be an integer when using, dimRoundingMode \"+i+\" but got pad \"+r+\".\"),assert(l.shape[3]===u.shape[2],\"Error in conv2d: depth of input (\"+l.shape[3]+\") must match input depth for filter \"+u.shape[2]+\".\"),assert(eitherStridesOrDilationsAreOne(n,a),\"Error in conv2D: Either strides or dilations must be 1. Got strides \"+n+\" and dilations '\"+a+\"'\"),assert(\"NHWC\"===o,\"Error in conv2d: got dataFormat of \"+o+\" but only NHWC is currently supported.\");var p,d=computeConv2DInfo(l.shape,u.shape,n,a,r,i);if(1!==d.filterHeight||1!==d.filterWidth||1!==d.dilationHeight||1!==d.dilationWidth||1!==d.strideHeight||1!==d.strideWidth||\"SAME\"!==d.padInfo.type&&\"VALID\"!==d.padInfo.type){p=ENV.engine.runKernel(function(e){return e.conv2d(l,u,d)},{x:l,$filter:u},function(e){return assert(tupleValuesAreOne(a),\"Error in gradient of conv2D: dilation rates greater than 1 are notyet supported in gradients. Got dilations '\"+a+\"'\"),{x:function(){return conv2dDerInput_(l.shape,e,u,n,r)},$filter:function(){return conv2dDerFilter_(l,e,u.shape,n,r)}}});}else{var h=l.reshape([-1,d.inChannels]),f=u.reshape([d.inChannels,d.outChannels]);p=matMul(h,f).reshape(d.outShape);}return c?p.as3D(p.shape[1],p.shape[2],p.shape[3]):p}function conv2dDerInput_(e,t,n,r,o,a){assert(e.length===t.rank,\"Length of inShape (\"+e.length+\") and rank of dy (\"+t.rank+\") must match\");var i=e,s=t,u=!1;3===t.rank&&(u=!0,s=t.as4D(1,t.shape[0],t.shape[1],t.shape[2]),i=[1,e[0],e[1],e[2]]);var l=i[3],c=s.shape[3];assert(4===i.length,\"Error in conv2dDerInput: inShape must be length 4, but got length \"+i.length+\".\"),assert(4===s.rank,\"Error in conv2dDerInput: dy must be rank 4, but got rank \"+s.rank),assert(4===n.rank,\"Error in conv2dDerInput: filter must be rank 4, but got rank \"+n.rank),assert(l===n.shape[2],\"Error in conv2dDerInput: depth of input (\"+l+\") must match input depth for filter \"+n.shape[2]+\".\"),assert(c===n.shape[3],\"Error in conv2dDerInput: depth of output (\"+c+\") must match output depth for filter \"+n.shape[3]+\".\"),null!=a&&assert(isInt(o),\"Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode \"+a+\" but got pad \"+o+\".\");var p=computeConv2DInfo(i,n.shape,r,1,o,a),d=ENV.engine.runKernel(function(e){return e.conv2dDerInput(s,n,p)},{dy4D:s,filter:n},function(e){return {dy4D:function(){return conv2d(e,n,r,o,\"NHWC\",1,a)},filter:function(){return conv2dDerFilter(e,s,n.shape,r,o,a)}}});return u?d.as3D(d.shape[1],d.shape[2],d.shape[3]):d}function conv2dDerFilter_(e,t,n,r,o,a){var i=e;3===e.rank&&(i=e.as4D(1,e.shape[0],e.shape[1],e.shape[2]));var s=t;3===s.rank&&(s=t.as4D(1,t.shape[0],t.shape[1],t.shape[2])),assert(4===i.rank,\"Error in conv2dDerFilter: input must be rank 4, but got shape \"+i.shape+\".\"),assert(4===s.rank,\"Error in conv2dDerFilter: dy must be rank 4, but got shape \"+s.shape+\".\"),assert(4===n.length,\"Error in conv2dDerFilter: filterShape must be length 4, but got \"+n+\".\"),assert(i.shape[3]===n[2],\"Error in conv2dDerFilter: depth of input \"+i.shape[3]+\") must match input depth in filter (\"+n[2]+\".\"),assert(s.shape[3]===n[3],\"Error in conv2dDerFilter: depth of dy (\"+s.shape[3]+\") must match output depth for filter (\"+n[3]+\").\"),null!=a&&assert(isInt(o),\"Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode \"+a+\" but got pad \"+o+\".\");var u=computeConv2DInfo(i.shape,n,r,1,o,a);return ENV.engine.runKernel(function(e){return e.conv2dDerFilter(i,s,u)},{x4D:i,dy4D:s})}function conv2dTranspose_(e,t,n,r,o,a){return conv2dDerInput_(n,convertToTensor(e,\"x\",\"conv2dTranspose\"),convertToTensor(t,\"filter\",\"conv2dTranspose\"),r,o,a)}function depthwiseConv2d_(e,t,n,r,o,a,i){void 0===o&&(o=\"NHWC\"),void 0===a&&(a=[1,1]);var s=convertToTensor(e,\"x\",\"depthwiseConv2d\"),u=convertToTensor(t,\"filter\",\"depthwiseConv2d\"),l=s,c=!1;3===s.rank&&(c=!0,l=s.as4D(1,s.shape[0],s.shape[1],s.shape[2])),assert(4===l.rank,\"Error in depthwiseConv2d: input must be rank 4, but got rank \"+l.rank+\".\"),assert(4===u.rank,\"Error in depthwiseConv2d: filter must be rank 4, but got rank \"+u.rank+\".\"),assert(l.shape[3]===u.shape[2],\"Error in depthwiseConv2d: number of input channels (\"+l.shape[3]+\") must match the inChannels dimension in filter \"+u.shape[2]+\".\"),null==a&&(a=[1,1]),assert(eitherStridesOrDilationsAreOne(n,a),\"Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides \"+n+\" and dilations '\"+a+\"'\"),null!=i&&assert(isInt(r),\"Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode \"+i+\" but got pad \"+r+\".\");var p=computeConv2DInfo(l.shape,u.shape,n,a,r,i,!0),d=ENV.engine.runKernel(function(e){return e.depthwiseConv2D(l,u,p)},{x:l,$filter:u},function(e){return assert(tupleValuesAreOne(a),\"Error in gradient of depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '\"+a+\"'\"),{x:function(){return depthwiseConv2dDerInput(l.shape,e,u,p)},$filter:function(){return depthwiseConv2dDerFilter(l,e,u.shape,p)}}});return c?d.as3D(d.shape[1],d.shape[2],d.shape[3]):d}function separableConv2d_(e,t,n,r,o,a,i){void 0===a&&(a=[1,1]),void 0===i&&(i=\"NHWC\");var s=convertToTensor(e,\"x\",\"separableConv2d\"),u=convertToTensor(t,\"depthwiseFilter\",\"separableConv2d\"),l=convertToTensor(n,\"pointwiseFilter\",\"separableConv2d\"),c=s,p=!1;if(3===s.rank&&(p=!0,c=s.as4D(1,s.shape[0],s.shape[1],s.shape[2])),\"NCHW\"===i)throw new Error(\"separableConv2d currently does not support dataFormat NCHW; only NHWC is supported\");assert(4===c.rank,\"Error in separableConv2d: input must be rank 4, but got rank \"+c.rank+\".\"),assert(4===u.rank,\"Error in separableConv2d: depthwise filter must be rank 4, but got rank \"+u.rank+\".\"),assert(4===l.rank,\"Error in separableConv2d: pointwise filter must be rank 4, but got rank \"+u.rank+\".\"),assert(1===l.shape[0],\"Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got \"+l.shape[0]+\".\"),assert(1===l.shape[1],\"Error in separableConv2d: the second dimension of pointwise filter  must be 1, but got \"+l.shape[1]+\".\");var d=u.shape[2],h=u.shape[3];assert(l.shape[2]===d*h,\"Error in separableConv2d: the third dimension of pointwise filter must be \"+d*h+\", but got \"+l.shape[2]+\".\");var f=depthwiseConv2d(c,u,r,o,i,a),m=conv2d(f,l,1,\"valid\",i);return p?m.as3D(m.shape[1],m.shape[2],m.shape[3]):m}function parseTupleParam$1(e){return \"number\"==typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function tupleValuesAreOne$1(e){var t=parseTupleParam$1(e),n=t[0],r=t[1],o=t[2];return 1===n&&1===r&&1===o}function eitherStridesOrDilationsAreOne$1(e,t){return tupleValuesAreOne$1(e)||tupleValuesAreOne$1(t)}function depthwiseConv2dDerInput(e,t,n,r){var o=t,a=!1;3===t.rank&&(a=!0,o=t.as4D(1,t.shape[0],t.shape[1],t.shape[2]));var i=ENV.engine.runKernel(function(e){return e.depthwiseConv2DDerInput(o,n,r)},{dy4D:o});return a?i.as3D(i.shape[1],i.shape[2],i.shape[3]):i}function depthwiseConv2dDerFilter(e,t,n,r){var o=e;3===e.rank&&(o=e.as4D(1,e.shape[0],e.shape[1],e.shape[2]));var a=t;return 3===a.rank&&(a=t.as4D(1,t.shape[0],t.shape[1],t.shape[2])),ENV.engine.runKernel(function(e){return e.depthwiseConv2DDerFilter(o,a,r)},{x4D:o,dy4D:a})}function conv3d_(e,t,n,r,o,a){void 0===o&&(o=\"NHWC\"),void 0===a&&(a=[1,1,1]);var i=convertToTensor(e,\"x\",\"conv3d\"),s=convertToTensor(t,\"filter\",\"conv3d\"),u=i,l=!1;4===i.rank&&(l=!0,u=i.as5D(1,i.shape[0],i.shape[1],i.shape[2],i.shape[3])),assert(5===u.rank,\"Error in conv3d: input must be rank 5, but got rank \"+u.rank+\".\"),assert(5===s.rank,\"Error in conv3d: filter must be rank 5, but got rank \"+s.rank+\".\"),assert(u.shape[4]===s.shape[3],\"Error in conv3d: depth of input (\"+u.shape[4]+\") must match input depth for filter \"+s.shape[3]+\".\"),assert(eitherStridesOrDilationsAreOne$1(n,a),\"Error in conv3D: Either strides or dilations must be 1. Got strides \"+n+\" and dilations '\"+a+\"'\"),assert(\"NHWC\"===o,\"Error in conv3d: got dataFormat of \"+o+\" but only NHWC is currently supported.\");var c=computeConv3DInfo(u.shape,s.shape,n,a,r),p=ENV.engine.runKernel(function(e){return e.conv3d(u,s,c)},{x:u,$filter:s},function(e){return assert(tupleValuesAreOne$1(a),\"Error in gradient of conv3D: dilation rates greater than 1 are notyet supported in gradients. Got dilations '\"+a+\"'\"),{x:function(){return conv3dDerInput_(u.shape,e,s,n,r)},$filter:function(){return conv3dDerFilter_(u,e,s.shape,n,r)}}});return l?p.as4D(p.shape[1],p.shape[2],p.shape[3],p.shape[4]):p}function conv3dDerInput_(e,t,n,r,o){assert(e.length===t.rank,\"Length of inShape (\"+e.length+\") and rank of dy (\"+t.rank+\") must match\");var a=e,i=t,s=!1;4===t.rank&&(s=!0,i=t.as5D(1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]),a=[1,e[0],e[1],e[2],e[3]]);var u=a[4],l=i.shape[4];assert(5===a.length,\"Error in conv3dDerInput: inShape must be length 5, but got length \"+a.length+\".\"),assert(5===i.rank,\"Error in conv3dDerInput: dy must be rank 5, but got rank \"+i.rank),assert(5===n.rank,\"Error in conv3dDerInput: filter must be rank 5, but got rank \"+n.rank),assert(u===n.shape[3],\"Error in conv3dDerInput: depth of input (\"+u+\") must match input depth for filter \"+n.shape[3]+\".\"),assert(l===n.shape[4],\"Error in conv3dDerInput: depth of output (\"+l+\") must match output depth for filter \"+n.shape[4]+\".\");var c=computeConv3DInfo(a,n.shape,r,1,o),p=ENV.engine.runKernel(function(e){return e.conv3dDerInput(i,n,c)},{dy5D:i});return s?p.as4D(p.shape[1],p.shape[2],p.shape[3],p.shape[4]):p}function conv3dDerFilter_(e,t,n,r,o){var a=e;4===e.rank&&(a=e.as5D(1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]));var i=t;4===i.rank&&(i=t.as5D(1,t.shape[0],t.shape[1],t.shape[2],t.shape[3])),assert(5===a.rank,\"Error in conv3dDerFilter: input must be rank 5, but got shape \"+a.shape+\".\"),assert(5===i.rank,\"Error in conv3dDerFilter: dy must be rank 5, but got shape \"+i.shape+\".\"),assert(5===n.length,\"Error in conv3dDerFilter: filterShape must be length 5, but got \"+n+\".\"),assert(a.shape[4]===n[3],\"Error in conv3dDerFilter: depth of input \"+a.shape[4]+\") must match input depth in filter (\"+n[3]+\".\"),assert(i.shape[4]===n[4],\"Error in conv3dDerFilter: depth of dy (\"+i.shape[4]+\") must match output depth for filter (\"+n[4]+\").\");var s=computeConv3DInfo(a.shape,n,r,1,o);return ENV.engine.runKernel(function(e){return e.conv3dDerFilter(a,i,s)},{x5D:a,dy5D:i})}var conv1d=op({conv1d_:conv1d_}),conv2d=op({conv2d_:conv2d_}),conv3d=op({conv3d_:conv3d_}),conv2dDerFilter=op({conv2dDerFilter_:conv2dDerFilter_}),depthwiseConv2d=op({depthwiseConv2d_:depthwiseConv2d_}),separableConv2d=op({separableConv2d_:separableConv2d_}),conv2dTranspose=op({conv2dTranspose_:conv2dTranspose_});function reverse1d_(e){var t=convertToTensor(e,\"x\",\"reverse\");return assert(1===t.rank,\"Error in reverse1D: x must be rank 1 but got\\n             rank \"+t.rank+\".\"),reverse(t,0)}function reverse2d_(e,t){var n=convertToTensor(e,\"x\",\"reverse\");return assert(2===n.rank,\"Error in reverse2D: x must be rank 2 but got\\n             rank \"+n.rank+\".\"),reverse(n,t)}function reverse3d_(e,t){var n=convertToTensor(e,\"x\",\"reverse\");return assert(3===n.rank,\"Error in reverse3D: x must be rank 3 but got\\n             rank \"+n.rank+\".\"),reverse(n,t)}function reverse4d_(e,t){var n=convertToTensor(e,\"x\",\"reverse\");return assert(4===n.rank,\"Error in reverse4D: x must be rank 4 but got\\n             rank \"+n.rank+\".\"),reverse(n,t)}function reverse_(e,t){var n=convertToTensor(e,\"x\",\"reverse\");if(0===n.rank)return n.clone();var r=parseAxisParam(t,n.shape);return ENV.engine.runKernel(function(e){return e.reverse(n,r)},{$x:n},function(e){return {$x:function(){return e.reverse(r)}}}).reshapeAs(n)}var reverse=op({reverse_:reverse_}),reverse1d=op({reverse1d_:reverse1d_}),reverse2d=op({reverse2d_:reverse2d_}),reverse3d=op({reverse3d_:reverse3d_}),reverse4d=op({reverse4d_:reverse4d_});function maxPoolImpl_(e,t,n,r,o,a){var i=convertToTensor(e,\"x\",\"maxPool\"),s=i,u=!1;3===i.rank&&(u=!0,s=i.as4D(1,i.shape[0],i.shape[1],i.shape[2])),null==r&&(r=[1,1]),assert(4===s.rank,\"Error in maxPool: input must be rank 4 but got rank \"+s.rank+\".\"),assert(eitherStridesOrDilationsAreOne(n,r),\"Error in maxPool: Either strides or dilations must be 1. Got strides \"+n+\" and dilations '\"+r+\"'\"),null!=a&&assert(isInt(o),\"Error in maxPool: pad must be an integer when using, dimRoundingMode \"+a+\" but got pad \"+o+\".\");var l=computePool2DInfo(s.shape,t,n,r,o,a),c=ENV.engine.runKernel(function(e,t){return t(e.maxPool(s,l))},{x:s},function(e,a){var i=a[0];return {x:function(){return maxPoolBackprop(e,s,i,t,n,r,o)}}});return u?c.as3D(c.shape[1],c.shape[2],c.shape[3]):c}function maxPool_(e,t,n,r,o){return maxPoolImpl_(e,t,n,1,r,o)}function avgPoolImpl_(e,t,n,r,o,a){var i=convertToTensor(e,\"x\",\"avgPool\",\"float32\");null==r&&(r=[1,1]),assert(eitherStridesOrDilationsAreOne(n,r),\"Error in avgPool: Either strides or dilations must be 1. Got strides \"+n+\" and dilations '\"+r+\"'\");var s=i,u=!1;3===i.rank&&(u=!0,s=i.as4D(1,i.shape[0],i.shape[1],i.shape[2])),assert(4===s.rank,\"Error in avgPool: x must be rank 4 but got rank \"+s.rank+\".\"),null!=a&&assert(isInt(o),\"Error in avgPool: pad must be an integer when using, dimRoundingMode \"+a+\" but got pad \"+o+\".\");var l=computePool2DInfo(s.shape,t,n,r,o),c=ENV.engine.runKernel(function(e){return e.avgPool(s,l)},{x:s},function(e){return {x:function(){return avgPoolBackprop(e,s,t,n,r,o)}}});return c=c.cast(i.dtype),u?c.as3D(c.shape[1],c.shape[2],c.shape[3]):c}function avgPool_(e,t,n,r,o){return avgPoolImpl_(e,t,n,1,r,o)}function pool_(e,t,n,r,o,a){null==o&&(o=[1,1]),null==a&&(a=1),0===r&&(r=\"valid\");var i=convertToTensor(e,\"x\",\"maxPool\"),s=i,u=!1;3===i.rank&&(u=!0,s=i.as4D(1,i.shape[0],i.shape[1],i.shape[2])),assert(eitherStridesOrDilationsAreOne(a,o),\"Error in pool: Either strides or dilations must be 1. Got strides \"+a+\" and dilations '\"+o+\"'\");var l,c=computePool2DInfo(s.shape,t,a,o,r),p=[c.dilationHeight,c.dilationWidth];l=\"same\"===r?withSpaceToBatchBasePaddings([c.filterHeight,c.filterWidth],p):[[0,0],[0,0]];var d=1===p[0]&&1===p[1],h=requiredSpaceToBatchPaddings([c.inHeight,c.inWidth],p,l),f=h[0],m=h[1],g=d?r:\"valid\",v=d?s:spaceToBatchND(s,p,f),y=(\"avg\"===n?function(){return avgPoolImpl_(v,t,a,1,g)}:function(){return maxPoolImpl_(v,t,a,1,g)})(),x=d?y:batchToSpaceND(y,p,m);return u?x.as3D(x.shape[1],x.shape[2],x.shape[3]):x}function maxPoolBackprop(e,t,n,r,o,a,i,s){var u=convertToTensor(e,\"dy\",\"maxPoolBackprop\"),l=convertToTensor(t,\"input\",\"maxPoolBackprop\"),c=convertToTensor(n,\"output\",\"maxPoolBackprop\");assert(l.rank===u.rank,\"Rank of input (\"+l.rank+\") does not match rank of dy (\"+u.rank+\")\"),null==a&&(a=[1,1]),assert(eitherStridesOrDilationsAreOne(o,a),\"Error in maxPoolBackProp: Either strides or dilations must be 1. Got strides \"+o+\" and dilations '\"+a+\"'\"),assert(4===u.rank,\"Error in maxPoolBackprop: dy must be rank 4 but got rank \"+u.rank+\".\"),assert(4===l.rank,\"Error in maxPoolBackprop: input must be rank 4 but got rank \"+l.rank+\".\"),null!=s&&assert(isInt(i),\"Error in maxPoolBackprop: pad must be an integer when using, dimRoundingMode \"+s+\" but got pad \"+i+\".\");var p=computePool2DInfo(l.shape,r,o,a,i,s);return ENV.engine.runKernel(function(e){return e.maxPoolBackprop(u,l,c,p)},{$dy:u,$input:l})}function avgPoolBackprop(e,t,n,r,o,a){var i=convertToTensor(e,\"dy\",\"avgPoolBackprop\"),s=convertToTensor(t,\"input\",\"avgPoolBackprop\");assert(s.rank===i.rank,\"Rank of input (\"+s.rank+\") does not match rank of dy (\"+i.rank+\")\"),null==o&&(o=[1,1]),assert(eitherStridesOrDilationsAreOne(r,o),\"Error in avgPoolBackprop: Either strides or dilations must be 1. Got strides \"+r+\" and dilations '\"+o+\"'\");var u=s,l=i,c=!1;3===s.rank&&(c=!0,u=s.as4D(1,s.shape[0],s.shape[1],s.shape[2]),l=i.as4D(1,i.shape[0],i.shape[1],i.shape[2])),assert(4===l.rank,\"Error in avgPoolBackprop: dy must be rank 4 but got rank \"+l.rank+\".\"),assert(4===u.rank,\"Error in avgPoolBackprop: input must be rank 4 but got rank \"+u.rank+\".\");var p=computePool2DInfo(u.shape,n,r,o,a),d=ENV.engine.runKernel(function(e){return e.avgPoolBackprop(l,u,p)},{dy4D:l,input4D:u});return c?d.as3D(d.shape[1],d.shape[2],d.shape[3]):d}function requiredSpaceToBatchPaddings(e,t,n){var r=n.map(function(e){return e[0]}),o=n.map(function(e){return e[1]}),a=e.concat(r,o),i=t.map(function(e,t){return (e-a[t]%e)%e}),s=o.map(function(e,t){return e+i[t]});return [t.map(function(e,t){return [r[t],s[t]]}),t.map(function(e,t){return [0,i[t]]})]}function withSpaceToBatchBasePaddings(e,t){var n=e.map(function(e,n){return e+(e-1)*(t[n]-1)}).map(function(e){return e-1}),r=n.map(function(e){return Math.floor(e/2)}),o=n.map(function(e,t){return e-r[t]});return n.map(function(e,t){return [r[t],o[t]]})}var maxPool=op({maxPool_:maxPool_}),avgPool=op({avgPool_:avgPool_}),pool=op({pool_:pool_});function slice1d_(e,t,n){var r=convertToTensor(e,\"x\",\"slice1d\");return assert(1===r.rank,\"slice1d expects a rank-1 tensor, but got a rank-\"+r.rank+\" tensor\"),slice(r,[t],[n])}function slice2d_(e,t,n){var r=convertToTensor(e,\"x\",\"slice2d\");return assert(2===r.rank,\"slice2d expects a rank-2 tensor, but got a rank-\"+r.rank+\" tensor\"),slice(r,t,n)}function slice3d_(e,t,n){var r=convertToTensor(e,\"x\",\"slice3d\");return assert(3===r.rank,\"slice3d expects a rank-3 tensor, but got a rank-\"+r.rank+\" tensor\"),slice(r,t,n)}function slice4d_(e,t,n){var r=convertToTensor(e,\"x\",\"slice4d\");return assert(4===r.rank,\"slice4d expects a rank-4 tensor, but got a rank-\"+r.rank+\" tensor\"),slice(r,t,n)}function slice_(e,t,n){var r,o,a=convertToTensor(e,\"x\",\"slice\");if(0===a.rank)throw new Error(\"Slicing scalar is not possible\");r=\"number\"==typeof t?[t].concat(new Array(a.rank-1).fill(0)):t.length<a.rank?t.concat(new Array(a.rank-t.length).fill(0)):t.slice(),o=(o=null==n?new Array(a.rank).fill(-1):\"number\"==typeof n?[n].concat(new Array(a.rank-1).fill(-1)):n.length<a.rank?n.concat(new Array(a.rank-n.length).fill(-1)):n).map(function(e,t){return e>=0?e:(assert(-1===e,\"Bad value in size\"),a.shape[t]-r[t])}),assertParamsValid(a,r,o);var i=a.shape;return ENV.engine.runKernel(function(e){return e.slice(a,r,o)},{$x:a},function(e){for(var t=[],n=0;n<e.rank;n++)t.push([r[n],i[n]-r[n]-o[n]]);return {$x:function(){return e.pad(t)}}})}var slice=op({slice_:slice_}),slice1d=op({slice1d_:slice1d_}),slice2d=op({slice2d_:slice2d_}),slice3d=op({slice3d_:slice3d_}),slice4d=op({slice4d_:slice4d_});function logSumExp_(e,t,n){void 0===t&&(t=null),void 0===n&&(n=!1);var r=convertToTensor(e,\"x\",\"logSumExp\"),o=parseAxisParam(t,r.shape),a=r.max(o,!0),i=r.sub(a).exp().sum(o).log(),s=a.reshape(i.shape).add(i);if(n){var u=expandShapeToKeepDim(s.shape,o);return s.reshape(u)}return s}function sum_(e,t,n){void 0===t&&(t=null),void 0===n&&(n=!1);var r=convertToTensor(e,\"x\",\"sum\");\"bool\"===r.dtype&&(r=r.toInt());var o=parseAxisParam(t,r.shape);return customGrad(function(e){var t=getAxesPermutation(o,e.rank),r=o,a=e;null!=t&&(a=e.transpose(t),r=getInnerMostAxes(r.length,e.rank));var i=ENV.engine.runKernel(function(e){return e.sum(a,r)},{permutedX:a});if(n){var s=expandShapeToKeepDim(i.shape,o);i=i.reshape(s);}return {value:i,gradFunc:function(t){var n=e.shape.slice();return o.forEach(function(e){n[e]=1;}),t.reshape(n).mul(ones$1(e.shape,\"float32\"))}}})(r)}function prod_(e,t,n){void 0===t&&(t=null),void 0===n&&(n=!1);var r=convertToTensor(e,\"x\",\"prod\");\"bool\"===r.dtype&&(r=r.toInt());var o=parseAxisParam(t,r.shape),a=getAxesPermutation(o,r.rank),i=o,s=r;null!=a&&(s=r.transpose(a),i=getInnerMostAxes(i.length,r.rank));var u=ENV.engine.runKernel(function(e){return e.prod(s,i)},{permutedX:s});if(n){var l=expandShapeToKeepDim(u.shape,o);u=u.reshape(l);}return u}function mean_(e,t,n){void 0===t&&(t=null),void 0===n&&(n=!1);var r=convertToTensor(e,\"x\",\"mean\"),o=parseAxisParam(t,r.shape),a=sizeFromShape(computeOutAndReduceShapes(r.shape,o)[1]);return customGrad(function(e){var r=scalar(a);return {value:(r.dtype===e.dtype?e:e.cast(r.dtype)).div(r).sum(t,n),gradFunc:function(t){var n=e.shape.slice();return o.forEach(function(e){n[e]=1;}),t.reshape(n).mul(ones$1(e.shape,\"float32\")).div(r)}}})(r)}function gradForMinAndMax(e,t,n,r,o){var a=t[0];return a.rank<n.rank&&(a=a.reshape(expandShapeToKeepDim(a.shape,r))),e.rank<n.rank&&(e=e.reshape(expandShapeToKeepDim(e.shape,r))),{$x:function(){var t=e.mul(n.equal(a).cast(e.dtype));return null==o?t:t.transpose(o)}}}function min_(e,t,n){void 0===t&&(t=null),void 0===n&&(n=!1);var r=convertToTensor(e,\"x\",\"min\"),o=r,a=parseAxisParam(t,r.shape),i=a,s=getAxesPermutation(i,r.rank);null!=s&&(r=r.transpose(s),i=getInnerMostAxes(i.length,r.rank));var u=ENV.engine.runKernel(function(e,t){return t(e.min(r,i))},{$x:r},function(e,t){return gradForMinAndMax(e,t,o,a,s)});if(n){var l=expandShapeToKeepDim(u.shape,a);u=u.reshape(l);}return u}function max_(e,t,n){void 0===t&&(t=null),void 0===n&&(n=!1);var r=convertToTensor(e,\"x\",\"max\"),o=r,a=parseAxisParam(t,r.shape),i=a,s=getAxesPermutation(i,r.rank);null!=s&&(r=r.transpose(s),i=getInnerMostAxes(i.length,r.rank));var u=ENV.engine.runKernel(function(e,t){return t(e.max(r,i))},{$x:r},function(e,t){return gradForMinAndMax(e,t,o,a,s)});if(n){var l=expandShapeToKeepDim(u.shape,a);u=u.reshape(l);}return u}function argMin_(e,t){void 0===t&&(t=0);var n=convertToTensor(e,\"x\",\"argMin\");null==t&&(t=0);var r=parseAxisParam(t,n.shape),o=getAxesPermutation(r,n.rank);null!=o&&(n=n.transpose(o),r=getInnerMostAxes(r.length,n.rank));return ENV.engine.runKernel(function(e){return e.argMin(n,r[0])},{$x:n},function(e){return {$x:function(){return zerosLike(n)}}})}function argMax_(e,t){void 0===t&&(t=0);var n=convertToTensor(e,\"x\",\"argMax\");null==t&&(t=0);var r=parseAxisParam(t,n.shape),o=getAxesPermutation(r,n.rank);null!=o&&(n=n.transpose(o),r=getInnerMostAxes(r.length,n.rank));return ENV.engine.runKernel(function(e){return e.argMax(n,r[0])},{$x:n},function(e){return {$x:function(){return zerosLike(n)}}})}function all_(e,t,n){void 0===t&&(t=null),void 0===n&&(n=!1);var r=convertToTensor(e,\"x\",\"all\",\"bool\"),o=parseAxisParam(t,r.shape),a=o,i=getAxesPermutation(a,r.rank);null!=i&&(r=r.transpose(i),a=getInnerMostAxes(a.length,r.rank));var s=ENV.engine.runKernel(function(e){return e.all(r,a)},{$x:r});if(n){var u=expandShapeToKeepDim(s.shape,o);return s.reshape(u)}return s}function any_(e,t,n){void 0===t&&(t=null),void 0===n&&(n=!1);var r=convertToTensor(e,\"x\",\"any\",\"bool\"),o=parseAxisParam(t,r.shape),a=o,i=getAxesPermutation(a,r.rank);null!=i&&(r=r.transpose(i),a=getInnerMostAxes(a.length,r.rank));var s=ENV.engine.runKernel(function(e){return e.any(r,a)},{$x:r});if(n){var u=expandShapeToKeepDim(s.shape,o);return s.reshape(u)}return s}function moments_(e,t,n){void 0===t&&(t=null),void 0===n&&(n=!1);var r=parseAxisParam(t,(e=convertToTensor(e,\"x\",\"moments\")).shape),o=e.mean(r,n),a=o.shape;return n||(a=expandShapeToKeepDim(o.shape,r)),{mean:o,variance:e.toFloat().sub(o.reshape(a)).square().mean(r,n)}}var all=op({all_:all_}),any=op({any_:any_}),argMax=op({argMax_:argMax_}),argMin=op({argMin_:argMin_}),logSumExp=op({logSumExp_:logSumExp_}),max=op({max_:max_}),mean=op({mean_:mean_}),min=op({min_:min_}),moments=op({moments_:moments_}),sum$1=op({sum_:sum_}),prod=op({prod_:prod_});function notEqual_(e,t){var n,r=convertToTensor(e,\"a\",\"notEqual\"),o=convertToTensor(t,\"b\",\"notEqual\");return n=makeTypesMatch(r,o),r=n[0],o=n[1],assertAndGetBroadcastShape(r.shape,o.shape),ENV.engine.runKernel(function(e){return e.notEqual(r,o)},{$a:r,$b:o})}function notEqualStrict_(e,t){var n=convertToTensor(e,\"a\",\"notEqualStrict\"),r=convertToTensor(t,\"b\",\"notEqualStrict\");return assertShapesMatch(n.shape,r.shape,\"Error in notEqualStrict: \"),n.notEqual(r)}function less_(e,t){var n,r=convertToTensor(e,\"a\",\"less\"),o=convertToTensor(t,\"b\",\"less\");return n=makeTypesMatch(r,o),r=n[0],o=n[1],assertAndGetBroadcastShape(r.shape,o.shape),ENV.engine.runKernel(function(e){return e.less(r,o)},{$a:r,$b:o})}function lessStrict_(e,t){var n=convertToTensor(e,\"a\",\"lessStrict\"),r=convertToTensor(t,\"b\",\"lessStrict\");return assertShapesMatch(n.shape,r.shape,\"Error in lessStrict: \"),n.less(r)}function equal_(e,t){var n,r=convertToTensor(e,\"a\",\"equal\"),o=convertToTensor(t,\"b\",\"equal\");return n=makeTypesMatch(r,o),r=n[0],o=n[1],assertAndGetBroadcastShape(r.shape,o.shape),ENV.engine.runKernel(function(e){return e.equal(r,o)},{$a:r,$b:o})}function equalStrict_(e,t){var n=convertToTensor(e,\"a\",\"equalStrict\"),r=convertToTensor(t,\"b\",\"equalStrict\");return assertShapesMatch(n.shape,r.shape,\"Error in equalStrict: \"),n.equal(r)}function lessEqual_(e,t){var n,r=convertToTensor(e,\"a\",\"lessEqual\"),o=convertToTensor(t,\"b\",\"lessEqual\");return n=makeTypesMatch(r,o),r=n[0],o=n[1],assertAndGetBroadcastShape(r.shape,o.shape),ENV.engine.runKernel(function(e){return e.lessEqual(r,o)},{$a:r,$b:o})}function lessEqualStrict_(e,t){var n=convertToTensor(e,\"a\",\"lessEqualStrict\"),r=convertToTensor(t,\"b\",\"lessEqualStrict\");return assertShapesMatch(n.shape,r.shape,\"Error in lessEqualStrict: \"),n.lessEqual(r)}function greater_(e,t){var n,r=convertToTensor(e,\"a\",\"greater\"),o=convertToTensor(t,\"b\",\"greater\");return n=makeTypesMatch(r,o),r=n[0],o=n[1],assertAndGetBroadcastShape(r.shape,o.shape),ENV.engine.runKernel(function(e){return e.greater(r,o)},{$a:r,$b:o})}function greaterStrict_(e,t){var n=convertToTensor(e,\"a\",\"greaterStrict\"),r=convertToTensor(t,\"b\",\"greaterStrict\");return assertShapesMatch(n.shape,r.shape,\"Error in greaterStrict: \"),n.greater(r)}function greaterEqual_(e,t){var n,r=convertToTensor(e,\"a\",\"greaterEqual\"),o=convertToTensor(t,\"b\",\"greaterEqual\");n=makeTypesMatch(r,o),r=n[0],o=n[1],assertAndGetBroadcastShape(r.shape,o.shape);return ENV.engine.runKernel(function(e){return e.greaterEqual(r,o)},{$a:r,$b:o},function(e){return {$a:function(){return zerosLike(r)},$b:function(){return zerosLike(o)}}})}function greaterEqualStrict_(e,t){var n=convertToTensor(e,\"a\",\"greaterEqualStrict\"),r=convertToTensor(t,\"b\",\"greaterEqualStrict\");return assertShapesMatch(n.shape,r.shape,\"Error in greaterEqualStrict: \"),n.greaterEqual(r)}var equal=op({equal_:equal_}),equalStrict=op({equalStrict_:equalStrict_}),greater=op({greater_:greater_}),greaterEqual=op({greaterEqual_:greaterEqual_}),greaterEqualStrict=op({greaterEqualStrict_:greaterEqualStrict_}),greaterStrict=op({greaterStrict_:greaterStrict_}),less=op({less_:less_}),lessEqual=op({lessEqual_:lessEqual_}),lessEqualStrict=op({lessEqualStrict_:lessEqualStrict_}),lessStrict=op({lessStrict_:lessStrict_}),notEqual=op({notEqual_:notEqual_}),notEqualStrict=op({notEqualStrict_:notEqualStrict_});function add_(e,t){var n,r=convertToTensor(e,\"a\",\"add\"),o=convertToTensor(t,\"b\",\"add\");n=makeTypesMatch(r,o),r=n[0],o=n[1];var a=assertAndGetBroadcastShape(r.shape,o.shape);return ENV.engine.runKernel(function(e){return e.add(r,o)},{$a:r,$b:o},function(e){return {$a:function(){var t=e,n=getReductionAxes(r.shape,a);return n.length>0&&(t=t.sum(n)),t.reshape(r.shape)},$b:function(){var t=e,n=getReductionAxes(o.shape,a);return n.length>0&&(t=t.sum(n)),t.reshape(o.shape)}}})}function addN_(e){assert(Array.isArray(e),function(){return \"The argument passed to tf.addN() must be a list of tensors\"}),assert(e.length>=1,function(){return \"Must pass at least one tensor to tf.addN(), but got \"+e.length});var t=e.map(function(e,t){return convertToTensor(e,\"tensors\"+t,\"addN\")}),n=t[0];t.forEach(function(e){if(e.dtype!==n.dtype)throw new Error(\"All tensors passed to tf.addN() must have the same dtype\")}),t.forEach(function(e){if(!arraysEqual(e.shape,n.shape))throw new Error(\"All tensors passed to tf.addN() must have the same shape\")});var r=t;return ENV.engine.runKernel(function(e){return e.addN(t)},r,function(e){var n={};return t.forEach(function(t,r){n[r]=function(){return e.clone()};}),n})}function addStrict_(e,t){var n=convertToTensor(e,\"a\",\"addStrict\"),r=convertToTensor(t,\"b\",\"addStrict\");return assertShapesMatch(n.shape,r.shape,\"Error in addStrict: \"),n.add(r)}function sub_(e,t){var n,r=convertToTensor(e,\"a\",\"sub\"),o=convertToTensor(t,\"b\",\"sub\");n=makeTypesMatch(r,o),r=n[0],o=n[1];var a=assertAndGetBroadcastShape(r.shape,o.shape);return ENV.engine.runKernel(function(e){return e.subtract(r,o)},{$a:r,$b:o},function(e){return {$a:function(){var t=e,n=getReductionAxes(r.shape,a);return n.length>0&&(t=t.sum(n)),t.reshape(r.shape)},$b:function(){var t=e,n=getReductionAxes(o.shape,a);return n.length>0&&(t=t.sum(n)),t.neg().reshape(o.shape)}}})}function subStrict_(e,t){var n=convertToTensor(e,\"a\",\"subStrict\"),r=convertToTensor(t,\"b\",\"subStrict\");return assertShapesMatch(n.shape,r.shape,\"Error in subStrict: \"),n.sub(r)}function pow_(e,t){var n=convertToTensor(e,\"base\",\"pow\"),r=convertToTensor(t,\"exp\",\"pow\"),o=assertAndGetBroadcastShape(n.shape,r.shape);e=n.cast(upcastType(n.dtype,r.dtype)),t=r.cast(upcastType(n.dtype,r.dtype));return ENV.engine.runKernel(function(e,t){return t(e.pow(n,r))},{$base:n,$exp:r},function(e,t){var a=t[0];return {$base:function(){var t=r.toFloat(),a=e.mul(t.mul(n.pow(t.sub(scalar(1))))),i=getReductionAxes(n.shape,o);return i.length>0&&(a=a.sum(i)),a.reshape(n.shape)},$exp:function(){var t=e.mul(a.mul(n.log()).toFloat()),i=getReductionAxes(r.shape,o);return i.length>0&&(t=t.sum(i)),t.reshape(r.shape)}}})}function powStrict_(e,t){return assertShapesMatch(e.shape,t.shape,\"Error in powStrict: \"),e.pow(t)}function mul_(e,t){var n,r=convertToTensor(e,\"a\",\"mul\"),o=convertToTensor(t,\"b\",\"mul\");n=makeTypesMatch(r,o),r=n[0],o=n[1];var a=assertAndGetBroadcastShape(r.shape,o.shape);return ENV.engine.runKernel(function(e){return e.multiply(r,o)},{$a:r,$b:o},function(e){return {$a:function(){var t=e.mul(o.toFloat()),n=getReductionAxes(r.shape,a);return n.length>0?t.sum(n).reshape(r.shape):t},$b:function(){var t=e.mul(r.toFloat()),n=getReductionAxes(o.shape,a);return n.length>0?t.sum(n).reshape(o.shape):t}}})}function mulStrict_(e,t){var n=convertToTensor(e,\"a\",\"mul\"),r=convertToTensor(t,\"b\",\"mul\");return assertShapesMatch(n.shape,r.shape,\"Error in multiplyStrict: \"),n.mul(r)}function div_(e,t){var n,r,o=convertToTensor(e,\"a\",\"div\"),a=convertToTensor(t,\"b\",\"div\");if(n=makeTypesMatch(o,a),o=n[0],a=n[1],\"int32\"===o.dtype&&\"int32\"===a.dtype)return floorDiv(o,a);r=function(e){return e.realDivide(o,a)};var i=assertAndGetBroadcastShape(o.shape,a.shape);return ENV.engine.runKernel(r,{$a:o,$b:a},function(e){return {$a:function(){var t=e.div(a.toFloat()),n=getReductionAxes(o.shape,i);return n.length>0?t.sum(n).reshape(o.shape):t},$b:function(){var t=e.mul(o.toFloat()),n=getReductionAxes(a.shape,i);n.length>0&&(t=t.sum(n).reshape(a.shape));var r=a.square();return t.div(r.toFloat()).neg()}}})}function floorDiv_(e,t){var n,r=convertToTensor(e,\"a\",\"floorDiv\"),o=convertToTensor(t,\"b\",\"floorDiv\");n=makeTypesMatch(r,o),r=n[0],o=n[1];var a=assertAndGetBroadcastShape(r.shape,o.shape);return ENV.engine.runKernel(function(e){return e.floorDiv(r,o)},{$a:r,$b:o},function(e){return {$a:function(){var t=e.div(o.toFloat()),n=getReductionAxes(r.shape,a);return n.length>0?t.sum(n).reshape(r.shape):t},$b:function(){var t=e.mul(r.toFloat()),n=getReductionAxes(o.shape,a);n.length>0&&(t=t.sum(n).reshape(o.shape));var i=o.square();return t.div(i.toFloat()).neg()}}})}function divStrict_(e,t){var n=convertToTensor(e,\"a\",\"div\"),r=convertToTensor(t,\"b\",\"div\");return assertShapesMatch(n.shape,r.shape,\"Error in divideStrict: \"),n.div(r)}function mod_(e,t){var n,r=convertToTensor(e,\"a\",\"mod\"),o=convertToTensor(t,\"b\",\"mod\");n=makeTypesMatch(r,o),r=n[0],o=n[1];var a=assertAndGetBroadcastShape(r.shape,o.shape);return ENV.engine.runKernel(function(e){return e.mod(r,o)},{$a:r,$b:o},function(e){return {$a:function(){var t=getReductionAxes(r.shape,a);return t.length>0?e.sum(t).reshape(r.shape):e},$b:function(){var t=e.mul(r.div(o).floor().neg()),n=getReductionAxes(o.shape,a);return n.length>0?t.sum(n).reshape(o.shape):t}}})}function modStrict_(e,t){var n=convertToTensor(e,\"a\",\"modStrict\"),r=convertToTensor(t,\"b\",\"modStrict\");return assertShapesMatch(n.shape,r.shape,\"Error in modStrict: \"),n.mod(r)}function minimum_(e,t){var n,r=convertToTensor(e,\"a\",\"minimum\"),o=convertToTensor(t,\"b\",\"minimum\");n=makeTypesMatch(r,o),r=n[0],o=n[1],\"bool\"===r.dtype&&(r=r.toInt(),o=o.toInt()),assertAndGetBroadcastShape(r.shape,o.shape);return ENV.engine.runKernel(function(e){return e.minimum(r,o)},{$a:r,$b:o},function(e){return {$a:function(){return e.mul(r.lessEqual(o).toFloat())},$b:function(){return e.mul(r.greater(o).toFloat())}}})}function minimumStrict_(e,t){var n=convertToTensor(e,\"a\",\"minimumStrict\"),r=convertToTensor(t,\"b\",\"minimumStrict\");return assertShapesMatch(n.shape,r.shape,\"Error in minimumStrict: \"),n.minimum(r)}function maximum_(e,t){var n,r=convertToTensor(e,\"a\",\"maximum\"),o=convertToTensor(t,\"b\",\"maximum\");n=makeTypesMatch(r,o),r=n[0],o=n[1],\"bool\"===r.dtype&&(r=r.toInt(),o=o.toInt()),assertAndGetBroadcastShape(r.shape,o.shape);return ENV.engine.runKernel(function(e){return e.maximum(r,o)},{$a:r,$b:o},function(e){return {$a:function(){return e.mul(r.greaterEqual(o).toFloat())},$b:function(){return e.mul(r.less(o).toFloat())}}})}function maximumStrict_(e,t){var n=convertToTensor(e,\"a\",\"maximumStrict\"),r=convertToTensor(t,\"b\",\"maximumStrict\");return assertShapesMatch(n.shape,r.shape,\"Error in maximumStrict: \"),n.maximum(r)}function squaredDifference_(e,t){var n,r=convertToTensor(e,\"a\",\"squaredDifference\"),o=convertToTensor(t,\"b\",\"squaredDifference\");n=makeTypesMatch(r,o),r=n[0],o=n[1],assertAndGetBroadcastShape(r.shape,o.shape);return ENV.engine.runKernel(function(e){return e.squaredDifference(r,o)},{$a:r,$b:o},function(e){var t=scalar(2);return {$a:function(){return e.mul(r.sub(o).mul(t))},$b:function(){return e.mul(o.sub(r).mul(t))}}})}function squaredDifferenceStrict_(e,t){var n=convertToTensor(e,\"a\",\"squaredDifferenceStrict\"),r=convertToTensor(t,\"b\",\"squaredDifferenceStrict\");return assertShapesMatch(n.shape,r.shape,\"Error in squaredDifferenceStrict: \"),n.squaredDifference(r)}function atan2_(e,t){var n,r=convertToTensor(e,\"a\",\"atan2\"),o=convertToTensor(t,\"b\",\"atan2\");n=makeTypesMatch(r,o),r=n[0],o=n[1];var a=assertAndGetBroadcastShape(r.shape,o.shape);return ENV.engine.runKernel(function(e){return e.atan2(r,o)},{$a:r,$b:o},function(e){return {$a:function(){var t=add(r.square(),o.square()),n=e.mul(o.div(t)),i=getReductionAxes(r.shape,a);return i.length>0&&(n=n.sum(i)),n.reshape(r.shape)},$b:function(){var t=add(r.square(),o.square()),n=neg(e.mul(r.div(t))),i=getReductionAxes(o.shape,a);return i.length>0&&(n=n.sum(i)),n.reshape(o.shape)}}})}var add=op({add_:add_}),addN=op({addN_:addN_}),addStrict=op({addStrict_:addStrict_}),atan2=op({atan2_:atan2_}),div=op({div_:div_}),divStrict=op({divStrict_:divStrict_}),floorDiv=op({floorDiv_:floorDiv_}),maximum=op({maximum_:maximum_}),maximumStrict=op({maximumStrict_:maximumStrict_}),minimum=op({minimum_:minimum_}),minimumStrict=op({minimumStrict_:minimumStrict_}),mod=op({mod_:mod_}),modStrict=op({modStrict_:modStrict_}),mul=op({mul_:mul_}),mulStrict=op({mulStrict_:mulStrict_}),pow=op({pow_:pow_}),powStrict=op({powStrict_:powStrict_}),squaredDifference=op({squaredDifference_:squaredDifference_}),squaredDifferenceStrict=op({squaredDifferenceStrict_:squaredDifferenceStrict_}),sub=op({sub_:sub_}),subStrict=op({subStrict_:subStrict_});function logicalNot_(e){var t=convertToTensor(e,\"x\",\"logicalNot\",\"bool\");return ENV.engine.runKernel(function(e){return e.logicalNot(t)},{$x:t})}function logicalAnd_(e,t){var n=convertToTensor(e,\"a\",\"logicalAnd\",\"bool\"),r=convertToTensor(t,\"b\",\"logicalAnd\",\"bool\");return assertAndGetBroadcastShape(n.shape,r.shape),ENV.engine.runKernel(function(e){return e.logicalAnd(n,r)},{$a:n,$b:r})}function logicalOr_(e,t){var n=convertToTensor(e,\"a\",\"logicalOr\",\"bool\"),r=convertToTensor(t,\"b\",\"logicalOr\",\"bool\");return assertAndGetBroadcastShape(n.shape,r.shape),ENV.engine.runKernel(function(e){return e.logicalOr(n,r)},{$a:n,$b:r})}function logicalXor_(e,t){var n=convertToTensor(e,\"a\",\"logicalXor\",\"bool\"),r=convertToTensor(t,\"b\",\"logicalXor\",\"bool\");return assertAndGetBroadcastShape(n.shape,r.shape),logicalOr(e,t).logicalAnd(logicalAnd(e,t).logicalNot())}function where_(e,t,n){var r=convertToTensor(t,\"a\",\"where\"),o=convertToTensor(n,\"b\",\"where\"),a=convertToTensor(e,\"condition\",\"where\",\"bool\");assertShapesMatch(r.shape,o.shape,\"Error in where: \"),1===a.rank?assert(a.shape[0]===r.shape[0],\"The first dimension of `a` must match the size of `condition`.\"):assertShapesMatch(a.shape,o.shape,\"Error in where: \");return ENV.engine.runKernel(function(e){return e.select(a,r,o)},{$condition:a,$a:r,$b:o},function(e){return {$condition:function(){return zerosLike(a).toFloat()},$a:function(){return e.mul(a.cast(e.dtype))},$b:function(){return e.mul(a.logicalNot().cast(e.dtype))}}})}function whereAsync_(e){return __awaiter(this,void 0,void 0,function(){var t,n,r;return __generator(this,function(o){switch(o.label){case 0:return [4,(t=convertToTensor(e,\"condition\",\"whereAsync\",\"bool\")).data()];case 1:return n=o.sent(),r=whereImpl(t.shape,n),e!==t&&t.dispose(),[2,r]}})})}var logicalAnd=op({logicalAnd_:logicalAnd_}),logicalNot=op({logicalNot_:logicalNot_}),logicalOr=op({logicalOr_:logicalOr_}),logicalXor=op({logicalXor_:logicalXor_}),where=op({where_:where_}),whereAsync=whereAsync_;function relu_(e){var t=convertToTensor(e,\"x\",\"relu\");if(\"bool\"===t.dtype)return t.toInt();return ENV.engine.runKernel(function(e){return e.relu(t)},{$x:t},function(e){var n=t.step();return {$x:function(){return e.mulStrict(n.toFloat())}}})}function elu_(e){var t=convertToTensor(e,\"x\",\"elu\");return ENV.engine.runKernel(function(e,n){return n(e.elu(t))},{$x:t},function(e,t){var n=t[0];return {$x:function(){return ENV.engine.runKernel(function(t){return t.eluDer(e,n)},{dy:e,y:n})}}})}function selu_(e){var t=convertToTensor(e,\"x\",\"selu\");return ENV.engine.runKernel(function(e){return e.selu(t)},{$x:t},function(e){return {$x:function(){var n=t.greater(scalar(0)),r=scalar(SELU_SCALEALPHA),o=scalar(SELU_SCALE),a=e.mul(o),i=e.mul(r).mul(t.toFloat().exp());return where(n,a,i)}}})}function leakyRelu_(e,t){void 0===t&&(t=.2);var n=convertToTensor(e,\"x\",\"leakyRelu\");return maximum(scalar(t).mul(n),n)}function prelu_(e,t){var n=convertToTensor(e,\"x\",\"prelu\"),r=convertToTensor(t,\"alpha\",\"prelu\"),o=scalar(0);return maximum(o,n).add(r.mul(minimum(o,n)))}var elu=op({elu_:elu_}),leakyRelu=op({leakyRelu_:leakyRelu_}),prelu=op({prelu_:prelu_}),relu=op({relu_:relu_}),selu=op({selu_:selu_});function transpose_(e,t){var n=convertToTensor(e,\"x\",\"transpose\");if(null==t&&(t=n.shape.map(function(e,t){return t}).reverse()),assert(n.rank===t.length,\"Error in transpose: rank of input \"+n.rank+\" must match length of perm \"+t+\".\"),t.forEach(function(e){assert(e>=0&&e<n.rank,\"All entries in 'perm' must be between 0 and \"+(n.rank-1)+\" but got \"+t);}),n.rank<=1)return n.clone();return ENV.engine.runKernel(function(e){return e.transpose(n,t)},{$x:n},function(e){var n=getUndoAxesPermutation(t);return {$x:function(){return e.transpose(n)}}})}var transpose=op({transpose_:transpose_});function localResponseNormalization_(e,t,n,r,o){void 0===t&&(t=5),void 0===n&&(n=1),void 0===r&&(r=1),void 0===o&&(o=.5);var a=convertToTensor(e,\"x\",\"localResponseNormalization\");assert(4===a.rank||3===a.rank,\"Error in localResponseNormalization: x must be rank 3 or 4 but got\\n               rank \"+a.rank+\".\"),assert(isInt(t),\"Error in localResponseNormalization: depthRadius must be an integer\\n                     but got depthRadius \"+t+\".\");var i=a,s=!1;3===a.rank&&(s=!0,i=a.as4D(1,a.shape[0],a.shape[1],a.shape[2]));var u=ENV.engine.runKernel(function(e,a){return a(e.localResponseNormalization4D(i,t,n,r,o))},{x4D:i},function(e,a){var s=a[0];return {x4D:function(){return ENV.engine.runKernel(function(a){return a.LRNGrad(e,i,s,t,n,r,o)},{})}}});return s?u.as3D(u.shape[1],u.shape[2],u.shape[3]):u}var localResponseNormalization=op({localResponseNormalization_:localResponseNormalization_});function norm_(e,t,n,r){void 0===t&&(t=\"euclidean\"),void 0===n&&(n=null),void 0===r&&(r=!1);var o=normImpl(e=convertToTensor(e,\"x\",\"norm\"),t,n),a=o.shape;if(r){var i=parseAxisParam(n,e.shape);a=expandShapeToKeepDim(o.shape,i);}return o.reshape(a)}function normImpl(e,t,n){if(void 0===n&&(n=null),0===e.rank)return e.abs();if(1!==e.rank&&null===n)return normImpl(e.reshape([-1]),t,n);if(1===e.rank||\"number\"==typeof n||n instanceof Array&&1===n.length){if(1===t)return e.abs().sum(n);if(t===1/0)return e.abs().max(n);if(t===-1/0)return e.abs().min(n);if(\"euclidean\"===t||2===t)return e.abs().pow(scalar(2,\"int32\")).sum(n).sqrt();throw new Error(\"Error in norm: invalid ord value: \"+t)}if(n instanceof Array&&2===n.length){if(1===t)return e.abs().sum(n[0]).max(n[1]-1);if(t===1/0)return e.abs().sum(n[1]).max(n[0]);if(t===-1/0)return e.abs().sum(n[1]).min(n[0]);if(\"fro\"===t||\"euclidean\"===t)return e.square().sum(n).sqrt();throw new Error(\"Error in norm: invalid ord value: \"+t)}throw new Error(\"Error in norm: invalid axis: \"+n)}var norm=op({norm_:norm_});function unsortedSegmentSum_(e,t,n){var r=convertToTensor(e,\"x\",\"unsortedSegmentSum\"),o=convertToTensor(t,\"segmentIds\",\"unsortedSegmentSum\",\"int32\");assert(isInt(n),\"numSegments must be of dtype int\");return ENV.engine.runKernel(function(e){return e.unsortedSegmentSum(r,o,n)},{$x:r},function(e){return {$x:function(){return gatherDropNegatives(e,o)}}})}function gather_(e,t,n){void 0===n&&(n=0);var r=convertToTensor(e,\"x\",\"gather\"),o=convertToTensor(t,\"indices\",\"gather\",\"int32\");n=parseAxisParam(n,r.shape)[0];return ENV.engine.runKernel(function(e){return e.gather(r,o,n)},{$x:r},function(e){return {$x:function(){if(0===n)return unsortedSegmentSum(e,o,r.shape[n]);var t=r.shape,a=o.size,i=t.slice(0,n),s=i.length,u=t.slice(n,t.length).slice(1),l=u.length,c=arrayRange(0,s),p=arrayRange(s+1,s+1+l),d=arrayConcat([i,[a],u]),h=e.reshape(d),f=o.reshape([a]),m=arrayConcat([[s],c,p]),g=h.transpose(m),v=unsortedSegmentSum(g,f,r.shape[n]),y=getUndoAxesPermutation(m);return v=v.transpose(y)}}})}function arrayRange(e,t){for(var n=[],r=e;r<t;++r)n.push(r);return n}function arrayConcat(e){for(var t=[],n=0;n<e.length;++n)for(var r=0;r<e[n].length;++r)t.push(e[n][r]);return t}function gatherDropNegatives(e,t){for(var n=maximum(t,zerosLike(t)),r=gather(e,n),o=greaterEqual(t,scalar(0,\"int32\")),a=r.rank-o.rank,i=0;i<a;++i)o=expandDims(o,i+1);o=logicalAnd(o,ones$1(r.shape,\"bool\"));var s=zerosLike(r);return where(o,r,s)}var gather=op({gather_:gather_}),unsortedSegmentSum=op({unsortedSegmentSum_:unsortedSegmentSum_});function multiRNNCell_(e,t,n,r){for(var o=convertToTensor(t,\"data\",\"multiRNNCell\"),a=convertToTensorArray(n,\"c\",\"multiRNNCell\"),i=convertToTensorArray(r,\"h\",\"multiRNNCell\"),s=o,u=[],l=0;l<e.length;l++){var c=e[l](s,a[l],i[l]);u.push(c[0]),u.push(c[1]),s=c[1];}var p=[],d=[];for(l=0;l<u.length;l+=2)p.push(u[l]),d.push(u[l+1]);return [p,d]}function basicLSTMCell_(e,t,n,r,o,a){var i=convertToTensor(e,\"forgetBias\",\"basicLSTMCell\"),s=convertToTensor(t,\"lstmKernel\",\"basicLSTMCell\"),u=convertToTensor(n,\"lstmBias\",\"basicLSTMCell\"),l=convertToTensor(r,\"data\",\"basicLSTMCell\"),c=convertToTensor(o,\"c\",\"basicLSTMCell\"),p=convertToTensor(a,\"h\",\"basicLSTMCell\"),d=l.concat(p,1).matMul(s).add(u),h=d.shape[0],f=d.shape[1]/4,m=[h,f],g=d.slice([0,0],m),v=d.slice([0,f],m),y=d.slice([0,2*f],m),x=d.slice([0,3*f],m),T=g.sigmoid().mulStrict(v.tanh()).addStrict(c.mulStrict(i.add(y).sigmoid()));return [T,T.tanh().mulStrict(x.sigmoid())]}var basicLSTMCell=op({basicLSTMCell_:basicLSTMCell_}),multiRNNCell=op({multiRNNCell_:multiRNNCell_});function movingAverage_(e,t,n,r,o){void 0===o&&(o=!0);var a=convertToTensor(e,\"v\",\"movingAverage\"),i=convertToTensor(t,\"x\",\"movingAverage\"),s=convertToTensor(n,\"decay\",\"movingAverage\");assertTypesMatch(a,i),assert(arraysEqual(a.shape,i.shape),\"Shape mismatch in v and x\");var u=scalar(1),l=u.sub(s),c=i.sub(a).mul(l);if(o){assert(null!=r,\"When using zeroDebias: true, step is required.\");var p=convertToTensor(r,\"step\",\"movingAverage\");c=c.div(u.sub(pow(s,p)));}return a.add(c)}var movingAverage=op({movingAverage_:movingAverage_});function stridedSlice_(e,t,n,r,o,a,i,s,u){if(void 0===o&&(o=0),void 0===a&&(a=0),void 0===i&&(i=0),void 0===s&&(s=0),void 0===u&&(u=0),0!==i)throw new Error(\"ellipsis mask is not yet supported\");if(0!==s)throw new Error(\"new axis mask is not yet supported\");var l=convertToTensor(e,\"x\",\"stridedSlice\");return ENV.engine.runKernel(function(e){return e.stridedSlice(l,t,n,r,o,a,i,s,u)},{$x:l})}var stridedSlice=op({stridedSlice_:stridedSlice_});function topk_(e,t,n){void 0===t&&(t=1),void 0===n&&(n=!0);var r=convertToTensor(e,\"x\",\"topk\");if(0===r.rank)throw new Error(\"topk() expects the input to be of rank 1 or higher\");var o=r.shape[r.shape.length-1];if(t>o)throw new Error(\"'k' passed to topk() must be <= the last dimension (\"+o+\") but got \"+t);var a=ENV.engine.runKernel(function(e){return e.topk(r,t,n)},{$x:r});return {values:a[0],indices:a[1]}}var topk=op({topk_:topk_});function scatterND_(e,t,n){var r=convertToTensor(e,\"indices\",\"scatterND\",\"int32\"),o=convertToTensor(t,\"updates\",\"scatterND\");return validateInput(o,r,n),ENV.engine.runKernel(function(e){return e.scatterND(r,o,n)},{$indices:r,$updates:o})}var scatterND=op({scatterND_:scatterND_});function fft_(e){assert(\"complex64\"===e.dtype,\"The dtype for tf.spectral.fft() must be complex64 but got \"+e.dtype+\".\");var t=e.shape[e.shape.length-1],n=e.size/t,r=e.as2D(n,t);return ENV.engine.runKernel(function(e){return e.fft(r)},{input:e}).reshape(e.shape)}function ifft_(e){assert(\"complex64\"===e.dtype,\"The dtype for tf.spectral.ifft() must be complex64 but got \"+e.dtype+\".\");var t=e.shape[e.shape.length-1],n=e.size/t,r=e.as2D(n,t);return ENV.engine.runKernel(function(e){return e.ifft(r)},{input:e}).reshape(e.shape)}function rfft_(e){assert(\"float32\"===e.dtype,\"The dtype for rfft() must be real value but\\n    got \"+e.dtype);var t=e.shape[e.shape.length-1],n=e.size/t,r=e.zerosLike(),o=complex(e,r).as2D(n,t),a=fft(o),i=Math.floor(t/2)+1,s=real(a),u=imag(a),l=s.split([i,t-i],s.shape.length-1),c=u.split([i,t-i],u.shape.length-1),p=e.shape.slice();return p[e.shape.length-1]=i,complex(l[0],c[0]).reshape(p)}function irfft_(e){var t=e.shape[e.shape.length-1],n=e.size/t;if(t<=2){var r=e.as2D(n,t),o=ifft(r);return real(o)}var a=[n,2*(t-1)],i=real(e).as2D(n,t),s=imag(e).as2D(n,t),u=i.slice([0,1],[n,t-2]).reverse(1),l=s.slice([0,1],[n,t-2]).reverse(1).mul(scalar(-1)),c=i.concat(u,1),p=s.concat(l,1);r=complex(c,p).as2D(a[0],a[1]),o=ifft(r);return real(o)}var fft=op({fft_:fft_}),ifft=op({ifft_:ifft_}),rfft=op({rfft_:rfft_}),irfft=op({irfft_:irfft_}),spectral_ops=Object.freeze({fft:fft,ifft:ifft,rfft:rfft,irfft:irfft});function validateInput$1(e,t,n,r){if(\"int32\"!==e.dtype)throw new Error(\"tf.sparseToDense() expects the indices to be int32 type, but the dtype was \"+e.dtype+\".\");if(e.rank>2)throw new Error(\"sparseIndices should be a scalar, vector, or matrix, but got shape \"+e.shape+\".\");var o=e.rank>0?e.shape[0]:1,a=e.rank>1?e.shape[1]:1;if(n.length!==a)throw new Error(\"outputShape has incorrect number of elements:, \"+n.length+\", should be: \"+a+\".\");var i=t.size;if(0!==t.rank&&(1!==t.rank||i!==o))throw new Error(\"sparseValues has incorrect shape \"+t.shape+\", should be [] or [\"+o+\"]\");if(t.dtype!==r.dtype)throw new Error(\"sparseValues.dtype must match defaultValues.dtype\")}function sparseToDense_(e,t,n,r){var o=convertToTensor(e,\"sparseIndices\",\"sparseToDense\",\"int32\"),a=convertToTensor(t,\"sparseValues\",\"sparseToDense\"),i=convertToTensor(r,\"defaultValue\",\"sparseToDense\",a.dtype);return validateInput$1(o,a,n,i),ENV.engine.runKernel(function(e){return e.sparseToDense(o,a,n,i)},{$sparseIndices:o,$sparseValues:a,$defaultValue:i})}var sparseToDense=op({sparseToDense_:sparseToDense_});function gatherND_(e,t){var n=convertToTensor(t,\"indices\",\"gatherND\",\"int32\"),r=convertToTensor(e,\"x\",\"gatherND\");return ENV.engine.runKernel(function(e){return e.gatherND(r,n)},{$x:r,$indices:n})}var Reduction,gatherND=op({gatherND_:gatherND_});function computeWeightedLoss_(e,t,n){void 0===n&&(n=Reduction.SUM_BY_NONZERO_WEIGHTS);var r=convertToTensor(e,\"losses\",\"computeWeightedLoss\"),o=null;null!=t&&(o=convertToTensor(t,\"weights\",\"computeWeightedLoss\"));var a=null==o?r:r.mul(o);if(n===Reduction.NONE)return a;if(n===Reduction.SUM)return a.sum();if(n===Reduction.MEAN){if(null==o)return a.mean();var i=sizeFromShape(r.shape)/sizeFromShape(o.shape),s=a.sum().div(o.sum());return i>1?s.div(scalar(i)):s}if(n===Reduction.SUM_BY_NONZERO_WEIGHTS){if(null==o)return a.sum().div(scalar(r.size));var u=o.mul(ones$1(r.shape)).notEqual(scalar(0)).sum().toFloat();return a.sum().div(u)}throw Error(\"Unknown reduction: \"+n)}function absoluteDifference_(e,t,n,r){void 0===r&&(r=Reduction.SUM_BY_NONZERO_WEIGHTS);var o=convertToTensor(e,\"labels\",\"absoluteDifference\"),a=convertToTensor(t,\"predictions\",\"absoluteDifference\"),i=null;null!=n&&(i=convertToTensor(n,\"weights\",\"absoluteDifference\")),assertShapesMatch(o.shape,a.shape,\"Error in absoluteDifference: \");var s=o.sub(a).abs();return computeWeightedLoss(s,i,r)}function meanSquaredError_(e,t,n,r){void 0===r&&(r=Reduction.SUM_BY_NONZERO_WEIGHTS);var o=convertToTensor(e,\"labels\",\"meanSquaredError\"),a=convertToTensor(t,\"predictions\",\"meanSquaredError\"),i=null;null!=n&&(i=convertToTensor(n,\"weights\",\"meanSquaredError\")),assertShapesMatch(o.shape,a.shape,\"Error in meanSquaredError: \");var s=o.squaredDifference(a);return computeWeightedLoss(s,i,r)}function cosineDistance_(e,t,n,r,o){void 0===o&&(o=Reduction.SUM_BY_NONZERO_WEIGHTS);var a=convertToTensor(e,\"labels\",\"cosineDistance\"),i=convertToTensor(t,\"predictions\",\"cosineDistance\"),s=null;null!=r&&(s=convertToTensor(r,\"weights\",\"cosineDistance\")),assertShapesMatch(a.shape,i.shape,\"Error in cosineDistance: \");var u=scalar(1).sub(a.mul(i).sum(n,!0));return computeWeightedLoss(u,s,o)}function hingeLoss_(e,t,n,r){void 0===r&&(r=Reduction.SUM_BY_NONZERO_WEIGHTS);var o=convertToTensor(e,\"labels\",\"hingeLoss\"),a=convertToTensor(t,\"predictions\",\"hingeLoss\"),i=null;null!=n&&(i=convertToTensor(n,\"weights\",\"hingeLoss\")),assertShapesMatch(o.shape,a.shape,\"Error in hingeLoss: \");var s=scalar(1);o=scalar(2).mul(o).sub(s);var u=s.sub(o.mul(a)).relu();return computeWeightedLoss(u,i,r)}function logLoss_(e,t,n,r,o){void 0===r&&(r=1e-7),void 0===o&&(o=Reduction.SUM_BY_NONZERO_WEIGHTS);var a=convertToTensor(e,\"labels\",\"logLoss\"),i=convertToTensor(t,\"predictions\",\"logLoss\"),s=null;null!=n&&(s=convertToTensor(n,\"weights\",\"logLoss\")),assertShapesMatch(a.shape,i.shape,\"Error in logLoss: \");var u=scalar(1),l=scalar(r),c=a.mul(i.add(l).log()).neg().sub(u.sub(a).mul(u.sub(i).add(l).log()));return computeWeightedLoss(c,s,o)}function sigmoidCrossEntropyWithLogits_(e,t){var n=convertToTensor(e,\"labels\",\"sigmoidCrossEntropyWithLogits\"),r=convertToTensor(t,\"logits\",\"sigmoidCrossEntropyWithLogits\");assertShapesMatch(n.shape,r.shape,\"Error in sigmoidCrossEntropyWithLogits: \");var o=r.relu(),a=r.mul(n),i=r.abs().neg().exp().log1p();return o.sub(a).add(i)}function sigmoidCrossEntropy_(e,t,n,r,o){void 0===r&&(r=0),void 0===o&&(o=Reduction.SUM_BY_NONZERO_WEIGHTS);var a=convertToTensor(e,\"multiClassLabels\",\"sigmoidCrossEntropy\"),i=convertToTensor(t,\"logits\",\"sigmoidCrossEntropy\"),s=null;if(null!=n&&(s=convertToTensor(n,\"weights\",\"sigmoidCrossEntropy\")),assertShapesMatch(a.shape,i.shape,\"Error in sigmoidCrossEntropy: \"),r>0){var u=scalar(r),l=scalar(1),c=scalar(.5);a=a.mul(l.sub(u)).add(c.mul(u));}var p=sigmoidCrossEntropyWithLogits_(a,i);return computeWeightedLoss(p,s,o)}function huberLoss_(e,t,n,r,o){void 0===r&&(r=1),void 0===o&&(o=Reduction.SUM_BY_NONZERO_WEIGHTS);var a=convertToTensor(e,\"labels\",\"huberLoss\"),i=convertToTensor(t,\"predictions\",\"huberLoss\"),s=null;null!=n&&(s=convertToTensor(n,\"weights\",\"huberLoss\")),assertShapesMatch(a.shape,i.shape,\"Error in huberLoss: \");var u=scalar(r),l=i.sub(a).abs(),c=minimum(l,u),p=l.sub(c),d=scalar(.5).mul(c.square()).add(u.mul(p));return computeWeightedLoss(d,s,o)}function softmaxCrossEntropyWithLogits_(e,t,n){if(void 0===n&&(n=-1),-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error(\"Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank \"+t.rank+\" and dim was \"+n);return customGrad(function(e,t){var r=t.logSumExp([n],!0),o=t.toFloat().sub(r);return {value:o.mul(e).neg().sum([n]),gradFunc:function(t){var r=expandShapeToKeepDim(t.shape,[n]);return [t.reshape(r).mul(e.toFloat().sub(o.exp())),t.reshape(r).mul(o.exp().sub(e.toFloat()))]}}})(e,t)}function softmaxCrossEntropy_(e,t,n,r,o){void 0===r&&(r=0),void 0===o&&(o=Reduction.SUM_BY_NONZERO_WEIGHTS);var a=convertToTensor(e,\"onehotLabels\",\"softmaxCrossEntropy\"),i=convertToTensor(t,\"logits\",\"softmaxCrossEntropy\"),s=null;if(null!=n&&(s=convertToTensor(n,\"weights\",\"softmaxCrossEntropy\")),assertShapesMatch(a.shape,i.shape,\"Error in softmaxCrossEntropy: \"),r>0){var u=scalar(r),l=scalar(1),c=scalar(a.shape[1]);a=a.mul(l.sub(u)).add(u.div(c));}var p=softmaxCrossEntropyWithLogits_(a,i);return computeWeightedLoss(p,s,o)}!function(e){e[e.NONE=0]=\"NONE\",e[e.MEAN=1]=\"MEAN\",e[e.SUM=2]=\"SUM\",e[e.SUM_BY_NONZERO_WEIGHTS=3]=\"SUM_BY_NONZERO_WEIGHTS\";}(Reduction||(Reduction={}));var absoluteDifference=op({absoluteDifference_:absoluteDifference_}),computeWeightedLoss=op({computeWeightedLoss_:computeWeightedLoss_}),cosineDistance=op({cosineDistance_:cosineDistance_}),hingeLoss=op({hingeLoss_:hingeLoss_}),huberLoss=op({huberLoss_:huberLoss_}),logLoss=op({logLoss_:logLoss_}),meanSquaredError=op({meanSquaredError_:meanSquaredError_}),sigmoidCrossEntropy=op({sigmoidCrossEntropy_:sigmoidCrossEntropy_}),softmaxCrossEntropy=op({softmaxCrossEntropy_:softmaxCrossEntropy_}),loss_ops=Object.freeze({get Reduction(){return Reduction},absoluteDifference:absoluteDifference,computeWeightedLoss:computeWeightedLoss,cosineDistance:cosineDistance,hingeLoss:hingeLoss,huberLoss:huberLoss,logLoss:logLoss,meanSquaredError:meanSquaredError,sigmoidCrossEntropy:sigmoidCrossEntropy,softmaxCrossEntropy:softmaxCrossEntropy});function gramSchmidt_(e){var t;if(Array.isArray(e)){t=!1,assert(null!=e&&e.length>0,\"Gram-Schmidt process: input must not be null, undefined, or empty\");for(var n=e[0].shape[0],r=1;r<e.length;++r)assert(e[r].shape[0]===n,\"Gram-Schmidt: Non-unique lengths found in the input vectors: (\"+e[r].shape[0]+\" vs. \"+n+\")\");}else t=!0,e=split$1(e,e.shape[0],0).map(function(e){return squeeze(e,[0])});assert(e.length<=e[0].shape[0],\"Gram-Schmidt: Number of vectors (\"+e.length+\") exceeds number of dimensions (\"+e[0].shape[0]+\").\");var o=[],a=e,i=function(e){o.push(ENV.engine.tidy(function(){var t=a[e];if(e>0)for(var n=0;n<e;++n){var r=sum$1(o[n].mulStrict(t)).mul(o[n]);t=t.sub(r);}return t.div(norm(t,\"euclidean\"))}));};for(r=0;r<e.length;++r)i(r);return t?stack(o,0):o}function qr_(e,t){if(void 0===t&&(t=!1),e.rank<2)throw new Error(\"qr() requires input tensor to have a rank >= 2, but got rank \"+e.rank);if(2===e.rank)return qr2d(e,t);var n=e.shape.slice(0,e.shape.length-2).reduce(function(e,t){return e*t}),r=[],o=[];return unstack(e.reshape([n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0).forEach(function(e){var n=qr2d(e,t),a=n[0],i=n[1];r.push(a),o.push(i);}),[stack(r,0).reshape(e.shape),stack(o,0).reshape(e.shape)]}function qr2d(e,t){return void 0===t&&(t=!1),ENV.engine.tidy(function(){if(2!==e.shape.length)throw new Error(\"qr2d() requires a 2D Tensor, but got a \"+e.shape.length+\"D Tensor.\");for(var n=e.shape[0],r=e.shape[1],o=eye(n),a=e.clone(),i=tensor2d([[1]],[1,1]),s=i.clone(),u=n>=r?r:n,l=function(e){var t,u=a,l=s,c=o;t=ENV.engine.tidy(function(){var t=a.slice([e,e],[n-e,1]),u=t.norm(),l=a.slice([e,e],[1,1]),c=l.sign().neg(),p=l.sub(c.mul(u)),d=t.div(p);s=1===d.shape[0]?i.clone():i.concat(d.slice([1,0],[d.shape[0]-1,d.shape[1]]),0);var h=c.matMul(p).div(u).neg(),f=a.slice([e,0],[n-e,r]),m=h.mul(s);a=0===e?f.sub(m.matMul(s.transpose().matMul(f))):a.slice([0,0],[e,r]).concat(f.sub(m.matMul(s.transpose().matMul(f))),0);var g=o.slice([0,e],[n,o.shape[1]-e]);return o=0===e?g.sub(g.matMul(s).matMul(m.transpose())):o.slice([0,0],[n,e]).concat(g.sub(g.matMul(s).matMul(m.transpose())),1),[s,a,o]}),s=t[0],a=t[1],o=t[2],dispose([u,l,c]);},c=0;c<u;++c)l(c);return !t&&n>r&&(o=o.slice([0,0],[n,r]),a=a.slice([0,0],[r,r])),[o,a]})}var gramSchmidt=op({gramSchmidt_:gramSchmidt_}),qr=op({qr_:qr_}),linalg_ops=Object.freeze({gramSchmidt:gramSchmidt,qr:qr});function resizeBilinear_(e,t,n){void 0===n&&(n=!1);var r=convertToTensor(e,\"images\",\"resizeBilinear\");assert(3===r.rank||4===r.rank,\"Error in resizeBilinear: x must be rank 3 or 4, but got rank \"+r.rank+\".\"),assert(2===t.length,\"Error in resizeBilinear: new shape must 2D, but got shape \"+t+\".\");var o=r,a=!1;3===r.rank&&(a=!0,o=r.as4D(1,r.shape[0],r.shape[1],r.shape[2]));var i=t[0],s=t[1],u=ENV.engine.runKernel(function(e,t){return e.resizeBilinear(o,i,s,n)},{batchImages:o},function(e,t){return {batchImages:function(){return ENV.engine.runKernel(function(t){return t.resizeBilinearBackprop(e,o,n)},{})}}});return a?u.as3D(u.shape[1],u.shape[2],u.shape[3]):u}function resizeNearestNeighbor_(e,t,n){void 0===n&&(n=!1);var r=convertToTensor(e,\"images\",\"resizeNearestNeighbor\");assert(3===r.rank||4===r.rank,\"Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank \"+r.rank+\".\"),assert(2===t.length,\"Error in resizeNearestNeighbor: new shape must 2D, but got shape \"+t+\".\"),assert(\"float32\"===r.dtype||\"int32\"===r.dtype,\"`images` must have `int32` or `float32` as dtype\");var o=r,a=!1;3===r.rank&&(a=!0,o=r.as4D(1,r.shape[0],r.shape[1],r.shape[2]));var i=t[0],s=t[1],u=ENV.engine.runKernel(function(e,t){return e.resizeNearestNeighbor(o,i,s,n)},{batchImages:o},function(e,t){return {batchImages:function(){return ENV.engine.runKernel(function(t){return t.resizeNearestNeighborBackprop(e,o,n)},{})}}});return a?u.as3D(u.shape[1],u.shape[2],u.shape[3]):u}function nonMaxSuppression_(e,t,n,r,o){void 0===r&&(r=.5),void 0===o&&(o=Number.NEGATIVE_INFINITY);var a=convertToTensor(e,\"boxes\",\"nonMaxSuppression\"),i=convertToTensor(t,\"scores\",\"nonMaxSuppression\"),s=nonMaxSuppSanityCheck(a,i,n,r,o);return n=s.maxOutputSize,r=s.iouThreshold,o=s.scoreThreshold,ENV.engine.runKernel(function(e){return e.nonMaxSuppression(a,i,n,r,o)},{$boxes:a})}function nonMaxSuppressionAsync_(e,t,n,r,o){return void 0===r&&(r=.5),void 0===o&&(o=Number.NEGATIVE_INFINITY),__awaiter(this,void 0,void 0,function(){var a,i,s,u,l,c;return __generator(this,function(p){switch(p.label){case 0:return a=convertToTensor(e,\"boxes\",\"nonMaxSuppressionAsync\"),i=convertToTensor(t,\"scores\",\"nonMaxSuppressionAsync\"),s=nonMaxSuppSanityCheck(a,i,n,r,o),n=s.maxOutputSize,r=s.iouThreshold,o=s.scoreThreshold,[4,a.data()];case 1:return u=p.sent(),[4,i.data()];case 2:return l=p.sent(),c=nonMaxSuppressionImpl(u,l,n,r,o),a!==e&&a.dispose(),i!==t&&i.dispose(),[2,c]}})})}function nonMaxSuppSanityCheck(e,t,n,r,o){null==r&&(r=.5),null==o&&(o=Number.NEGATIVE_INFINITY);var a=e.shape[0];return n=Math.min(n,a),assert(0<=r&&r<=1,\"iouThreshold must be in [0, 1], but was '\"+r+\"'\"),assert(2===e.rank,\"boxes must be a 2D tensor, but was of rank '\"+e.rank+\"'\"),assert(4===e.shape[1],\"boxes must have 4 columns, but 2nd dimension was \"+e.shape[1]),assert(1===t.rank,\"scores must be a 1D tensor\"),assert(t.shape[0]===a,\"scores has incompatible shape with boxes. Expected \"+a+\", but was \"+t.shape[0]),{maxOutputSize:n,iouThreshold:r,scoreThreshold:o}}function cropAndResize_(e,t,n,r,o,a){var i=convertToTensor(e,\"image\",\"cropAndResize\",\"float32\"),s=convertToTensor(t,\"boxes\",\"cropAndResize\",\"float32\"),u=convertToTensor(n,\"boxInd\",\"cropAndResize\",\"int32\");o=o||\"bilinear\",a=a||0;var l=s.shape[0];assert(4===i.rank,\"Error in cropAndResize: image must be rank 4,but got rank \"+i.rank+\".\"),assert(2===s.rank&&4===s.shape[1],\"Error in cropAndResize: boxes must be have size [\"+l+\",4] but had shape \"+s.shape+\".\"),assert(1===u.rank&&u.shape[0]===l,\"Error in cropAndResize: boxInd must be have size [\"+l+\"] but had shape \"+s.shape+\".\"),assert(2===r.length,\"Error in cropAndResize: cropSize must be of length 2, but got length \"+r.length+\".\"),assert(r[0]>=1&&r[1]>=1,\"cropSize must be atleast [1,1], but was \"+r),assert(\"bilinear\"===o||\"nearest\"===o,\"method must be bilinear or nearest, but was \"+o);return ENV.engine.runKernel(function(e,t){return e.cropAndResize(i,s,u,r,o,a)},{$image:i,$boxes:s})}var resizeBilinear=op({resizeBilinear_:resizeBilinear_}),resizeNearestNeighbor=op({resizeNearestNeighbor_:resizeNearestNeighbor_}),nonMaxSuppression=op({nonMaxSuppression_:nonMaxSuppression_}),nonMaxSuppressionAsync=nonMaxSuppressionAsync_,cropAndResize=cropAndResize_,image_ops=Object.freeze({resizeBilinear:resizeBilinear,resizeNearestNeighbor:resizeNearestNeighbor,nonMaxSuppression:nonMaxSuppression,nonMaxSuppressionAsync:nonMaxSuppressionAsync,cropAndResize:cropAndResize}),ops=Object.freeze({image:image_ops,linalg:linalg_ops,losses:loss_ops,spectral:spectral_ops,op:op,batchNormalization2d:batchNormalization2d,batchNormalization3d:batchNormalization3d,batchNormalization4d:batchNormalization4d,batchNormalization:batchNormalization,complex:complex,real:real,imag:imag,concat:concat,concat1d:concat1d,concat2d:concat2d,concat3d:concat3d,concat4d:concat4d,split:split$1,conv1d:conv1d,conv2d:conv2d,conv3d:conv3d,conv2dDerFilter:conv2dDerFilter,depthwiseConv2d:depthwiseConv2d,separableConv2d:separableConv2d,conv2dTranspose:conv2dTranspose,matMul:matMul,dot:dot,outerProduct:outerProduct,reverse:reverse,reverse1d:reverse1d,reverse2d:reverse2d,reverse3d:reverse3d,reverse4d:reverse4d,maxPool:maxPool,avgPool:avgPool,pool:pool,slice:slice,slice1d:slice1d,slice2d:slice2d,slice3d:slice3d,slice4d:slice4d,abs:abs,acos:acos,acosh:acosh,asin:asin,asinh:asinh,atan:atan,atanh:atanh,ceil:ceil,clipByValue:clipByValue,cos:cos,cosh:cosh,erf:erf,exp:exp,expm1:expm1,floor:floor,log:log$1,log1p:log1p,logSigmoid:logSigmoid,neg:neg,reciprocal:reciprocal,round:round,rsqrt:rsqrt,sigmoid:sigmoid,sign:sign,sin:sin,sinh:sinh,softplus:softplus,sqrt:sqrt,square:square,step:step,tan:tan,tanh:tanh$1,all:all,any:any,argMax:argMax,argMin:argMin,logSumExp:logSumExp,max:max,mean:mean,min:min,moments:moments,sum:sum$1,prod:prod,equal:equal,equalStrict:equalStrict,greater:greater,greaterEqual:greaterEqual,greaterEqualStrict:greaterEqualStrict,greaterStrict:greaterStrict,less:less,lessEqual:lessEqual,lessEqualStrict:lessEqualStrict,lessStrict:lessStrict,notEqual:notEqual,notEqualStrict:notEqualStrict,add:add,addN:addN,addStrict:addStrict,atan2:atan2,div:div,divStrict:divStrict,floorDiv:floorDiv,maximum:maximum,maximumStrict:maximumStrict,minimum:minimum,minimumStrict:minimumStrict,mod:mod,modStrict:modStrict,mul:mul,mulStrict:mulStrict,pow:pow,powStrict:powStrict,squaredDifference:squaredDifference,squaredDifferenceStrict:squaredDifferenceStrict,sub:sub,subStrict:subStrict,elu:elu,leakyRelu:leakyRelu,prelu:prelu,relu:relu,selu:selu,logicalAnd:logicalAnd,logicalNot:logicalNot,logicalOr:logicalOr,logicalXor:logicalXor,where:where,whereAsync:whereAsync,buffer:buffer,toPixels:toPixels,print:print,batchToSpaceND:batchToSpaceND,cast:cast,clone:clone,cumsum:cumsum,depthToSpace:depthToSpace,expandDims:expandDims,eye:eye,fromPixels:fromPixels,multinomial:multinomial,oneHot:oneHot,pad:pad,pad1d:pad1d,pad2d:pad2d,pad3d:pad3d,pad4d:pad4d,rand:rand,randomNormal:randomNormal,randomUniform:randomUniform,reshape:reshape,spaceToBatchND:spaceToBatchND,squeeze:squeeze,stack:stack,tile:tile,truncatedNormal:truncatedNormal,unstack:unstack,setdiff1dAsync:setdiff1dAsync,fill:fill,linspace:linspace,ones:ones$1,range:range,scalar:scalar,tensor:tensor,tensor1d:tensor1d,tensor2d:tensor2d,tensor3d:tensor3d,tensor4d:tensor4d,tensor5d:tensor5d,tensor6d:tensor6d,zeros:zeros,onesLike:onesLike,zerosLike:zerosLike,transpose:transpose,softmax:softmax,logSoftmax:logSoftmax,localResponseNormalization:localResponseNormalization,norm:norm,gather:gather,unsortedSegmentSum:unsortedSegmentSum,basicLSTMCell:basicLSTMCell,multiRNNCell:multiRNNCell,movingAverage:movingAverage,stridedSlice:stridedSlice,topk:topk,scatterND:scatterND,fft:fft,ifft:ifft,rfft:rfft,irfft:irfft,sparseToDense:sparseToDense,gatherND:gatherND}),MathBackendCPU=function(){function e(){this.blockSize=48,this.firstUse=!0,ENV.get(\"IS_BROWSER\")&&(this.fromPixels2DContext=document.createElement(\"canvas\").getContext(\"2d\"));}return e.prototype.setDataMover=function(e){this.data=new DataStorage(e);},e.prototype.register=function(e,t,n){if(this.firstUse&&(this.firstUse=!1,ENV.get(\"IS_NODE\")&&warn(\"\\n============================\\nHi there 👋. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\\n============================\\n\")),this.data.has(e))throw new Error(\"Data buffer is already registered\");this.data.set(e,{dtype:n});},e.prototype.write=function(e,t){if(null==t)throw new Error(\"MathBackendCPU.write(): values can not be null\");this.data.get(e).values=t;},e.prototype.fromPixels=function(e,t){if(null==e)throw new Error(\"pixels passed to tf.fromPixels() can not be null\");var n,r;if(ENV.get(\"IS_NODE\")&&null==e.getContext)throw new Error(\"When running in node, pixels must be an HTMLCanvasElement like the one returned by the `canvas` npm package\");if(null!=e.getContext)n=e.getContext(\"2d\").getImageData(0,0,e.width,e.height).data;else if(e instanceof ImageData)n=e.data;else{if(!(e instanceof HTMLImageElement||e instanceof HTMLVideoElement))throw new Error(\"pixels passed to tf.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement or ImageData, but was \"+e.constructor.name);if(null==this.fromPixels2DContext)throw new Error(\"Can't read pixels from HTMLImageElement outside the browser.\");this.fromPixels2DContext.canvas.width=e.width,this.fromPixels2DContext.canvas.height=e.height,this.fromPixels2DContext.drawImage(e,0,0,e.width,e.height),n=this.fromPixels2DContext.getImageData(0,0,e.width,e.height).data;}if(4===t)r=new Int32Array(n);else{var o=e.width*e.height;r=new Int32Array(o*t);for(var a=0;a<o;a++)for(var i=0;i<t;++i)r[a*t+i]=n[4*a+i];}return tensor3d(r,[e.height,e.width,t],\"int32\")},e.prototype.read=function(e){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){return [2,this.readSync(e)]})})},e.prototype.readSync=function(e){var t=this.data.get(e),n=t.dtype,r=t.complexTensors;return \"complex64\"===n?mergeRealAndImagArrays(r.real.dataSync(),r.imag.dataSync()):this.data.get(e).values},e.prototype.disposeData=function(e){if(this.data.has(e)){var t=this.data.get(e).complexTensors;null!=t&&(t.real.dispose(),t.imag.dispose()),this.data.delete(e);}},e.prototype.time=function(e){return __awaiter(this,void 0,void 0,function(){var t;return __generator(this,function(n){return t=now(),e(),[2,{kernelMs:now()-t}]})})},e.prototype.memory=function(){return {unreliable:!0,reasons:[\"The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less.\"]}},e.prototype.complex=function(e,t){var n=Tensor.make(e.shape,{},\"complex64\");return this.data.get(n.dataId).complexTensors={real:ENV.engine.keep(e.clone()),imag:ENV.engine.keep(t.clone())},n},e.prototype.real=function(e){return this.data.get(e.dataId).complexTensors.real.clone()},e.prototype.imag=function(e){return this.data.get(e.dataId).complexTensors.imag.clone()},e.prototype.assertNotComplex=function(e,t){Array.isArray(e)||(e=[e]),e.forEach(function(e){null!=e&&assert(\"complex64\"!==e.dtype,t+\" does not support complex64 tensors.\");});},e.prototype.slice=function(e,t,n){this.assertNotComplex(e,\"slice\");for(var r=buffer(n,e.dtype),o=0;o<r.size;++o){var a=r.indexToLoc(o),i=a.map(function(e,n){return e+t[n]});r.set.apply(r,[e.get.apply(e,i)].concat(a));}return r.toTensor()},e.prototype.stridedSlice=function(e,t,n,r,o,a,i,s,u){this.assertNotComplex(e,\"stridedSlice\");var l=getStridedSlicedInfo(e.shape,t,n,r,o,a,i,s,u),c=l[0],p=l[1],d=l[2],h=p.filter(function(e,t){return -1===d.indexOf(t)});if(h.some(function(e){return 0===e}))return tensor([],h);for(var f=buffer(p,e.dtype),m=0;m<f.size;m++){for(var g=f.indexToLoc(m),v=new Array(g.length),y=0;y<v.length;y++)v[y]=g[y]*r[y]+c[y];f.set.apply(f,[e.get.apply(e,v)].concat(g));}return f.toTensor().reshape(h)},e.prototype.reverse=function(e,t){this.assertNotComplex(e,\"reverse\");for(var n=buffer(e.shape,e.dtype),r=e.buffer(),o=function(o){var a=n.indexToLoc(o),i=a.slice();t.forEach(function(t){return i[t]=e.shape[t]-1-i[t]}),n.set.apply(n,[r.get.apply(r,i)].concat(a));},a=0;a<n.size;a++)o(a);return n.toTensor()},e.prototype.concat=function(e,t){this.assertNotComplex(e,\"concat\");var n=e.map(function(e){var n=sizeFromShape(e.shape.slice(t));return e.as2D(-1,n)}),r=computeOutShape(n.map(function(e){return e.shape}),1),o=buffer(r,e[0].dtype).values;if(1===n[0].shape[0]){var a=0;n.forEach(function(e){o.set(e.dataSync(),a),a+=e.size;});}else{var i=0;n.forEach(function(e){for(var t=e.dataSync(),n=0,a=0;a<e.shape[0];++a)for(var s=a*r[1]+i,u=0;u<e.shape[1];++u)o[s+u]=t[n++];i+=e.shape[1];});}var s=computeOutShape(e.map(function(e){return e.shape}),t);return tensor(o,s,e[0].dtype)},e.prototype.neg=function(e){return this.assertNotComplex(e,\"neg\"),this.multiply(scalar(-1),e)},e.prototype.add=function(e,t){return \"complex64\"===e.dtype||\"complex64\"===t.dtype?this.broadcastedBinaryComplexOp(e.cast(\"complex64\"),t.cast(\"complex64\"),function(e,t,n,r){return {real:e+n,imag:t+r}}):this.broadcastedBinaryOp(e,t,upcastType(e.dtype,t.dtype),function(e,t){return e+t})},e.prototype.addN=function(e){this.assertNotComplex(e,\"addN\");for(var t=e.map(function(e){return e.dataSync()}),n=buffer(e[0].shape,e[0].dtype),r=n.values,o=0;o<e.length;o++)for(var a=t[o],i=0;i<r.length;i++)r[i]+=a[i];return n.toTensor()},e.prototype.subtract=function(e,t){return \"complex64\"===e.dtype||\"complex64\"===t.dtype?this.broadcastedBinaryComplexOp(e.cast(\"complex64\"),t.cast(\"complex64\"),function(e,t,n,r){return {real:e-n,imag:t-r}}):this.broadcastedBinaryOp(e,t,upcastType(e.dtype,t.dtype),function(e,t){return e-t})},e.prototype.pow=function(e,t){return this.assertNotComplex([e,t],\"pow\"),this.broadcastedBinaryOp(e,t,e.dtype,function(e,t){return Math.pow(e,t)})},e.prototype.batchMatMul=function(e,t,n,r){this.assertNotComplex([e,t],\"matMul\");for(var o=n?e.shape[1]:e.shape[2],a=n?e.shape[2]:e.shape[1],i=r?t.shape[1]:t.shape[2],s=e.shape[0],u=e.dataSync(),l=t.dataSync(),c=n?[e.strides[0],1,e.strides[1]]:[e.strides[0],e.strides[1],1],p=c[0],d=c[1],h=c[2],f=r?[1,t.strides[1],t.strides[0]]:[t.strides[1],1,t.strides[0]],m=f[0],g=f[1],v=f[2],y=a*i,x=buffer([s,a,i],e.dtype),T=x.values,w=this.blockSize,E=0;E<s;E++)for(var S=0;S<a;S+=w)for(var b=0;b<i;b+=w)for(var C=0;C<o;C+=w)for(var A=Math.min(S+w,a),_=Math.min(b+w,i),N=Math.min(C+w,o),R=S;R<A;R++)for(var k=b;k<_;k++){for(var I=0,D=C;D<N;D++)I+=u[E*p+R*d+D*h]*l[D*m+k*g+E*v];T[E*y+(R*i+k)]+=I;}return x.toTensor()},e.prototype.multiply=function(e,t){return \"complex64\"===e.dtype||\"complex64\"===t.dtype?this.broadcastedBinaryComplexOp(e.cast(\"complex64\"),t.cast(\"complex64\"),function(e,t,n,r){return {real:e*n-t*r,imag:e*r+t*n}}):this.broadcastedBinaryOp(e,t,upcastType(e.dtype,t.dtype),function(e,t){return e*t})},e.prototype.realDivide=function(e,t){this.assertNotComplex([e,t],\"realDivide\");return this.broadcastedBinaryOp(e,t,\"float32\",function(e,t){return e/t})},e.prototype.floorDiv=function(e,t){this.assertNotComplex([e,t],\"floorDiv\");return this.broadcastedBinaryOp(e,t,\"int32\",function(e,t){return Math.floor(e/t)})},e.prototype.sum=function(e,t){this.assertNotComplex(e,\"sum\"),assertAxesAreInnerMostDims(\"sum\",t,e.rank);for(var n=computeOutAndReduceShapes(e.shape,t),r=n[0],o=n[1],a=zeros(r,upcastType(e.dtype,\"int32\")),i=sizeFromShape(o),s=a.dataSync(),u=e.dataSync(),l=0;l<s.length;++l){for(var c=l*i,p=0,d=0;d<i;++d)p+=u[c+d];s[l]=p;}return a},e.prototype.prod=function(e,t){this.assertNotComplex(e,\"sum\");for(var n=computeOutAndReduceShapes(e.shape,t),r=n[0],o=n[1],a=zeros(r,upcastType(e.dtype,\"int32\")),i=sizeFromShape(o),s=a.dataSync(),u=e.dataSync(),l=0;l<s.length;++l){for(var c=l*i,p=1,d=0;d<i;++d)p*=u[c+d];s[l]=p;}return a},e.prototype.unsortedSegmentSum=function(e,t,n){this.assertNotComplex(e,\"unsortedSegmentSum\");for(var r=[],o=e.rank-t.rank,a=0;a<o;++a)t=t.expandDims(a+1);for(a=0;a<n;++a){var i=scalar(a,\"int32\"),s=equal(i,t).asType(\"float32\").mul(e).sum(0);r.push(s);}return stack(r)},e.prototype.argMin=function(e,t){this.assertNotComplex(e,\"argMin\");var n=[t];assertAxesAreInnerMostDims(\"argMin\",n,e.rank);for(var r=computeOutAndReduceShapes(e.shape,n),o=r[0],a=r[1],i=zeros(o,\"int32\"),s=sizeFromShape(a),u=i.dataSync(),l=e.dataSync(),c=0;c<u.length;++c){for(var p=c*s,d=l[p],h=0,f=0;f<s;++f){var m=l[p+f];m<d&&(d=m,h=f);}u[c]=h;}return i},e.prototype.argMax=function(e,t){this.assertNotComplex(e,\"argMax\");var n=[t];assertAxesAreInnerMostDims(\"argMax\",n,e.rank);for(var r=computeOutAndReduceShapes(e.shape,n),o=r[0],a=r[1],i=zeros(o,\"int32\"),s=sizeFromShape(a),u=i.dataSync(),l=e.dataSync(),c=0;c<u.length;++c){for(var p=c*s,d=l[p],h=0,f=0;f<s;++f){var m=l[p+f];m>d&&(d=m,h=f);}u[c]=h;}return i},e.prototype.cumsum=function(e,t,n,r){if(this.assertNotComplex(e,\"cumsum\"),t!==e.rank-1)throw new Error(\"backend.cumsum in CPU expects an inner-most axis=\"+(e.rank-1)+\" but got axis=\"+t);for(var o=upcastType(e.dtype,\"int32\"),a=zeros(e.shape,o),i=a.dataSync(),s=e.dataSync(),u=e.shape[e.rank-1],l=r?function(e,t){return e+u-t-1}:function(e,t){return e+t},c=0;c<s.length;c+=u)for(var p=0;p<u;p++){var d=l(c,p);if(0===p)i[d]=n?0:s[d];else{var h=l(c,p-1);i[d]=n?s[h]+i[h]:s[d]+i[h];}}return a},e.prototype.equal=function(e,t){return this.assertNotComplex([e,t],\"equal\"),this.broadcastedBinaryOp(e,t,\"bool\",function(e,t){return e===t?1:0})},e.prototype.notEqual=function(e,t){return this.assertNotComplex([e,t],\"notEqual\"),this.broadcastedBinaryOp(e,t,\"bool\",function(e,t){return e!==t?1:0})},e.prototype.less=function(e,t){return this.assertNotComplex([e,t],\"less\"),this.broadcastedBinaryOp(e,t,\"bool\",function(e,t){return e<t?1:0})},e.prototype.lessEqual=function(e,t){return this.assertNotComplex([e,t],\"lessEqual\"),this.broadcastedBinaryOp(e,t,\"bool\",function(e,t){return e<=t?1:0})},e.prototype.greater=function(e,t){return this.assertNotComplex([e,t],\"greater\"),this.broadcastedBinaryOp(e,t,\"bool\",function(e,t){return e>t?1:0})},e.prototype.greaterEqual=function(e,t){return this.assertNotComplex([e,t],\"greaterEqual\"),this.broadcastedBinaryOp(e,t,\"bool\",function(e,t){return e>=t?1:0})},e.prototype.logicalNot=function(e){this.assertNotComplex(e,\"logicalNot\");for(var t=e.dataSync(),n=new Uint8Array(t.length),r=0;r<t.length;++r)n[r]=t[r]?0:1;return Tensor.make(e.shape,{values:n},\"bool\")},e.prototype.logicalAnd=function(e,t){return this.assertNotComplex([e,t],\"logicalAnd\"),this.broadcastedBinaryOp(e,t,\"bool\",function(e,t){return e&&t})},e.prototype.logicalOr=function(e,t){return this.assertNotComplex([e,t],\"logicalOr\"),this.broadcastedBinaryOp(e,t,\"bool\",function(e,t){return e||t})},e.prototype.select=function(e,t,n){this.assertNotComplex([e,t,n],\"select\");for(var r=e.dataSync(),o=t.dataSync(),a=n.dataSync(),i=zeros(t.shape,upcastType(t.dtype,n.dtype)),s=i.dataSync(),u=0,l=0===e.rank||e.rank>1||1===t.rank?1:t.shape[1],c=0;c<r.length;c++)for(var p=0;p<l;p++)1===r[c]?s[u++]=o[c]:s[u++]=a[c];return i},e.prototype.where=function(e){this.assertNotComplex([e],\"where\");var t=e.dataSync();return whereImpl(e.shape,t)},e.prototype.topk=function(e,t,n){return this.assertNotComplex(e,\"topk\"),topkImpl(e.dataSync(),e.shape,e.dtype,t,n)},e.prototype.min=function(e,t){this.assertNotComplex(e,\"min\"),assertAxesAreInnerMostDims(\"min\",t,e.rank);for(var n=computeOutAndReduceShapes(e.shape,t),r=n[0],o=n[1],a=zeros(r,e.dtype),i=sizeFromShape(o),s=a.dataSync(),u=e.dataSync(),l=0;l<s.length;++l){for(var c=l*i,p=u[c],d=0;d<i;++d){var h=u[c+d];h<p&&(p=h);}s[l]=p;}return a},e.prototype.minimum=function(e,t){return this.assertNotComplex([e,t],\"minimum\"),this.broadcastedBinaryOp(e,t,e.dtype,function(e,t){return Math.min(e,t)})},e.prototype.mod=function(e,t){return this.assertNotComplex([e,t],\"mod\"),this.broadcastedBinaryOp(e,t,e.dtype,function(e,t){var n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t})},e.prototype.max=function(e,t){this.assertNotComplex(e,\"max\"),assertAxesAreInnerMostDims(\"max\",t,e.rank);for(var n=computeOutAndReduceShapes(e.shape,t),r=n[0],o=n[1],a=zeros(r,e.dtype),i=sizeFromShape(o),s=a.dataSync(),u=e.dataSync(),l=0;l<s.length;++l){for(var c=l*i,p=u[c],d=0;d<i;++d){var h=u[c+d];h>p&&(p=h);}s[l]=p;}return a},e.prototype.maximum=function(e,t){return this.assertNotComplex([e,t],\"maximum\"),this.broadcastedBinaryOp(e,t,e.dtype,function(e,t){return Math.max(e,t)})},e.prototype.all=function(e,t){this.assertNotComplex(e,\"all\"),assertAxesAreInnerMostDims(\"all\",t,e.rank);for(var n=computeOutAndReduceShapes(e.shape,t),r=n[0],o=n[1],a=zeros(r,e.dtype),i=sizeFromShape(o),s=a.dataSync(),u=e.dataSync(),l=0;l<s.length;++l){for(var c=l*i,p=u[c],d=0;d<i;++d){var h=u[c+d];p=p&&h;}s[l]=p;}return a},e.prototype.any=function(e,t){this.assertNotComplex(e,\"any\"),assertAxesAreInnerMostDims(\"any\",t,e.rank);for(var n=computeOutAndReduceShapes(e.shape,t),r=n[0],o=n[1],a=zeros(r,e.dtype),i=sizeFromShape(o),s=a.dataSync(),u=e.dataSync(),l=0;l<s.length;++l){for(var c=l*i,p=u[c],d=0;d<i;++d){var h=u[c+d];p=p||h;}s[l]=p;}return a},e.prototype.squaredDifference=function(e,t){return this.assertNotComplex([e,t],\"squaredDifference\"),this.broadcastedBinaryOp(e,t,e.dtype,function(e,t){var n=e-t;return n*n})},e.prototype.ceil=function(e){this.assertNotComplex(e,\"ceil\");for(var t=e.dataSync(),n=new Float32Array(t.length),r=0;r<t.length;++r)n[r]=Math.ceil(t[r]);return Tensor.make(e.shape,{values:n})},e.prototype.floor=function(e){this.assertNotComplex(e,\"floor\");for(var t=e.dataSync(),n=new Float32Array(t.length),r=0;r<t.length;++r)n[r]=Math.floor(t[r]);return Tensor.make(e.shape,{values:n})},e.prototype.sign=function(e){this.assertNotComplex(e,\"x\");for(var t=e.dataSync(),n=new Float32Array(t.length),r=0;r<t.length;++r)t[r]<0?n[r]=-1:t[r]>0?n[r]=1:n[r]=0;return Tensor.make(e.shape,{values:n})},e.prototype.round=function(e){this.assertNotComplex(e,\"round\");for(var t=e.dataSync(),n=new Float32Array(t.length),r=0;r<t.length;++r){var o=Math.floor(t[r]);t[r]-o<.5?n[r]=Math.floor(t[r]):t[r]-o>.5?n[r]=Math.ceil(t[r]):n[r]=o%2==0?o:o+1;}return Tensor.make(e.shape,{values:n})},e.prototype.exp=function(e){this.assertNotComplex(e,\"exp\");for(var t=e.dataSync(),n=new Float32Array(t.length),r=0;r<t.length;++r)n[r]=Math.exp(t[r]);return Tensor.make(e.shape,{values:n})},e.prototype.expm1=function(e){this.assertNotComplex(e,\"expm1\");for(var t=e.dataSync(),n=new Float32Array(t.length),r=0;r<t.length;++r)n[r]=Math.expm1(t[r]);return Tensor.make(e.shape,{values:n})},e.prototype.log=function(e){this.assertNotComplex(e,\"log\");for(var t=e.dataSync(),n=new Float32Array(t.length),r=0;r<t.length;++r){var o=t[r];n[r]=Math.log(o);}return Tensor.make(e.shape,{values:n})},e.prototype.log1p=function(e){this.assertNotComplex(e,\"log1p\");for(var t=e.dataSync(),n=new Float32Array(t.length),r=0;r<t.length;++r){var o=t[r];n[r]=Math.log1p(o);}return Tensor.make(e.shape,{values:n})},e.prototype.sqrt=function(e){this.assertNotComplex(e,\"sqrt\");for(var t=e.dataSync(),n=new Float32Array(t.length),r=0;r<t.length;++r){var o=t[r];n[r]=Math.sqrt(o);}return Tensor.make(e.shape,{values:n})},e.prototype.rsqrt=function(e){this.assertNotComplex(e,\"rsqrt\");for(var t=e.dataSync(),n=new Float32Array(t.length),r=0;r<t.length;++r){var o=t[r];n[r]=1/Math.sqrt(o);}return Tensor.make(e.shape,{values:n})},e.prototype.square=function(e){this.assertNotComplex(e,\"square\");for(var t=e.dataSync(),n=new Float32Array(t.length),r=0;r<t.length;++r){var o=t[r];n[r]=o*o;}return Tensor.make(e.shape,{values:n})},e.prototype.reciprocal=function(e){this.assertNotComplex(e,\"reciprocal\");for(var t=e.dataSync(),n=new Float32Array(t.length),r=0;r<t.length;++r)n[r]=1/t[r];return Tensor.make(e.shape,{values:n})},e.prototype.relu=function(e){this.assertNotComplex(e,\"relu\");for(var t=zeros(e.shape,e.dtype),n=t.dataSync(),r=e.dataSync(),o=0;o<r.length;++o)n[o]=Math.max(0,r[o]);return t},e.prototype.elu=function(e){this.assertNotComplex(e,\"elu\");for(var t=new Float32Array(e.size),n=e.dataSync(),r=0;r<n.length;++r){var o=n[r];t[r]=o>=0?o:Math.exp(o)-1;}return Tensor.make(e.shape,{values:t})},e.prototype.eluDer=function(e,t){this.assertNotComplex([e,t],\"eluDer\");for(var n=new Float32Array(t.size),r=t.dataSync(),o=e.dataSync(),a=0;a<r.length;++a){var i=r[a];n[a]=i>=1?o[a]:o[a]*(i+1);}return Tensor.make(t.shape,{values:n})},e.prototype.selu=function(e){this.assertNotComplex(e,\"selu\");for(var t=SELU_SCALEALPHA,n=SELU_SCALE,r=new Float32Array(e.size),o=e.dataSync(),a=0;a<o.length;++a){var i=o[a];r[a]=i>=0?n*i:t*(Math.exp(i)-1);}return Tensor.make(e.shape,{values:r})},e.prototype.clip=function(e,t,n){this.assertNotComplex(e,\"clip\");for(var r=new Float32Array(e.size),o=e.dataSync(),a=0;a<o.length;++a){var i=o[a];r[a]=i>n?n:i<t?t:i;}return Tensor.make(e.shape,{values:r})},e.prototype.abs=function(e){for(var t=new Float32Array(e.size),n=e.dataSync(),r=0;r<n.length;++r)t[r]=Math.abs(n[r]);return Tensor.make(e.shape,{values:t})},e.prototype.complexAbs=function(e){for(var t=new Float32Array(e.size),n=e.dataSync(),r=0;r<e.size;++r){var o=n[2*r],a=n[2*r+1];t[r]=Math.hypot(o,a);}return Tensor.make(e.shape,{values:t})},e.prototype.int=function(e){this.assertNotComplex(e,\"int\");for(var t=new Int32Array(e.size),n=e.dataSync(),r=0;r<n.length;++r)t[r]=n[r];return Tensor.make(e.shape,{values:t},\"int32\")},e.prototype.sigmoid=function(e){this.assertNotComplex(e,\"sigmoid\");for(var t=new Float32Array(e.size),n=e.dataSync(),r=0;r<n.length;++r)t[r]=1/(1+Math.exp(-n[r]));return Tensor.make(e.shape,{values:t})},e.prototype.softplus=function(e){this.assertNotComplex(e,\"softplus\");for(var t=Math.log(1.1920928955078125e-7)+2,n=new Float32Array(e.size),r=e.dataSync(),o=0;o<r.length;++o){var a=r[o]>-t,i=r[o]<t,s=Math.exp(r[o]),u=void 0;u=i?s:a?r[o]:Math.log(1+s),n[o]=u;}return Tensor.make(e.shape,{values:n})},e.prototype.sin=function(e){this.assertNotComplex(e,\"sin\");for(var t=new Float32Array(e.size),n=e.dataSync(),r=0;r<n.length;++r)t[r]=Math.sin(n[r]);return Tensor.make(e.shape,{values:t})},e.prototype.cos=function(e){this.assertNotComplex(e,\"cos\");for(var t=new Float32Array(e.size),n=e.dataSync(),r=0;r<n.length;++r)t[r]=Math.cos(n[r]);return Tensor.make(e.shape,{values:t})},e.prototype.tan=function(e){this.assertNotComplex(e,\"tan\");for(var t=new Float32Array(e.size),n=e.dataSync(),r=0;r<n.length;++r)t[r]=Math.tan(n[r]);return Tensor.make(e.shape,{values:t})},e.prototype.asin=function(e){this.assertNotComplex(e,\"asin\");for(var t=new Float32Array(e.size),n=e.dataSync(),r=0;r<n.length;++r)t[r]=Math.asin(n[r]);return Tensor.make(e.shape,{values:t})},e.prototype.acos=function(e){this.assertNotComplex(e,\"acos\");for(var t=new Float32Array(e.size),n=e.dataSync(),r=0;r<n.length;++r)t[r]=Math.acos(n[r]);return Tensor.make(e.shape,{values:t})},e.prototype.atan=function(e){this.assertNotComplex(e,\"atan\");for(var t=new Float32Array(e.size),n=e.dataSync(),r=0;r<n.length;++r)t[r]=Math.atan(n[r]);return Tensor.make(e.shape,{values:t})},e.prototype.atan2=function(e,t){return this.assertNotComplex([e,t],\"atan2\"),this.broadcastedBinaryOp(e,t,e.dtype,function(e,t){return Math.atan2(e,t)})},e.prototype.sinh=function(e){this.assertNotComplex(e,\"sinh\");for(var t=new Float32Array(e.size),n=e.dataSync(),r=0;r<n.length;++r)t[r]=Math.sinh(n[r]);return Tensor.make(e.shape,{values:t})},e.prototype.cosh=function(e){this.assertNotComplex(e,\"cosh\");for(var t=new Float32Array(e.size),n=e.dataSync(),r=0;r<n.length;++r)t[r]=Math.cosh(n[r]);return Tensor.make(e.shape,{values:t})},e.prototype.tanh=function(e){this.assertNotComplex(e,\"tanh\");for(var t=new Float32Array(e.size),n=e.dataSync(),r=0;r<n.length;++r)t[r]=tanh(n[r]);return Tensor.make(e.shape,{values:t})},e.prototype.asinh=function(e){this.assertNotComplex(e,\"asinh\");for(var t=new Float32Array(e.size),n=e.dataSync(),r=0;r<n.length;++r)t[r]=Math.asinh(n[r]);return Tensor.make(e.shape,{values:t})},e.prototype.acosh=function(e){this.assertNotComplex(e,\"acosh\");for(var t=new Float32Array(e.size),n=e.dataSync(),r=0;r<n.length;++r)t[r]=Math.acosh(n[r]);return Tensor.make(e.shape,{values:t})},e.prototype.atanh=function(e){this.assertNotComplex(e,\"atanh\");for(var t=new Float32Array(e.size),n=e.dataSync(),r=0;r<n.length;++r)t[r]=Math.atanh(n[r]);return Tensor.make(e.shape,{values:t})},e.prototype.erf=function(e){this.assertNotComplex(e,\"erf\");for(var t=new Float32Array(e.size),n=e.dataSync(),r=ERF_P,o=ERF_A1,a=ERF_A2,i=ERF_A3,s=ERF_A4,u=ERF_A5,l=0;l<n.length;++l){var c=n[l],p=1/(1+r*c);t[l]=1-((((u*p+s)*p+i)*p+a)*p+o)*p*Math.exp(-c*c);}return Tensor.make(e.shape,{values:t})},e.prototype.step=function(e,t){void 0===t&&(t=0),this.assertNotComplex(e,\"step\");for(var n=new Float32Array(e.size),r=e.dataSync(),o=0;o<r.length;++o){var a=r[o];isNaN(a)?n[o]=NaN:n[o]=a>0?1:t;}return Tensor.make(e.shape,{values:n})},e.prototype.conv2d=function(e,t,n){this.assertNotComplex([e,t],\"conv2d\");for(var r=n.filterHeight,o=n.filterWidth,a=n.dilationHeight,i=n.dilationWidth,s=n.padInfo.left,u=n.padInfo.top,l=buffer(n.outShape,e.dtype),c=e.dataSync(),p=t.dataSync(),d=l.values,h=0;h<n.batchSize;++h)for(var f=h*e.strides[0],m=h*l.strides[0],g=0;g<n.outHeight;++g)for(var v=m+g*l.strides[1],y=g*n.strideHeight-s,x=0;x<r;x++){var T=y+x*a;if(!(T<0||T>=n.inHeight))for(var w=x*t.strides[0],E=f+T*e.strides[1],S=0;S<n.outWidth;++S)for(var b=v+S*n.outChannels,C=S*n.strideWidth-u,A=0;A<o;A++){var _=C+A*i;if(!(_<0||_>=n.inWidth))for(var N=w+A*t.strides[1],R=E+_*n.inChannels,k=N,I=0;I<n.inChannels;++I){for(var D=c[R+I],M=0;M<n.outChannels;++M)d[b+M]+=D*p[k+M];k+=n.outChannels;}}}return l.toTensor()},e.prototype.conv3d=function(e,t,n){for(var r=n.filterDepth,o=n.filterHeight,a=n.filterWidth,i=n.dilationDepth,s=n.dilationHeight,u=n.dilationWidth,l=n.padInfo.front,c=n.padInfo.left,p=n.padInfo.top,d=buffer(n.outShape,e.dtype),h=e.dataSync(),f=t.dataSync(),m=d.values,g=0;g<n.batchSize;++g)for(var v=g*e.strides[0],y=g*d.strides[0],x=0;x<n.outDepth;++x)for(var T=y+x*d.strides[1],w=x*n.strideDepth-l,E=0;E<r;E++){var S=w+E*i;if(!(S<0||S>=n.inDepth))for(var b=E*t.strides[0],C=v+S*e.strides[1],A=0;A<n.outHeight;++A)for(var _=T+A*d.strides[2],N=A*n.strideHeight-p,R=0;R<o;R++){var k=N+R*s;if(!(k<0||k>=n.inHeight))for(var I=b+R*t.strides[1],D=C+k*e.strides[2],M=0;M<n.outWidth;++M)for(var P=_+M*n.outChannels,O=M*n.strideWidth-c,F=0;F<a;F++){var L=O+F*u;if(!(L<0||L>=n.inWidth))for(var B=I+F*t.strides[2],U=D+L*n.inChannels,V=B,z=0;z<n.inChannels;++z){for(var H=h[U+z],W=0;W<n.outChannels;++W)m[P+W]+=H*f[V+W];V+=n.outChannels;}}}}return d.toTensor()},e.prototype.conv2dDerInput=function(e,t,n){this.assertNotComplex([e,t],\"conv2dDerInput\");for(var r=buffer(n.inShape,\"float32\"),o=r.values,a=r.strides,i=a[0],s=a[1],u=a[2],l=e.dataSync(),c=e.strides,p=c[0],d=c[1],h=c[2],f=t.dataSync(),m=t.strides,g=m[0],v=m[1],y=m[2],x=n.batchSize,T=n.filterHeight,w=n.filterWidth,E=n.inChannels,S=n.inHeight,b=n.inWidth,C=n.outChannels,A=n.outHeight,_=n.outWidth,N=n.strideHeight,R=n.strideWidth,k=T-1-n.padInfo.top,I=w-1-n.padInfo.left,D=0;D<x;++D)for(var M=0;M<E;++M)for(var P=0;P<S;++P)for(var O=P-k,F=Math.max(0,Math.ceil(O/N)),L=Math.min(A,(T+O)/N),B=0;B<b;++B){for(var U=B-I,V=Math.max(0,Math.ceil(U/R)),z=Math.min(_,(w+U)/R),H=0,W=F;W<L;++W)for(var G=W*N-O,q=V;q<z;++q)for(var $=p*D+d*W+h*q,X=g*(T-1-G)+v*(w-1-(q*R-U))+y*M,K=0;K<C;++K){H+=l[$+K]*f[X+K];}o[i*D+s*P+u*B+M]=H;}return r.toTensor()},e.prototype.conv3dDerInput=function(e,t,n){for(var r=buffer(n.inShape,\"float32\"),o=r.values,a=r.strides,i=a[0],s=a[1],u=a[2],l=a[3],c=e.dataSync(),p=e.strides,d=p[0],h=p[1],f=p[2],m=p[3],g=t.dataSync(),v=t.strides,y=v[0],x=v[1],T=v[2],w=v[3],E=n.batchSize,S=n.filterDepth,b=n.filterHeight,C=n.filterWidth,A=n.inChannels,_=n.inDepth,N=n.inHeight,R=n.inWidth,k=n.outChannels,I=n.outDepth,D=n.outHeight,M=n.outWidth,P=n.strideDepth,O=n.strideHeight,F=n.strideWidth,L=S-1-n.padInfo.front,B=b-1-n.padInfo.top,U=C-1-n.padInfo.left,V=0;V<E;++V)for(var z=0;z<A;++z)for(var H=0;H<_;++H)for(var W=H-L,G=Math.max(0,Math.ceil(W/P)),q=Math.min(I,(S+W)/P),$=0;$<N;++$)for(var X=$-B,K=Math.max(0,Math.ceil(X/O)),j=Math.min(D,(b+X)/O),Y=0;Y<R;++Y){for(var Q=Y-U,J=Math.max(0,Math.ceil(Q/F)),Z=Math.min(M,(C+Q)/F),ee=0,te=G;te<q;++te)for(var ne=te*P-W,re=K;re<j;++re)for(var oe=re*O-X,ae=J;ae<Z;++ae)for(var ie=d*V+h*te+f*re+m*ae,se=y*(S-1-ne)+x*(b-1-oe)+T*(C-1-(ae*F-Q))+w*z,ue=0;ue<k;++ue){ee+=c[ie+ue]*g[se+ue];}o[i*V+s*H+u*$+l*Y+z]=ee;}return r.toTensor()},e.prototype.conv2dDerFilter=function(e,t,n){this.assertNotComplex([e,t],\"conv2dDerFilter\");for(var r=n.strideHeight,o=n.strideWidth,a=n.filterHeight,i=n.filterWidth,s=buffer(n.filterShape,\"float32\"),u=n.padInfo.left,l=n.padInfo.top,c=0;c<a;++c)for(var p=Math.max(0,Math.ceil((l-c)/r)),d=Math.min(n.outHeight,(n.inHeight+l-c)/r),h=0;h<i;++h)for(var f=Math.max(0,Math.ceil((u-h)/o)),m=Math.min(n.outWidth,(n.inWidth+u-h)/o),g=0;g<n.inChannels;++g)for(var v=0;v<n.outChannels;++v){for(var y=0,x=0;x<n.batchSize;++x)for(var T=p;T<d;++T)for(var w=c+T*r-l,E=f;E<m;++E){var S=h+E*o-u;y+=e.get(x,w,S,g)*t.get(x,T,E,v);}s.set(y,c,h,g,v);}return s.toTensor()},e.prototype.conv3dDerFilter=function(e,t,n){for(var r=n.strideDepth,o=n.strideHeight,a=n.strideWidth,i=n.filterDepth,s=n.filterHeight,u=n.filterWidth,l=buffer(n.filterShape,\"float32\"),c=l.values,p=l.strides,d=p[0],h=p[1],f=p[2],m=p[3],g=t.dataSync(),v=t.strides,y=v[0],x=v[1],T=v[2],w=v[3],E=e.dataSync(),S=e.strides,b=S[0],C=S[1],A=S[2],_=S[3],N=n.padInfo.front,R=n.padInfo.left,k=n.padInfo.top,I=0;I<i;++I)for(var D=Math.max(0,Math.ceil((N-I)/r)),M=Math.min(n.outDepth,(n.inDepth+N-I)/r),P=I*d,O=0;O<s;++O)for(var F=Math.max(0,Math.ceil((k-O)/o)),L=Math.min(n.outHeight,(n.inHeight+k-O)/o),B=O*h+P,U=0;U<u;++U)for(var V=Math.max(0,Math.ceil((R-U)/a)),z=Math.min(n.outWidth,(n.inWidth+R-U)/a),H=U*f+B,W=0;W<n.inChannels;++W)for(var G=W*m+H,q=0;q<n.outChannels;++q){for(var $=0,X=0;X<n.batchSize;++X)for(var K=X*b,j=X*y,Y=D;Y<M;++Y)for(var Q=(I+Y*r-N)*C+K,J=Y*x+j,Z=F;Z<L;++Z)for(var ee=(O+Z*o-k)*A+Q,te=Z*T+J,ne=V;ne<z;++ne){var re=ne*w+te;$+=E[(U+ne*a-R)*_+ee+W]*g[re+q];}c[G+q]=$;}return l.toTensor()},e.prototype.depthwiseConv2D=function(e,t,n){this.assertNotComplex([e,t],\"depthwiseConv2D\");for(var r=n.filterHeight,o=n.filterWidth,a=n.dilationHeight,i=n.dilationWidth,s=n.padInfo.left,u=n.padInfo.top,l=n.outChannels/n.inChannels,c=buffer(n.outShape,e.dtype),p=e.dataSync(),d=t.dataSync(),h=c.values,f=0;f<n.batchSize;++f)for(var m=f*e.strides[0],g=f*c.strides[0],v=0;v<n.outHeight;++v)for(var y=g+v*c.strides[1],x=v*n.strideHeight-s,T=0;T<r;++T){var w=x+T*a;if(!(w<0||w>=n.inHeight))for(var E=T*t.strides[0],S=m+w*e.strides[1],b=0;b<n.outWidth;++b)for(var C=y+b*c.strides[2],A=b*n.strideWidth-u,_=0;_<o;++_){var N=A+_*i;if(!(N<0||N>=n.inWidth))for(var R=E+_*t.strides[1],k=S+N*n.inChannels,I=C,D=R,M=0;M<n.inChannels;++M){for(var P=p[k+M],O=0;O<l;++O)h[I+O]+=P*d[D+O];I+=l,D+=l;}}}return c.toTensor()},e.prototype.depthwiseConv2DDerInput=function(e,t,n){this.assertNotComplex([e,t],\"depthwiseConv2DDerInput\");for(var r=buffer(n.inShape,\"float32\"),o=r.values,a=r.strides,i=a[0],s=a[1],u=a[2],l=e.dataSync(),c=e.strides,p=c[0],d=c[1],h=c[2],f=t.dataSync(),m=t.strides,g=m[0],v=m[1],y=m[2],x=n.batchSize,T=n.filterHeight,w=n.filterWidth,E=n.inChannels,S=n.inHeight,b=n.inWidth,C=n.outChannels,A=n.outHeight,_=n.outWidth,N=n.strideHeight,R=n.strideWidth,k=T-1-n.padInfo.top,I=w-1-n.padInfo.left,D=C/E,M=0;M<x;++M)for(var P=0;P<E;++P)for(var O=0;O<S;++O)for(var F=O-k,L=Math.max(0,Math.ceil(F/N)),B=Math.min(A,(T+F)/N),U=0;U<b;++U){for(var V=U-I,z=Math.max(0,Math.ceil(V/R)),H=Math.min(_,(w+V)/R),W=0,G=L;G<B;++G)for(var q=G*N-F,$=z;$<H;++$)for(var X=p*M+d*G+h*$,K=g*(T-1-q)+v*(w-1-($*R-V))+y*P,j=0;j<D;++j){W+=l[X+(P*D+j)]*f[K+j];}o[i*M+s*O+u*U+P]=W;}return r.toTensor()},e.prototype.depthwiseConv2DDerFilter=function(e,t,n){this.assertNotComplex([e,t],\"depthwiseConv2DDerFilter\");for(var r=n.strideHeight,o=n.strideWidth,a=n.filterHeight,i=n.filterWidth,s=buffer(n.filterShape,\"float32\"),u=n.padInfo.left,l=n.padInfo.top,c=n.outChannels/n.inChannels,p=0;p<a;++p)for(var d=Math.max(0,Math.ceil((l-p)/r)),h=Math.min(n.outHeight,(n.inHeight+l-p)/r),f=0;f<i;++f)for(var m=Math.max(0,Math.ceil((u-f)/o)),g=Math.min(n.outWidth,(n.inWidth+u-f)/o),v=0;v<n.outChannels;++v){for(var y=Math.trunc(v/c),x=v%c,T=0,w=0;w<n.batchSize;++w)for(var E=d;E<h;++E)for(var S=p+E*r-l,b=m;b<g;++b){var C=f+b*o-u;T+=e.get(w,S,C,y)*t.get(w,E,b,v);}s.set(T,p,f,y,x);}return s.toTensor()},e.prototype.tile=function(e,t){this.assertNotComplex(e,\"tile\");for(var n=new Array(e.rank),r=0;r<n.length;r++)n[r]=e.shape[r]*t[r];var o=buffer(n,e.dtype),a=e.buffer();for(r=0;r<o.values.length;++r){for(var i=o.indexToLoc(r),s=new Array(e.rank),u=0;u<s.length;u++)s[u]=i[u]%e.shape[u];var l=a.locToIndex(s);o.values[r]=a.values[l];}return o.toTensor()},e.prototype.pad=function(e,t,n){this.assertNotComplex(e,\"pad\");var r=t.map(function(t,n){return t[0]+e.shape[n]+t[1]}),o=t.map(function(e){return e[0]}),a=e.buffer(),i=buffer(r,e.dtype);0!==n&&i.values.fill(n);for(var s=0;s<e.size;s++){var u=a.indexToLoc(s),l=u.map(function(e,t){return e+o[t]});i.set.apply(i,[e.get.apply(e,u)].concat(l));}return i.toTensor()},e.prototype.transpose=function(e,t){this.assertNotComplex(e,\"transpose\");for(var n=new Array(e.rank),r=0;r<n.length;r++)n[r]=e.shape[t[r]];var o=e.dataSync(),a=buffer(n,e.dtype),i=e.buffer();for(r=0;r<e.size;++r){for(var s=i.indexToLoc(r),u=new Array(s.length),l=0;l<u.length;l++)u[l]=s[t[l]];var c=a.locToIndex(u);a.values[c]=o[r];}return a.toTensor()},e.prototype.gather=function(e,t,n){this.assertNotComplex([e,t],\"gather\");var r=e.shape.slice(),o=t.dataSync();r[n]=o.length;for(var a=buffer(r,e.dtype),i=e.buffer(),s=0;s<a.size;++s){var u=a.indexToLoc(s),l=u.slice();l[n]=o[u[n]];var c=i.locToIndex(l);a.values[s]=i.values[c];}return a.toTensor()},e.prototype.batchToSpaceND=function(e,t,n){this.assertNotComplex([e],\"batchToSpaceND\");var r=t.reduce(function(e,t){return e*t}),o=getReshaped(e.shape,t,r),a=getPermuted(o.length,t.length),i=getReshapedPermuted(e.shape,t,r),s=getSliceBeginCoords(n,t.length),u=getSliceSize(i,n,t.length);return e.reshape(o).transpose(a).reshape(i).slice(s,u)},e.prototype.spaceToBatchND=function(e,t,n){this.assertNotComplex([e],\"spaceToBatchND\");var r=t.reduce(function(e,t){return e*t}),o=[[0,0]];o.push.apply(o,n);for(var a=1+t.length;a<e.shape.length;++a)o.push([0,0]);var i=e.pad(o),s=getReshaped(i.shape,t,r,!1),u=getPermuted(s.length,t.length,!1),l=getReshapedPermuted(i.shape,t,r,!1);return i.reshape(s).transpose(u).reshape(l)},e.prototype.pool=function(e,t,n){this.assertNotComplex(e,\"pool\");for(var r=t.strideHeight,o=t.strideWidth,a=t.dilationHeight,i=t.dilationWidth,s=t.effectiveFilterHeight,u=t.effectiveFilterWidth,l=t.padInfo.top,c=t.padInfo.left,p=\"max\"===n?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,d=e.dataSync(),h=buffer(t.outShape,e.dtype),f=h.values,m=t.outShape[1]*t.outShape[2]*t.outShape[3],g=t.outShape[2]*t.outShape[3],v=t.outShape[3],y=0;y<t.batchSize;++y)for(var x=y*m,T=y*e.strides[0],w=0;w<t.inChannels;++w)for(var E=0;E<t.outHeight;++E)for(var S=E*r-l,b=Math.max(0,S),C=Math.min(t.inHeight,s+S),A=x+E*g,_=0;_<t.outWidth;++_){for(var N=_*o-c,R=Math.max(0,N),k=Math.min(t.inWidth,u+N),I=p,D=0,M=0,P=b;P<C;P+=a){for(var O=T+P*e.strides[1],F=R;F<k;F+=i){var L=d[O+F*e.strides[2]+w];\"max\"===n&&L>I?I=L:\"avg\"===n&&(D+=L,M++);}if(isNaN(I))break}f[A+_*v+w]=\"avg\"===n?D/M:I;}return h.toTensor()},e.prototype.maxPool=function(e,t){return this.pool(e,t,\"max\")},e.prototype.maxPoolPositions=function(e,t){for(var n=buffer(t.outShape,\"int32\"),r=t.strideHeight,o=t.strideWidth,a=t.dilationHeight,i=t.dilationWidth,s=t.effectiveFilterHeight,u=t.effectiveFilterWidth,l=t.padInfo.top,c=t.padInfo.left,p=0;p<t.batchSize;++p)for(var d=0;d<t.inChannels;++d)for(var h=0;h<t.outHeight;++h){for(var f=h*r-l,m=f;m<0;)m+=a;for(var g=Math.min(t.inHeight,s+f),v=0;v<t.outWidth;++v){for(var y=v*o-c,x=y;x<0;)x+=i;for(var T=Math.min(t.inWidth,u+y),w=Number.NEGATIVE_INFINITY,E=-1,S=m;S<g;S+=a)for(var b=S-f,C=x;C<T;C+=i){var A=C-y,_=e.get(p,S,C,d);_>w&&(w=_,E=b*u+A);}n.set(E,p,h,v,d);}}return n.toTensor()},e.prototype.maxPoolBackprop=function(e,t,n,r){this.assertNotComplex([t,n],\"maxPoolBackprop\");for(var o=this.maxPoolPositions(t,r),a=r.strideHeight,i=r.strideWidth,s=r.dilationHeight,u=r.dilationWidth,l=r.effectiveFilterHeight,c=r.effectiveFilterWidth,p=c-1-r.padInfo.left,d=l-1-r.padInfo.top,h=buffer(t.shape,\"float32\"),f=0;f<r.batchSize;++f)for(var m=0;m<r.inChannels;++m)for(var g=0;g<r.inHeight;++g)for(var v=0;v<r.inWidth;++v){for(var y=g-d,x=v-p,T=0,w=0;w<l;w+=s){var E=(y+w)/a;if(!(E<0||E>=r.outHeight||Math.floor(E)!==E))for(var S=0;S<c;S+=u){var b=(x+S)/i;if(!(b<0||b>=r.outWidth||Math.floor(b)!==b)){var C=l*c-1-o.get(f,E,b,m)===w*c+S?1:0;if(0!==C)T+=e.get(f,E,b,m)*C;}}}h.set(T,f,g,v,m);}return h.toTensor()},e.prototype.avgPoolBackprop=function(e,t,n){this.assertNotComplex([e,t],\"avgPoolBackprop\");for(var r=n.strideHeight,o=n.strideWidth,a=n.filterHeight,i=n.filterWidth,s=n.dilationHeight,u=n.dilationWidth,l=n.effectiveFilterHeight,c=n.effectiveFilterWidth,p=c-1-n.padInfo.left,d=l-1-n.padInfo.top,h=buffer(t.shape,\"float32\"),f=1/(a*i),m=0;m<n.batchSize;++m)for(var g=0;g<n.inChannels;++g)for(var v=0;v<n.inHeight;++v)for(var y=0;y<n.inWidth;++y){for(var x=v-d,T=y-p,w=0,E=0;E<l;E+=s){var S=(x+E)/r;if(!(S<0||S>=n.outHeight||Math.floor(S)!==S))for(var b=0;b<c;b+=u){var C=(T+b)/o;if(!(C<0||C>=n.outWidth||Math.floor(C)!==C))w+=e.get(m,S,C,g);}}h.set(w*f,m,v,y,g);}return h.toTensor()},e.prototype.cast=function(e,t){return castTensor(e,t,this)},e.prototype.reshape=function(e,t){return reshapeTensor(e,t)},e.prototype.avgPool=function(e,t){return this.assertNotComplex(e,\"avgPool\"),this.pool(e,t,\"avg\").toFloat()},e.prototype.resizeBilinear=function(e,t,n,r){this.assertNotComplex(e,\"resizeBilinear\");for(var o=e.shape,a=o[0],i=o[1],s=o[2],u=o[3],l=e.dataSync(),c=new Float32Array(sizeFromShape([a,t,n,u])),p=[r&&t>1?i-1:i,r&&n>1?s-1:s],d=[r&&t>1?t-1:t,r&&n>1?n-1:n],h=0,f=p[0]/d[0],m=p[1]/d[1],g=0;g<a;g++)for(var v=0;v<t;v++)for(var y=f*v,x=Math.floor(y),T=y-x,w=Math.min(i-1,Math.ceil(y)),E=g*e.strides[0]+x*e.strides[1],S=g*e.strides[0]+w*e.strides[1],b=0;b<n;b++)for(var C=m*b,A=Math.floor(C),_=C-A,N=Math.min(s-1,Math.ceil(C)),R=E+A*e.strides[2],k=S+A*e.strides[2],I=E+ +N*e.strides[2],D=S+N*e.strides[2],M=0;M<u;M++){var P=l[R+M],O=l[k+M],F=P+(l[I+M]-P)*_,L=F+(O+(l[D+M]-O)*_-F)*T;c[h++]=L;}return tensor(c,[a,t,n,u])},e.prototype.resizeBilinearBackprop=function(e,t,n){this.assertNotComplex([e,t],\"resizeBilinearBackprop\");for(var r=t.shape,o=r[0],a=r[1],i=r[2],s=r[3],u=e.shape,l=u[1],c=u[2],p=new Float32Array(o*a*i*s),d=[n&&l>1?a-1:a,n&&c>1?i-1:i],h=[n&&l>1?l-1:l,n&&c>1?c-1:c],f=d[0]/h[0],m=d[1]/h[1],g=e.dataSync(),v=0,y=0;y<o;y++)for(var x=y*t.strides[0],T=0;T<l;T++)for(var w=T*f,E=Math.floor(w),S=Math.min(Math.ceil(w),a-1),b=x+E*t.strides[1],C=x+S*t.strides[1],A=w-E,_=1-A,N=0;N<c;N++)for(var R=N*m,k=Math.floor(R),I=Math.min(Math.ceil(R),i-1),D=R-k,M=1-D,P=b+k*t.strides[2],O=b+I*t.strides[2],F=C+k*t.strides[2],L=C+I*t.strides[2],B=_*M,U=_*D,V=A*M,z=A*D,H=0;H<s;H++){var W=g[v++];p[P+H]+=W*B,p[O+H]+=W*U,p[F+H]+=W*V,p[L+H]+=W*z;}return tensor4d(p,[o,i,a,s],t.dtype)},e.prototype.resizeNearestNeighbor=function(e,t,n,r){this.assertNotComplex(e,\"resizeNearestNeighbor\");for(var o=e.shape,a=o[0],i=o[1],s=o[2],u=o[3],l=e.dataSync(),c=new Float32Array(a*t*n*u),p=[r&&t>1?i-1:i,r&&n>1?s-1:s],d=[r&&t>1?t-1:t,r&&n>1?n-1:n],h=p[0]/d[0],f=p[1]/d[1],m=0,g=0;g<a;g++)for(var v=g*e.strides[0],y=0;y<t;y++)for(var x=h*y,T=v+Math.min(i-1,r?Math.round(x):Math.floor(x))*e.strides[1],w=0;w<n;w++)for(var E=f*w,S=T+Math.min(s-1,r?Math.round(E):Math.floor(E))*e.strides[2],b=0;b<u;b++){var C=l[S+b];c[m++]=C;}return tensor(c,[a,t,n,u],e.dtype)},e.prototype.resizeNearestNeighborBackprop=function(e,t,n){this.assertNotComplex([e,t],\"resizeNearestNeighborBackprop\");for(var r=t.shape,o=r[0],a=r[1],i=r[2],s=r[3],u=e.shape,l=u[1],c=u[2],p=new Float32Array(o*a*i*s),d=e.dataSync(),h=[n&&l>1?a-1:a,n&&c>1?i-1:i],f=[n&&l>1?l-1:l,n&&c>1?c-1:c],m=h[0]/f[0],g=h[1]/f[1],v=1/m,y=1/g,x=2*Math.ceil(v)+2,T=2*Math.ceil(y)+2,w=0;w<o;w++)for(var E=w*t.strides[0],S=0;S<a;S++)for(var b=E+S*t.strides[1],C=Math.floor(S*v),A=Math.floor(C-x/2),_=0;_<i;_++)for(var N=b+_*t.strides[2],R=Math.floor(_*y),k=Math.floor(R-T/2),I=0;I<s;I++){for(var D=0,M=0;M<x;M++){var P=M+A;if(!(P<0||P>=l)){var O=E+P*e.strides[1],F=P*m;if(S===Math.min(a-1,n?Math.round(F):Math.floor(F)))for(var L=0;L<T;L++){var B=L+k;if(!(B<0||B>=c)){var U=O+B*e.strides[2],V=B*g;_===Math.min(i-1,n?Math.round(V):Math.floor(V))&&(D+=d[U+I]);}}}}p[N+I]=D;}return tensor4d(p,t.shape,t.dtype)},e.prototype.batchNormalization=function(e,t,n,r,o,a){this.assertNotComplex([e,t,n,o,a],\"batchNormalization\");for(var i=e.dataSync(),s=t.dataSync(),u=n.dataSync(),l=o?o.dataSync():new Float32Array([1]),c=a?a.dataSync():new Float32Array([0]),p=new Float32Array(i.length),d=c.length,h=l.length,f=u.length,m=s.length,g=0,v=0,y=0,x=0,T=0;T<i.length;++T)p[T]=c[g++]+(i[T]-s[v++])*l[y++]/Math.sqrt(u[x++]+r),g>=d&&(g=0),v>=m&&(v=0),y>=h&&(y=0),x>=f&&(x=0);return tensor4d(p,e.shape)},e.prototype.localResponseNormalization4D=function(e,t,n,r,o){this.assertNotComplex(e,\"localResponseNormalization4D\");var a=e.shape[3],i=a-1,s=e.dataSync(),u=sizeFromShape(e.shape),l=new Float32Array(u);function c(e){for(var n=e%a,r=e-n+Math.max(0,n-t),o=e-n+Math.min(n+t,i),u=0;r<=o;r++){var l=s[r];u+=l*l;}return u}for(var p=0;p<u;p++){var d=c(p),h=s[p]*Math.pow(n+r*d,-o);l[p]=h;}return tensor4d(l,e.shape)},e.prototype.LRNGrad=function(e,t,n,r,o,a,i){this.assertNotComplex(e,\"LRNGrad\");for(var s=e.shape[3],u=e.dataSync(),l=t.dataSync(),c=n.dataSync(),p=new Float32Array(sizeFromShape(e.shape)),d=sizeFromShape(e.shape),h=0;h<d;h++){for(var f=h%s,m=h-f+Math.max(0,f-r),g=h-f+Math.min(s,f+r+1),v=0,y=m;y<g;y++)v+=Math.pow(l[y],2);v=a*v+o;for(y=m;y<g;y++){var x=-2*a*i*l[y]*c[h]/v;h===y&&(x+=Math.pow(v,-i)),x*=u[h],p[y]+=x;}}return tensor4d(p,e.shape)},e.prototype.multinomial=function(e,t,n,r){this.assertNotComplex(e,\"multinomial\");for(var o=t?e:softmax(e),a=o.shape[0],i=o.shape[1],s=zeros([a,n],\"int32\"),u=s.dataSync(),l=o.dataSync(),c=0;c<a;++c){var p=c*i,d=new Float32Array(i-1);d[0]=l[p];for(var h=1;h<d.length;++h)d[h]=d[h-1]+l[p+h];for(var f=seedrandom_1(r.toString()),m=c*n,g=0;g<n;++g){var v=f();u[m+g]=d.length;for(var y=0;y<d.length;y++)if(v<d[y]){u[m+g]=y;break}}}return s},e.prototype.oneHot=function(e,t,n,r){this.assertNotComplex(e,\"oneHot\");var o=new Float32Array(e.size*t);o.fill(r);for(var a=0;a<e.size;++a)e.get(a)>=0&&e.get(a)<t&&(o[a*t+e.get(a)]=n);return tensor2d(o,[e.size,t],\"int32\")},e.prototype.nonMaxSuppression=function(e,t,n,r,o){return this.assertNotComplex(e,\"nonMaxSuppression\"),nonMaxSuppressionImpl(e.dataSync(),t.dataSync(),n,r,o)},e.prototype.fft=function(e){return this.fftBatch(e,!1)},e.prototype.ifft=function(e){return this.fftBatch(e,!0)},e.prototype.fftBatch=function(e,t){for(var n=e.shape[0],r=e.shape[1],o=buffer(e.shape,\"float32\"),a=buffer(e.shape,\"float32\"),i=real(e).as2D(n,r),s=imag(e).as2D(n,r),u=0;u<n;u++)for(var l=i.slice([u,0],[1,r]),c=s.slice([u,0],[1,r]),p=complex(l,c),d=this.fftImpl(p,t).dataSync(),h=0;h<r;h++){var f=getComplexWithIndex(d,h);o.values[u*r+h]=f.real,a.values[u*r+h]=f.imag;}return complex(o.toTensor(),a.toTensor()).as2D(n,r)},e.prototype.fftImpl=function(e,t){var n=e.as1D(),r=n.size;if(this.isExponentOf2(r)){var o=this.fftRadix2(n,r,t).as2D(e.shape[0],e.shape[1]);return t&&(o=complex(real(o).div(scalar(r)),imag(o).div(scalar(r)))),o}var a=e.dataSync(),i=splitRealAndImagArrays(this.fourierTransformByMatmul(a,r,t));return complex(i.real,i.imag).as2D(e.shape[0],e.shape[1])},e.prototype.isExponentOf2=function(e){return 0==(e&e-1)},e.prototype.fftRadix2=function(e,t,n){if(1===t)return e;var r=e.dataSync(),o=t/2,a=complexWithEvenIndex(r),i=complex(a.real,a.imag).as1D(),s=complexWithOddIndex(r),u=complex(s.real,s.imag).as1D();i=this.fftRadix2(i,o,n),u=this.fftRadix2(u,o,n);var l=exponents(t,n),c=complex(l.real,l.imag).mul(u),p=i.add(c),d=i.sub(c),h=real(p).concat(real(d)),f=imag(p).concat(imag(d));return complex(h,f).as1D()},e.prototype.fourierTransformByMatmul=function(e,t,n){for(var r=new Float32Array(2*t),o=0;o<t;o++){for(var a=0,i=0,s=0;s<t;s++){var u=exponent(o*s,t,n),l=getComplexWithIndex(e,s);a+=l.real*u.real-l.imag*u.imag,i+=l.real*u.imag+l.imag*u.real;}n&&(a/=t,i/=t),assignToTypedArray(r,a,i,o);}return r},e.prototype.depthToSpace=function(e,t,n){assert(\"NHWC\"===n,\"Only NHWC dataFormat supported on CPU for depthToSpace. Got \"+n),assert(t>1,\"blockSize should be > 1 for depthToSpace, but was: \"+t);for(var r=e.shape[0],o=e.shape[1],a=e.shape[2],i=e.shape[3],s=o*t,u=a*t,l=i/(t*t),c=e.dataSync(),p=new Float32Array(r*s*u*l),d=0,h=0;h<r;++h)for(var f=0;f<s;++f)for(var m=Math.floor(f/t),g=f%t,v=0;v<u;++v)for(var y=Math.floor(v/t),x=(g*t+v%t)*l,T=0;T<l;++T){var w=T+x+i*(y+a*(m+o*h));p[d++]=c[w];}return tensor4d(p,[r,s,u,l])},e.prototype.broadcastedBinaryOp=function(e,t,n,r){var o=assertAndGetBroadcastShape(e.shape,t.shape),a=buffer(o,n),i=e.dataSync(),s=t.dataSync(),u=getBroadcastDims(e.shape,o),l=getBroadcastDims(t.shape,o),c=a.values;if(u.length+l.length===0)for(var p=0;p<c.length;++p)c[p]=r(i[p%i.length],s[p%s.length]);else{var d=e.buffer(),h=t.buffer(),f=function(n){var o=a.indexToLoc(n),p=o.slice(-e.rank);u.forEach(function(e){return p[e]=0});var f=d.locToIndex(p),m=o.slice(-t.rank);l.forEach(function(e){return m[e]=0});var g=h.locToIndex(m);c[n]=r(i[f],s[g]);};for(p=0;p<c.length;++p)f(p);}return a.toTensor()},e.prototype.broadcastedBinaryComplexOp=function(e,t,n){var r=assertAndGetBroadcastShape(e.shape,t.shape),o=buffer(r,\"float32\"),a=buffer(r,\"float32\"),i=e.dataSync(),s=t.dataSync(),u=getBroadcastDims(e.shape,r),l=getBroadcastDims(t.shape,r),c=o.values,p=a.values;if(u.length+l.length===0)for(var d=0;d<c.length;d++){var h=d%i.length,f=d%s.length,m=n(i[2*h],i[2*h+1],s[2*f],s[2*f+1]);c[d]=m.real,p[d]=m.imag;}else{var g=this.data.get(e.dataId).complexTensors.real.buffer(),v=this.data.get(t.dataId).complexTensors.real.buffer(),y=function(r){var a=o.indexToLoc(r),d=a.slice(-e.rank);u.forEach(function(e){return d[e]=0});var h=g.locToIndex(d),f=a.slice(-t.rank);l.forEach(function(e){return f[e]=0});var m=v.locToIndex(f),y=n(i[2*h],i[2*h+1],s[2*m],s[2*m+1]);c[r]=y.real,p[r]=y.imag;};for(d=0;d<c.length;d++)y(d);}return this.complex(o.toTensor(),a.toTensor())},e.prototype.split=function(e,t,n){return split(e,t,n)},e.prototype.dispose=function(){},e.prototype.floatPrecision=function(){return 32},e.prototype.cropAndResize=function(e,t,n,r,o,a){for(var i=e.shape,s=i[0],u=i[1],l=i[2],c=i[3],p=t.shape[0],d=r[0],h=r[1],f=buffer([p,d,h,c],e.dtype),m=t.dataSync(),g=n.dataSync(),v=e.dataSync(),y=e.strides,x=f.strides,T=0;T<p;T++){var w=4*T,E=m[w],S=m[w+1],b=m[w+2],C=m[w+3],A=g[T];if(!(A>=s))for(var _=d>1?(b-E)*(u-1)/(d-1):0,N=h>1?(C-S)*(l-1)/(h-1):0,R=0;R<d;R++){var k=d>1?E*(u-1)+R*_:.5*(E+b)*(u-1);if(k<0||k>u-1)for(var I=0;I<h;I++)for(var D=0;D<c;D++){var M=D+I*x[2]+R*x[1]+T*x[0];f.values[M]=a;}else if(\"bilinear\"===o){var P=Math.floor(k),O=Math.ceil(k),F=k-P;for(I=0;I<h;I++){if((q=h>1?S*(l-1)+I*N:.5*(S+C)*(l-1))<0||q>l-1)for(D=0;D<c;D++){M=D+I*x[2]+R*x[1]+T*x[0];f.values[M]=a;}else{var L=Math.floor(q),B=Math.ceil(q),U=q-L;for(D=0;D<c;D++){var V=v[M=D+L*y[2]+P*y[1]+A*y[0]],z=v[M=D+B*y[2]+P*y[1]+A*y[0]],H=v[M=D+L*y[2]+O*y[1]+A*y[0]],W=V+(z-V)*U,G=H+(v[M=D+B*y[2]+O*y[1]+A*y[0]]-H)*U;M=D+I*x[2]+R*x[1]+T*x[0],f.values[M]=W+(G-W)*F;}}}}else for(I=0;I<h;++I){var q;if((q=h>1?S*(l-1)+I*N:.5*(S+C)*(l-1))<0||q>l-1)for(D=0;D<c;D++){M=D+I*x[2]+R*x[1]+T*x[0];f.values[M]=a;}else{var $=Math.round(q),X=Math.round(k);for(D=0;D<c;D++){var K=D+$*y[2]+X*y[1]+A*y[0],j=D+I*x[2]+R*x[1]+T*x[0];f.values[j]=v[K];}}}}}return f.toTensor()},e.prototype.sparseToDense=function(e,t,n,r){var o=calculateShapes(t,e,n),a=o.sliceRank,i=o.numUpdates,s=o.sliceSize,u=o.strides,l=o.outputSize;return this.scatter(e,t,n,l,s,i,a,u,r,!1)},e.prototype.gatherND=function(e,t){var n=t.shape,r=n[n.length-1],o=prepareAndValidate(e,t),a=o[0],i=o[1],s=o[2],u=o[3];if(0===i)return tensor([],a,e.dtype);for(var l=new TensorBuffer([i,s],e.dtype),c=t.dataSync(),p=e.dataSync(),d=0;d<i;d++){for(var h=[],f=0,m=0;m<r;m++){var g=c[d*r+m];f+=g*u[m],h.push(g);}if(f<0||f>=e.size/s)throw new Error(\"Invalid indices: \"+h+\" does not index into \"+e.shape);for(var v=0;v<s;v++)l.values[d*s+v]=p[f*s+v];}return l.toTensor().reshape(a)},e.prototype.scatterND=function(e,t,n){var r=calculateShapes(t,e,n),o=r.sliceRank,a=r.numUpdates,i=r.sliceSize,s=r.strides,u=r.outputSize,l=scalar(0);return this.scatter(e,t,n,u,i,a,o,s,l,!0)},e.prototype.scatter=function(e,t,n,r,o,a,i,s,u,l){var c=[r/o,o],p=e.dataSync(),d=t.dataSync();if(0===r)return tensor([],n,t.dtype);var h=new TensorBuffer(c,t.dtype);h.values.fill(u.dataSync()[0]);for(var f=0;f<a;f++){for(var m=[],g=0,v=0;v<i;v++){var y=p[f*i+v];m.push(y),g+=y*s[v];}if(g<0||g>=r/o)throw new Error(\"Invalid indices: \"+m+\" does not index into \"+n);for(var x=0;x<o;x++)l?h.values[g*o+x]+=d[f*o+x]:h.values[g*o+x]=0===t.rank?d[0]:d[f*o+x];}return h.toTensor().reshape(n)},e}();ENV.registerBackend(\"cpu\",function(){return new MathBackendCPU},1,setTensorTracker);var delayCallback=\"undefined\"!=typeof requestAnimationFrame?requestAnimationFrame:setImmediate;function nextFrame(){return new Promise(function(e){return delayCallback(function(){return e()})})}var DTYPE_VALUE_SIZE_MAP={float32:4,int32:4,uint16:2,uint8:1,bool:1};function encodeWeights(e){return __awaiter(this,void 0,void 0,function(){var t,n,r,o;return __generator(this,function(a){switch(a.label){case 0:for(r in t=[],n=[],e){if(\"float32\"!==(o=e[r]).dtype&&\"int32\"!==o.dtype&&\"bool\"!==o.dtype)throw new Error(\"Unsupported dtype in weight '\"+r+\"': \"+o.dtype);t.push({name:r,shape:o.shape,dtype:o.dtype}),n.push(o.data());}return [4,Promise.all(n)];case 1:return [2,{data:concatenateTypedArrays(a.sent()),specs:t}]}})})}function decodeWeights(e,t){for(var n={},r=0,o=function(t){var o=t.name,a=t.dtype,i=t.shape,s=sizeFromShape(i),u=void 0;if(\"quantization\"in t){var l=t.quantization;if(\"uint8\"!==l.dtype&&\"uint16\"!==l.dtype)throw new Error(\"Weight \"+t.name+\" has unknown quantization dtype \"+l.dtype+\". Supported quantization dtypes are: 'uint8' and 'uint16'.\");var c=DTYPE_VALUE_SIZE_MAP[l.dtype],p=e.slice(r,r+s*c),d=\"uint8\"===l.dtype?new Uint8Array(p):new Uint16Array(p);if(\"float32\"===a)u=Float32Array.from(d,function(e){return e*l.scale+l.min});else{if(\"int32\"!==a)throw new Error(\"Unsupported dtype in weight '\"+o+\"': \"+a);u=Int32Array.from(d,function(e){return Math.round(e*l.scale+l.min)});}r+=s*c;}else{var h=DTYPE_VALUE_SIZE_MAP[a];p=e.slice(r,r+s*h);if(\"float32\"===a)u=new Float32Array(p);else if(\"int32\"===a)u=new Int32Array(p);else{if(\"bool\"!==a)throw new Error(\"Unsupported dtype in weight '\"+o+\"': \"+a);u=new Uint8Array(p);}r+=s*h;}var f=void 0;if(\"float32\"===a)f=tensor(u,i,\"float32\");else if(\"int32\"===a)f=tensor(u,i,\"int32\");else{if(\"bool\"!==a)throw new Error(\"Unsupported dtype in weight '\"+o+\"': \"+a);f=tensor(u,i,\"bool\");}n[o]=f;},a=0,i=t;a<i.length;a++){o(i[a]);}return n}function concatenateTypedArrays(e){if(null===e)throw new Error(\"Invalid input value: \"+JSON.stringify(e));var t=0,n=[];e.forEach(function(e){if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error(\"Unsupported TypedArray subtype: \"+e.constructor.name)});var r=new Uint8Array(t),o=0;return n.forEach(function(e){r.set(new Uint8Array(e.buffer),o),o+=e.byteLength;}),r.buffer}var useNodeBuffer=\"undefined\"!=typeof Buffer&&(\"undefined\"==typeof Blob||\"undefined\"==typeof atob||\"undefined\"==typeof btoa);function stringByteLength(e){return useNodeBuffer?Buffer.byteLength(e):new Blob([e]).size}function arrayBufferToBase64String(e){return useNodeBuffer?Buffer.from(e).toString(\"base64\"):btoa(String.fromCharCode.apply(null,new Uint8Array(e)))}function base64StringToArrayBuffer(e){if(useNodeBuffer){var t=Buffer.from(e,\"base64\");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}for(var n=atob(e),r=new Uint8Array(n.length),o=0;o<n.length;++o)r.set([n.charCodeAt(o)],o);return r.buffer}function concatenateArrayBuffers(e){var t=0;e.forEach(function(e){t+=e.byteLength;});var n=new Uint8Array(t),r=0;return e.forEach(function(e){n.set(new Uint8Array(e),r),r+=e.byteLength;}),n.buffer}function basename(e){for(e=e.trim();e.endsWith(\"/\");)e=e.slice(0,e.length-1);var t=e.split(\"/\");return t[t.length-1]}function getModelArtifactsInfoForJSON(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error(\"Expected JSON model topology, received ArrayBuffer.\");return {dateSaved:new Date,modelTopologyType:\"JSON\",modelTopologyBytes:null==e.modelTopology?0:stringByteLength(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:stringByteLength(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:e.weightData.byteLength}}var IORouterRegistry=function(){function e(){this.saveRouters=[],this.loadRouters=[];}return e.getInstance=function(){return null==e.instance&&(e.instance=new e),e.instance},e.registerSaveRouter=function(t){e.getInstance().saveRouters.push(t);},e.registerLoadRouter=function(t){e.getInstance().loadRouters.push(t);},e.getSaveHandlers=function(t){return e.getHandlers(t,\"save\")},e.getLoadHandlers=function(t){return e.getHandlers(t,\"load\")},e.getHandlers=function(e,t){var n=[];return (\"load\"===t?this.getInstance().loadRouters:this.getInstance().saveRouters).forEach(function(t){var r=t(e);null!==r&&n.push(r);}),n},e}(),URL_SCHEME_SUFFIX=\"://\",ModelStoreManagerRegistry=function(){function e(){this.managers={};}return e.getInstance=function(){return null==e.instance&&(e.instance=new e),e.instance},e.registerManager=function(t,n){assert(null!=t,\"scheme must not be undefined or null.\"),t.endsWith(URL_SCHEME_SUFFIX)&&(t=t.slice(0,t.indexOf(URL_SCHEME_SUFFIX))),assert(t.length>0,\"scheme must not be an empty string.\");var r=e.getInstance();assert(null==r.managers[t],\"A model store manager is already registered for scheme '\"+t+\"'.\"),r.managers[t]=n;},e.getManager=function(e){var t=this.getInstance().managers[e];if(null==t)throw new Error(\"Cannot find model manager for scheme '\"+e+\"'\");return t},e.getSchemes=function(){return Object.keys(this.getInstance().managers)},e}();function parseURL(e){if(-1===e.indexOf(URL_SCHEME_SUFFIX))throw new Error(\"The url string provided does not contain a scheme. Supported schemes are: \"+ModelStoreManagerRegistry.getSchemes().join(\",\"));return {scheme:e.split(URL_SCHEME_SUFFIX)[0],path:e.split(URL_SCHEME_SUFFIX)[1]}}function cloneModelInternal(e,t,n){return void 0===n&&(n=!1),__awaiter(this,void 0,void 0,function(){var r,o,a,i,s,u,l,c,p;return __generator(this,function(d){switch(d.label){case 0:return assert(e!==t,\"Old path and new path are the same: '\"+e+\"'\"),assert((r=IORouterRegistry.getLoadHandlers(e)).length>0,\"Copying failed because no load handler is found for source URL \"+e+\".\"),assert(r.length<2,\"Copying failed because more than one (\"+r.length+\") load handlers for source URL \"+e+\".\"),o=r[0],assert((a=IORouterRegistry.getSaveHandlers(t)).length>0,\"Copying failed because no save handler is found for destination URL \"+t+\".\"),assert(a.length<2,\"Copying failed because more than one (\"+r.length+\") save handlers for destination URL \"+t+\".\"),i=a[0],s=parseURL(e).scheme,u=parseURL(e).path,l=s===parseURL(e).scheme,[4,o.load()];case 1:return c=d.sent(),n&&l?[4,ModelStoreManagerRegistry.getManager(s).removeModel(u)]:[3,3];case 2:d.sent(),d.label=3;case 3:return [4,i.save(c)];case 4:return p=d.sent(),!n||l?[3,6]:[4,ModelStoreManagerRegistry.getManager(s).removeModel(u)];case 5:d.sent(),d.label=6;case 6:return [2,p.modelArtifactsInfo]}})})}function listModels(){return __awaiter(this,void 0,void 0,function(){var e,t,n,r,o,a,i;return __generator(this,function(s){switch(s.label){case 0:e=ModelStoreManagerRegistry.getSchemes(),t={},n=0,r=e,s.label=1;case 1:return n<r.length?(o=r[n],[4,ModelStoreManagerRegistry.getManager(o).listModels()]):[3,4];case 2:for(i in a=s.sent())t[o+URL_SCHEME_SUFFIX+i]=a[i];s.label=3;case 3:return n++,[3,1];case 4:return [2,t]}})})}function removeModel(e){return __awaiter(this,void 0,void 0,function(){var t;return __generator(this,function(n){switch(n.label){case 0:return t=parseURL(e),[4,ModelStoreManagerRegistry.getManager(t.scheme).removeModel(t.path)];case 1:return [2,n.sent()]}})})}function copyModel(e,t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(n){switch(n.label){case 0:return [4,cloneModelInternal(e,t,!1)];case 1:return [2,n.sent()]}})})}function moveModel(e,t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(n){switch(n.label){case 0:return [4,cloneModelInternal(e,t,!0)];case 1:return [2,n.sent()]}})})}var DATABASE_NAME=\"tensorflowjs\",DATABASE_VERSION=1,MODEL_STORE_NAME=\"models_store\",INFO_STORE_NAME=\"model_info_store\";function getIndexedDBFactory(){if(!ENV.get(\"IS_BROWSER\"))throw new Error(\"Failed to obtain IndexedDB factory because the current environmentis not a web browser.\");var e=window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error(\"The current browser does not appear to support IndexedDB.\");return t}function setUpDatabase(e){var t=e.result;t.createObjectStore(MODEL_STORE_NAME,{keyPath:\"modelPath\"}),t.createObjectStore(INFO_STORE_NAME,{keyPath:\"modelPath\"});}var BrowserIndexedDB=function(){function e(e){if(this.indexedDB=getIndexedDBFactory(),null==e||!e)throw new Error(\"For IndexedDB, modelPath must not be null, undefined or empty.\");this.modelPath=e;}return e.prototype.save=function(e){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){if(e.modelTopology instanceof ArrayBuffer)throw new Error(\"BrowserLocalStorage.save() does not support saving model topology in binary formats yet.\");return [2,this.databaseAction(this.modelPath,e)]})})},e.prototype.load=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return [2,this.databaseAction(this.modelPath)]})})},e.prototype.databaseAction=function(e,t){var n=this;return new Promise(function(e,r){var o=n.indexedDB.open(DATABASE_NAME,DATABASE_VERSION);o.onupgradeneeded=function(){return setUpDatabase(o)},o.onsuccess=function(){var a=o.result;if(null==t){var i=a.transaction(MODEL_STORE_NAME,\"readonly\"),s=i.objectStore(MODEL_STORE_NAME).get(n.modelPath);s.onsuccess=function(){if(null==s.result)return a.close(),r(new Error(\"Cannot find model with path '\"+n.modelPath+\"' in IndexedDB.\"));e(s.result.modelArtifacts);},s.onerror=function(e){return a.close(),r(s.error)},i.oncomplete=function(){return a.close()};}else{var u,l=getModelArtifactsInfoForJSON(t),c=a.transaction(INFO_STORE_NAME,\"readwrite\"),p=c.objectStore(INFO_STORE_NAME),d=p.put({modelPath:n.modelPath,modelArtifactsInfo:l});d.onsuccess=function(){var o=(u=a.transaction(MODEL_STORE_NAME,\"readwrite\")).objectStore(MODEL_STORE_NAME).put({modelPath:n.modelPath,modelArtifacts:t,modelArtifactsInfo:l});o.onsuccess=function(){return e({modelArtifactsInfo:l})},o.onerror=function(e){var t=(p=c.objectStore(INFO_STORE_NAME)).delete(n.modelPath);t.onsuccess=function(){return a.close(),r(o.error)},t.onerror=function(e){return a.close(),r(o.error)};};},d.onerror=function(e){return a.close(),r(d.error)},c.oncomplete=function(){null==u?a.close():u.oncomplete=function(){return a.close()};};}},o.onerror=function(e){return r(o.error)};})},e.URL_SCHEME=\"indexeddb://\",e}(),indexedDBRouter=function(e){return ENV.get(\"IS_BROWSER\")&&!Array.isArray(e)&&e.startsWith(BrowserIndexedDB.URL_SCHEME)?browserIndexedDB(e.slice(BrowserIndexedDB.URL_SCHEME.length)):null};function browserIndexedDB(e){return new BrowserIndexedDB(e)}function maybeStripScheme(e){return e.startsWith(BrowserIndexedDB.URL_SCHEME)?e.slice(BrowserIndexedDB.URL_SCHEME.length):e}IORouterRegistry.registerSaveRouter(indexedDBRouter),IORouterRegistry.registerLoadRouter(indexedDBRouter);var BrowserIndexedDBManager=function(){function e(){this.indexedDB=getIndexedDBFactory();}return e.prototype.listModels=function(){return __awaiter(this,void 0,void 0,function(){var e=this;return __generator(this,function(t){return [2,new Promise(function(t,n){var r=e.indexedDB.open(DATABASE_NAME,DATABASE_VERSION);r.onupgradeneeded=function(){return setUpDatabase(r)},r.onsuccess=function(){var e=r.result,o=e.transaction(INFO_STORE_NAME,\"readonly\"),a=o.objectStore(INFO_STORE_NAME).getAll();a.onsuccess=function(){for(var e={},n=0,r=a.result;n<r.length;n++){var o=r[n];e[o.modelPath]=o.modelArtifactsInfo;}t(e);},a.onerror=function(t){return e.close(),n(a.error)},o.oncomplete=function(){return e.close()};},r.onerror=function(e){return n(r.error)};})]})})},e.prototype.removeModel=function(e){return __awaiter(this,void 0,void 0,function(){var t=this;return __generator(this,function(n){return e=maybeStripScheme(e),[2,new Promise(function(n,r){var o=t.indexedDB.open(DATABASE_NAME,DATABASE_VERSION);o.onupgradeneeded=function(){return setUpDatabase(o)},o.onsuccess=function(){var t,a=o.result,i=a.transaction(INFO_STORE_NAME,\"readwrite\"),s=i.objectStore(INFO_STORE_NAME),u=s.get(e);u.onsuccess=function(){if(null==u.result)return a.close(),r(new Error(\"Cannot find model with path '\"+e+\"' in IndexedDB.\"));var o=s.delete(e),i=function(){var o=(t=a.transaction(MODEL_STORE_NAME,\"readwrite\")).objectStore(MODEL_STORE_NAME).delete(e);o.onsuccess=function(){return n(u.result.modelArtifactsInfo)},o.onerror=function(e){return r(u.error)};};o.onsuccess=i,o.onerror=function(e){return i(),a.close(),r(u.error)};},u.onerror=function(e){return a.close(),r(u.error)},i.oncomplete=function(){null==t?a.close():t.oncomplete=function(){return a.close()};};},o.onerror=function(e){return r(o.error)};})]})})},e}();if(ENV.get(\"IS_BROWSER\"))try{ModelStoreManagerRegistry.registerManager(BrowserIndexedDB.URL_SCHEME,new BrowserIndexedDBManager);}catch(e){}var PATH_SEPARATOR=\"/\",PATH_PREFIX=\"tensorflowjs_models\",INFO_SUFFIX=\"info\",MODEL_TOPOLOGY_SUFFIX=\"model_topology\",WEIGHT_SPECS_SUFFIX=\"weight_specs\",WEIGHT_DATA_SUFFIX=\"weight_data\";function getModelKeys(e){return {info:[PATH_PREFIX,e,INFO_SUFFIX].join(PATH_SEPARATOR),topology:[PATH_PREFIX,e,MODEL_TOPOLOGY_SUFFIX].join(PATH_SEPARATOR),weightSpecs:[PATH_PREFIX,e,WEIGHT_SPECS_SUFFIX].join(PATH_SEPARATOR),weightData:[PATH_PREFIX,e,WEIGHT_DATA_SUFFIX].join(PATH_SEPARATOR)}}function getModelPathFromKey(e){var t=e.split(PATH_SEPARATOR);if(t.length<3)throw new Error(\"Invalid key format: \"+e);return t.slice(1,t.length-1).join(PATH_SEPARATOR)}function maybeStripScheme$1(e){return e.startsWith(BrowserLocalStorage.URL_SCHEME)?e.slice(BrowserLocalStorage.URL_SCHEME.length):e}var BrowserLocalStorage=function(){function e(e){if(!ENV.get(\"IS_BROWSER\")||void 0===window.localStorage)throw new Error(\"The current environment does not support local storage.\");if(this.LS=window.localStorage,null==e||!e)throw new Error(\"For local storage, modelPath must not be null, undefined or empty.\");this.modelPath=e,this.keys=getModelKeys(this.modelPath);}return e.prototype.save=function(e){return __awaiter(this,void 0,void 0,function(){var t,n,r,o;return __generator(this,function(a){if(e.modelTopology instanceof ArrayBuffer)throw new Error(\"BrowserLocalStorage.save() does not support saving model topology in binary formats yet.\");t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),r=getModelArtifactsInfoForJSON(e);try{return this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,arrayBufferToBase64String(e.weightData)),[2,{modelArtifactsInfo:r}]}catch(e){for(o in this.keys)this.LS.removeItem(this.keys[o]);throw new Error(\"Failed to save model '\"+this.modelPath+\"' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=\"+r.modelTopologyBytes+\", weightSpecsBytes=\"+r.weightSpecsBytes+\", weightDataBytes=\"+r.weightDataBytes+\".\")}return [2]})})},e.prototype.load=function(){return __awaiter(this,void 0,void 0,function(){var e,t,n,r,o;return __generator(this,function(a){if(null==(e=JSON.parse(this.LS.getItem(this.keys.info))))throw new Error(\"In local storage, there is no model with name '\"+this.modelPath+\"'\");if(\"JSON\"!==e.modelTopologyType)throw new Error(\"BrowserLocalStorage does not support loading non-JSON model topology yet.\");if(t={},null==(n=JSON.parse(this.LS.getItem(this.keys.topology))))throw new Error(\"In local storage, the topology of model '\"+this.modelPath+\"' is missing.\");if(t.modelTopology=n,null==(r=JSON.parse(this.LS.getItem(this.keys.weightSpecs))))throw new Error(\"In local storage, the weight specs of model '\"+this.modelPath+\"' are missing.\");if(t.weightSpecs=r,null==(o=this.LS.getItem(this.keys.weightData)))throw new Error(\"In local storage, the binary weight values of model '\"+this.modelPath+\"' are missing.\");return t.weightData=base64StringToArrayBuffer(o),[2,t]})})},e.URL_SCHEME=\"localstorage://\",e}(),localStorageRouter=function(e){return ENV.get(\"IS_BROWSER\")&&!Array.isArray(e)&&e.startsWith(BrowserLocalStorage.URL_SCHEME)?browserLocalStorage(e.slice(BrowserLocalStorage.URL_SCHEME.length)):null};function browserLocalStorage(e){return new BrowserLocalStorage(e)}IORouterRegistry.registerSaveRouter(localStorageRouter),IORouterRegistry.registerLoadRouter(localStorageRouter);var BrowserLocalStorageManager=function(){function e(){assert(ENV.get(\"IS_BROWSER\"),\"Current environment is not a web browser\"),assert(void 0!==window.localStorage,\"Current browser does not appear to support localStorage\"),this.LS=window.localStorage;}return e.prototype.listModels=function(){return __awaiter(this,void 0,void 0,function(){var e,t,n,r,o,a;return __generator(this,function(i){for(e={},t=PATH_PREFIX+PATH_SEPARATOR,n=PATH_SEPARATOR+INFO_SUFFIX,r=0;r<this.LS.length;++r)(o=this.LS.key(r)).startsWith(t)&&o.endsWith(n)&&(a=getModelPathFromKey(o),e[a]=JSON.parse(this.LS.getItem(o)));return [2,e]})})},e.prototype.removeModel=function(e){return __awaiter(this,void 0,void 0,function(){var t,n;return __generator(this,function(r){if(e=maybeStripScheme$1(e),t=getModelKeys(e),null==this.LS.getItem(t.info))throw new Error(\"Cannot find model at path '\"+e+\"'\");return n=JSON.parse(this.LS.getItem(t.info)),this.LS.removeItem(t.info),this.LS.removeItem(t.topology),this.LS.removeItem(t.weightSpecs),this.LS.removeItem(t.weightData),[2,n]})})},e}();if(ENV.get(\"IS_BROWSER\"))try{ModelStoreManagerRegistry.registerManager(BrowserLocalStorage.URL_SCHEME,new BrowserLocalStorageManager);}catch(e){}var DEFAULT_FILE_NAME_PREFIX=\"model\",DEFAULT_JSON_EXTENSION_NAME=\".json\",DEFAULT_WEIGHT_DATA_EXTENSION_NAME=\".weights.bin\",BrowserDownloads=function(){function e(t){if(!ENV.get(\"IS_BROWSER\"))throw new Error(\"browserDownloads() cannot proceed because the current environment is not a browser.\");t.startsWith(e.URL_SCHEME)&&(t=t.slice(e.URL_SCHEME.length)),null!=t&&0!==t.length||(t=DEFAULT_FILE_NAME_PREFIX),this.modelTopologyFileName=t+DEFAULT_JSON_EXTENSION_NAME,this.weightDataFileName=t+DEFAULT_WEIGHT_DATA_EXTENSION_NAME;}return e.prototype.save=function(e){return __awaiter(this,void 0,void 0,function(){var t,n,r,o,a,i;return __generator(this,function(s){if(t=window.URL.createObjectURL(new Blob([e.weightData],{type:\"application/octet-stream\"})),e.modelTopology instanceof ArrayBuffer)throw new Error(\"BrowserDownloads.save() does not support saving model topology in binary formats yet.\");return n=[{paths:[\"./\"+this.weightDataFileName],weights:e.weightSpecs}],r={modelTopology:e.modelTopology,weightsManifest:n},o=window.URL.createObjectURL(new Blob([JSON.stringify(r)],{type:\"application/json\"})),(a=null==this.jsonAnchor?document.createElement(\"a\"):this.jsonAnchor).download=this.modelTopologyFileName,a.href=o,a.click(),null!=e.weightData&&((i=null==this.weightDataAnchor?document.createElement(\"a\"):this.weightDataAnchor).download=this.weightDataFileName,i.href=t,i.click()),[2,{modelArtifactsInfo:getModelArtifactsInfoForJSON(e)}]})})},e.URL_SCHEME=\"downloads://\",e}(),BrowserFiles=function(){function e(e){if(null==e||e.length<1)throw new Error(\"When calling browserFiles, at least 1 file is required, but received \"+e);this.files=e;}return e.prototype.load=function(){return __awaiter(this,void 0,void 0,function(){var e,t,n=this;return __generator(this,function(r){return e=this.files[0],t=this.files.slice(1),[2,new Promise(function(r,o){var a=new FileReader;a.onload=function(a){var i=JSON.parse(a.target.result),s=i.modelTopology;if(null!=s){0===t.length&&r({modelTopology:s});var u=i.weightsManifest;if(null!=u){var l;try{l=n.checkManifestAndWeightFiles(u,t);}catch(e){return void o(e)}var c=[],p=[],d=[];u.forEach(function(e){e.paths.forEach(function(e){p.push(e),d.push(null);}),c.push.apply(c,e.weights);}),u.forEach(function(e){e.paths.forEach(function(e){var t=new FileReader;t.onload=function(t){var n=t.target.result,o=p.indexOf(e);d[o]=n,-1===d.indexOf(null)&&r({modelTopology:s,weightSpecs:c,weightData:concatenateArrayBuffers(d)});},t.onerror=function(t){return o(\"Failed to weights data from file of path '\"+e+\"'.\")},t.readAsArrayBuffer(l[e]);});});}else o(new Error(\"weightManifest field is missing from file \"+e.name));}else o(new Error(\"modelTopology field is missing from file \"+e.name));},a.onerror=function(t){return o(\"Failed to read model topology and weights manifest JSON from file '\"+e.name+\"'. BrowserFiles supports loading Keras-style tf.Model artifacts only.\")},a.readAsText(e);})]})})},e.prototype.checkManifestAndWeightFiles=function(e,t){for(var n=[],r=t.map(function(e){return basename(e.name)}),o={},a=0,i=e;a<i.length;a++){i[a].paths.forEach(function(e){var a=basename(e);if(-1!==n.indexOf(a))throw new Error(\"Duplicate file basename found in weights manifest: '\"+a+\"'\");if(n.push(a),-1===r.indexOf(a))throw new Error(\"Weight file with basename '\"+a+\"' is not provided.\");o[e]=t[r.indexOf(a)];});}if(n.length!==t.length)throw new Error(\"Mismatch in the number of files in weights manifest (\"+n.length+\") and the number of weight files provided (\"+t.length+\").\");return o},e}(),browserDownloadsRouter=function(e){return ENV.get(\"IS_BROWSER\")&&!Array.isArray(e)&&e.startsWith(BrowserDownloads.URL_SCHEME)?browserDownloads(e.slice(BrowserDownloads.URL_SCHEME.length)):null};function browserDownloads(e){return void 0===e&&(e=\"model\"),new BrowserDownloads(e)}function browserFiles(e){return new BrowserFiles(e)}function loadWeightsAsArrayBuffer(e,t,n){return __awaiter(this,void 0,void 0,function(){var r,o;return __generator(this,function(a){switch(a.label){case 0:return null==n&&(n=fetch),r=e.map(function(e){return n(e,t)}),[4,Promise.all(r)];case 1:return o=a.sent(),[4,Promise.all(o.map(function(e){return e.arrayBuffer()}))];case 2:return [2,a.sent()]}})})}function loadWeights(e,t,n,r){return void 0===t&&(t=\"\"),__awaiter(this,void 0,void 0,function(){return __generator(this,function(o){return [2,weightsLoaderFactory(function(e){return loadWeightsAsArrayBuffer(e,r)})(e,t,n)]})})}function weightsLoaderFactory(e){var t=this;return function(n,r,o){return void 0===r&&(r=\"\"),__awaiter(t,void 0,void 0,function(){var t,a,i,s,u,l,c,p,d,h;return __generator(this,function(f){switch(f.label){case 0:if(t=n.map(function(){return !1}),a={},i=null!=o?o.map(function(){return !1}):[],s=[],n.forEach(function(e,n){var r=0;e.weights.forEach(function(e){var u=\"quantization\"in e?e.quantization.dtype:e.dtype,l=DTYPE_VALUE_SIZE_MAP[u]*sizeFromShape(e.shape),c=function(){t[n]=!0,null==a[n]&&(a[n]=[]),a[n].push({manifestEntry:e,groupOffset:r,sizeBytes:l});};null!=o?o.forEach(function(t,n){t===e.name&&(c(),i[n]=!0);}):c(),s.push(e.name),r+=l;});}),!i.every(function(e){return e}))throw u=o.filter(function(e,t){return !i[t]}),new Error(\"Could not find weights in manifest with names: \"+u.join(\", \")+\". \\nManifest JSON has weights with names: \"+s.join(\", \")+\".\");return l=t.reduce(function(e,t,n){return t&&e.push(n),e},[]),c=[],l.forEach(function(e){n[e].paths.forEach(function(e){var t=r+(r.endsWith(\"/\")?\"\":\"/\")+e;c.push(t);});}),[4,e(c)];case 1:return p=f.sent(),d={},h=0,l.forEach(function(e){for(var t=n[e].paths.length,r=0,o=0;o<t;o++)r+=p[h+o].byteLength;for(var i=new ArrayBuffer(r),s=new Uint8Array(i),u=0,l=0;l<t;l++){var c=new Uint8Array(p[h+l]);s.set(c,u),u+=c.byteLength;}a[e].forEach(function(e){var t=decodeWeights(i.slice(e.groupOffset,e.groupOffset+e.sizeBytes),[e.manifestEntry]);for(var n in t)d[n]=t[n];}),h+=t;}),[2,d]}})})}}IORouterRegistry.registerSaveRouter(browserDownloadsRouter);var BrowserHTTPRequest=function(){function e(e,t,n,r){if(this.weightPathPrefix=n,this.DEFAULT_METHOD=\"POST\",null==r){if(\"undefined\"==typeof fetch)throw new Error(\"browserHTTPRequest is not supported outside the web browser without a fetch polyfill.\");this.fetchFunc=fetch.bind(\"undefined\"==typeof window?null:window);}else assert(\"function\"==typeof r,\"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)\"),this.fetchFunc=r;if(assert(null!=e&&e.length>0,\"URL path for browserHTTPRequest must not be null, undefined or empty.\"),Array.isArray(e)&&assert(2===e.length,\"URL paths for browserHTTPRequest must have a length of 2, (actual length is \"+e.length+\").\"),this.path=e,null!=t&&null!=t.body)throw new Error(\"requestInit is expected to have no pre-existing body, but has one.\");this.requestInit=t||{};}return e.prototype.save=function(e){return __awaiter(this,void 0,void 0,function(){var t,n,r,o;return __generator(this,function(a){switch(a.label){case 0:if(e.modelTopology instanceof ArrayBuffer)throw new Error(\"BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.\");return (t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit)).body=new FormData,n=[{paths:[\"./model.weights.bin\"],weights:e.weightSpecs}],r={modelTopology:e.modelTopology,weightsManifest:n},t.body.append(\"model.json\",new Blob([JSON.stringify(r)],{type:\"application/json\"}),\"model.json\"),null!=e.weightData&&t.body.append(\"model.weights.bin\",new Blob([e.weightData],{type:\"application/octet-stream\"}),\"model.weights.bin\"),[4,this.getFetchFunc()(this.path,t)];case 1:if((o=a.sent()).ok)return [2,{modelArtifactsInfo:getModelArtifactsInfoForJSON(e),responses:[o]}];throw new Error(\"BrowserHTTPRequest.save() failed due to HTTP response status \"+o.status+\".\")}})})},e.prototype.load=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return [2,Array.isArray(this.path)?this.loadBinaryModel():this.loadJSONModel()]})})},e.prototype.loadBinaryTopology=function(){return __awaiter(this,void 0,void 0,function(){var e,t;return __generator(this,function(n){switch(n.label){case 0:return n.trys.push([0,3,,4]),[4,this.getFetchFunc()(this.path[0],this.requestInit)];case 1:if(!(e=n.sent()).ok)throw new Error(\"BrowserHTTPRequest.load() failed due to HTTP response: \"+e.statusText);return [4,e.arrayBuffer()];case 2:return [2,n.sent()];case 3:throw t=n.sent(),new Error(this.path[0]+\" not found. \"+t);case 4:return [2]}})})},e.prototype.loadBinaryModel=function(){return __awaiter(this,void 0,void 0,function(){var e,t,n,r,o,a,i,s;return __generator(this,function(u){switch(u.label){case 0:return e=this.loadBinaryTopology(),[4,this.getFetchFunc()(this.path[1],this.requestInit)];case 1:if(!(t=u.sent()).ok)throw new Error(\"BrowserHTTPRequest.load() failed due to HTTP response: \"+t.statusText);return [4,Promise.all([e,t])];case 2:return n=u.sent(),r=n[0],[4,n[1].json()];case 3:return null==(o=u.sent())?[3,5]:[4,this.loadWeights(o)];case 4:s=u.sent(),a=s[0],i=s[1],u.label=5;case 5:return [2,{modelTopology:r,weightSpecs:a,weightData:i}]}})})},e.prototype.loadJSONModel=function(){return __awaiter(this,void 0,void 0,function(){var e,t,n,r,o,a,i,s;return __generator(this,function(u){switch(u.label){case 0:return [4,this.getFetchFunc()(this.path,this.requestInit)];case 1:if(!(e=u.sent()).ok)throw new Error(\"BrowserHTTPRequest.load() failed due to HTTP response: \"+e.statusText);return [4,e.json()];case 2:if(t=u.sent(),n=t.modelTopology,r=t.weightsManifest,null==n&&null==r)throw new Error(\"The JSON from HTTP path \"+this.path+\" contains neither model topology or manifest for weights.\");return null==r?[3,4]:(i=t.weightsManifest,[4,this.loadWeights(i)]);case 3:s=u.sent(),o=s[0],a=s[1],u.label=4;case 4:return [2,{modelTopology:n,weightSpecs:o,weightData:a}]}})})},e.prototype.loadWeights=function(e){return __awaiter(this,void 0,void 0,function(){var t,n,r,o,a,i,s,u,l,c,p,d;return __generator(this,function(h){switch(h.label){case 0:for(t=Array.isArray(this.path)?this.path[1]:this.path,n=parseUrl(t),r=n[0],o=n[1],a=this.weightPathPrefix||r,i=[],s=0,u=e;s<u.length;s++)l=u[s],i.push.apply(i,l.weights);return c=[],e.forEach(function(e){e.paths.forEach(function(e){c.push(a+e+o);});}),p=[i],d=concatenateArrayBuffers,[4,loadWeightsAsArrayBuffer(c,this.requestInit,this.getFetchFunc())];case 1:return [2,p.concat([d.apply(void 0,[h.sent()])])]}})})},e.prototype.getFetchFunc=function(){return this.fetchFunc},e.URL_SCHEME_REGEX=/^https?:\\/\\//,e}();function parseUrl(e){var t=e.lastIndexOf(\"/\"),n=e.lastIndexOf(\"?\");return [e.substring(0,t)+\"/\",n>t?e.substring(n):\"\"]}function isHTTPScheme(e){return null!=e.match(BrowserHTTPRequest.URL_SCHEME_REGEX)}var httpRequestRouter=function(e){if(\"undefined\"==typeof fetch)return null;return (Array.isArray(e)?e.every(function(e){return isHTTPScheme(e)}):isHTTPScheme(e))?browserHTTPRequest(e):null};function browserHTTPRequest(e,t,n,r){return new BrowserHTTPRequest(e,t,n,r)}IORouterRegistry.registerSaveRouter(httpRequestRouter),IORouterRegistry.registerLoadRouter(httpRequestRouter);var PassthroughLoader=function(){function e(e,t,n){this.modelTopology=e,this.weightSpecs=t,this.weightData=n;}return e.prototype.load=function(){return __awaiter(this,void 0,void 0,function(){var e;return __generator(this,function(t){return e={},null!=this.modelTopology&&(e=__assign({modelTopology:this.modelTopology},e)),null!=this.weightSpecs&&this.weightSpecs.length>0&&(e=__assign({weightSpecs:this.weightSpecs},e)),null!=this.weightData&&this.weightData.byteLength>0&&(e=__assign({weightData:this.weightData},e)),[2,e]})})},e}(),PassthroughSaver=function(){function e(e){this.saveHandler=e;}return e.prototype.save=function(e){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){return [2,this.saveHandler(e)]})})},e}();function fromMemory(e,t,n){return new PassthroughLoader(e,t,n)}function withSaveHandler(e){return new PassthroughSaver(e)}var registerSaveRouter=IORouterRegistry.registerSaveRouter,registerLoadRouter=IORouterRegistry.registerLoadRouter,getSaveHandlers=IORouterRegistry.getSaveHandlers,getLoadHandlers=IORouterRegistry.getLoadHandlers,io=Object.freeze({browserFiles:browserFiles,browserHTTPRequest:browserHTTPRequest,concatenateArrayBuffers:concatenateArrayBuffers,decodeWeights:decodeWeights,encodeWeights:encodeWeights,fromMemory:fromMemory,getLoadHandlers:getLoadHandlers,getModelArtifactsInfoForJSON:getModelArtifactsInfoForJSON,getSaveHandlers:getSaveHandlers,isHTTPScheme:isHTTPScheme,loadWeights:loadWeights,registerLoadRouter:registerLoadRouter,registerSaveRouter:registerSaveRouter,weightsLoaderFactory:weightsLoaderFactory,withSaveHandler:withSaveHandler,copyModel:copyModel,listModels:listModels,moveModel:moveModel,removeModel:removeModel});function confusionMatrix_(e,t,n){var r=convertToTensor(e,\"labels\",\"confusionMatrix\"),o=convertToTensor(t,\"predictions\",\"confusionMatrix\");assert(null==n||n>0&&Number.isInteger(n),\"If provided, numClasses must be a positive integer, but got \"+n),assert(1===r.rank,\"Expected the rank of labels to be 1, but got \"+r.rank),assert(1===o.rank,\"Expected the rank of predictions to be 1, but got \"+o.rank),assert(r.shape[0]===o.shape[0],\"Mismatch in the number of examples: \"+r.shape[0]+\" vs. \"+o.shape[0]+\". Labels and predictions should have the same number of elements.\"),assert(n>0&&Number.isInteger(n),\"numClasses is required to be a positive integer, but got \"+n);var a=oneHot(r.asType(\"int32\"),n),i=oneHot(o.asType(\"int32\"),n);return a.transpose().matMul(i).asType(\"int32\")}var confusionMatrix=op({confusionMatrix_:confusionMatrix_}),math=Object.freeze({confusionMatrix:confusionMatrix}),Serializable=function(){function e(){}return e.prototype.getClassName=function(){return this.constructor.className},e.fromConfig=function(e,t){return new e(t)},e}(),SerializationMap=function(){function e(){this.classNameMap={};}return e.getMap=function(){return null==e.instance&&(e.instance=new e),e.instance},e.register=function(t){e.getMap().classNameMap[t.className]=[t,t.fromConfig];},e}();function registerClass(e){assert(null!=e.className,\"Class being registered does not have the static className property defined.\"),assert(\"string\"==typeof e.className,\"className is required to be a string, but got type \"+typeof e.className),assert(e.className.length>0,\"Class being registered has an empty-string as its className, which is disallowed.\"),SerializationMap.register(e);}var serialization=Object.freeze({Serializable:Serializable,SerializationMap:SerializationMap,registerClass:registerClass}),WEBGL_ENVS={HAS_WEBGL:!0},NODE_ENVS={IS_NODE:!0},CHROME_ENVS={IS_CHROME:!0},BROWSER_ENVS={IS_BROWSER:!0},CPU_ENVS={HAS_WEBGL:!1},ALL_ENVS={};function expectArraysClose(e,t,n){return null==n&&(n=ENV.get(\"TEST_EPSILON\")),expectArraysPredicate(e,t,function(e,t){return areClose(e,Number(t),n)})}function expectArraysPredicate(e,t,n){if(e instanceof Tensor||t instanceof Tensor){if(e instanceof Tensor&&t instanceof Tensor){if(e.dtype!==t.dtype)throw new Error(\"Arrays are of different type actual: \"+e.dtype+\" vs expected: \"+t.dtype+\".\");if(!arraysEqual(e.shape,t.shape))throw new Error(\"Arrays are of different shape actual: \"+e.shape+\" vs expected: \"+t.shape+\".\")}}else{var r=e.constructor.name,o=t.constructor.name;if(r!==o)throw new Error(\"Arrays are of different type actual: \"+r+\" vs expected: \"+o)}var a,i;if(a=e instanceof Tensor?e.dataSync():e,i=t instanceof Tensor?t.dataSync():t,a.length!==i.length)throw new Error(\"Arrays have different lengths actual: \"+a.length+\" vs expected: \"+i.length+\".\\nActual:   \"+a+\".\\nExpected: \"+i+\".\");for(var s=0;s<i.length;++s){var u=a[s],l=i[s];if(!n(u,l))throw new Error(\"Arrays differ: actual[\"+s+\"] = \"+u+\", expected[\"+s+\"] = \"+l+\".\\nActual:   \"+a+\".\\nExpected: \"+i+\".\")}}function expectPromiseToFail(e,t){e().then(function(){return t.fail()},function(){return t()});}function expectArraysEqual(e,t){return e instanceof Tensor&&\"string\"===e.dtype||t instanceof Tensor&&\"string\"===t.dtype||e instanceof Array&&isString(e[0])||t instanceof Array&&isString(t[0])?expectArraysPredicate(e,t,function(e,t){return e==t}):expectArraysClose(e,t,0)}function expectNumbersClose(e,t,n){if(null==n&&(n=ENV.get(\"TEST_EPSILON\")),!areClose(e,t,n))throw new Error(\"Numbers differ: actual === \"+e+\", expected === \"+t)}function areClose(e,t,n){return !(!isNaN(e)||!isNaN(t))||!(isNaN(e)||isNaN(t)||Math.abs(e-t)>n)}function expectValuesInRange(e,t,n){var r;r=e instanceof Tensor?e.dataSync():e;for(var o=0;o<r.length;o++)if(r[o]<t||r[o]>n)throw new Error(\"Value out of range:\"+r[o]+\" low: \"+t+\", high: \"+n)}function expectArrayBuffersEqual(e,t){expect(new Float32Array(e)).toEqual(new Float32Array(t));}var test_util=Object.freeze({WEBGL_ENVS:WEBGL_ENVS,NODE_ENVS:NODE_ENVS,CHROME_ENVS:CHROME_ENVS,BROWSER_ENVS:BROWSER_ENVS,CPU_ENVS:CPU_ENVS,ALL_ENVS:ALL_ENVS,expectArraysClose:expectArraysClose,expectPromiseToFail:expectPromiseToFail,expectArraysEqual:expectArraysEqual,expectNumbersClose:expectNumbersClose,expectValuesInRange:expectValuesInRange,expectArrayBuffersEqual:expectArrayBuffersEqual}),version=\"0.14.2\",webgl=Object.freeze({gpgpu_util:gpgpu_util,webgl_util:webgl_util,MathBackendWebGL:MathBackendWebGL,GPGPUContext:GPGPUContext}),Optimizer=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.minimize=function(e,t,n){void 0===t&&(t=!1);var r=this.computeGradients(e,n),o=r.value,a=r.grads;return this.applyGradients(a),Object.keys(a).forEach(function(e){return a[e].dispose()}),t?o:(o.dispose(),null)},t.prototype.computeGradients=function(e,t){return variableGrads(e,t)},t}(Serializable),AdadeltaOptimizer=function(e){function t(t,n,r){void 0===r&&(r=null);var o=e.call(this)||this;return o.learningRate=t,o.rho=n,o.epsilon=r,o.accumulatedGrads={},o.accumulatedUpdates={},o.c=keep(scalar(-t)),o.rhoScalar=keep(scalar(n)),o.oneMinusRho=keep(scalar(1-n)),null===r&&(r=ENV.get(\"EPSILON\")),o.epsilonScalar=keep(scalar(r)),o}return __extends(t,e),t.prototype.applyGradients=function(e){var t=this,n=function(n){var o=ENV.engine.registeredVariables[n];if(null==r.accumulatedGrads[n]){tidy(function(){t.accumulatedGrads[n]=zerosLike(o).variable(!1);});}if(null==r.accumulatedUpdates[n]){tidy(function(){t.accumulatedUpdates[n]=zerosLike(o).variable(!1);});}var a=e[n],i=r.accumulatedGrads[n],s=r.accumulatedUpdates[n];tidy(function(){var e=t.rhoScalar.mul(i).add(t.oneMinusRho.mul(a.square())),r=s.add(t.epsilonScalar).sqrt().div(i.add(t.epsilonScalar).sqrt()).mul(a),u=t.rhoScalar.mul(s).add(t.oneMinusRho.mul(r.square()));t.accumulatedGrads[n].assign(e),t.accumulatedUpdates[n].assign(u);var l=t.c.mul(r).add(o);o.assign(l);});},r=this;for(var o in e)n(o);},t.prototype.dispose=function(){var e=this;this.c.dispose(),this.epsilonScalar.dispose(),this.rhoScalar.dispose(),this.oneMinusRho.dispose(),null!=this.accumulatedUpdates&&(Object.keys(this.accumulatedUpdates).forEach(function(t){return e.accumulatedUpdates[t].dispose()}),Object.keys(this.accumulatedGrads).forEach(function(t){return e.accumulatedGrads[t].dispose()}));},t.prototype.getConfig=function(){return {learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}},t.fromConfig=function(e,t){return new e(t.learningRate,t.rho,t.epsilon)},t.className=\"AdadeltaOptimizer\",t}(Optimizer);registerClass(AdadeltaOptimizer);var AdagradOptimizer=function(e){function t(t,n){void 0===n&&(n=.1);var r=e.call(this)||this;return r.learningRate=t,r.initialAccumulatorValue=n,r.accumulatedGrads={},r.c=keep(scalar(-t)),r.epsilon=keep(scalar(ENV.get(\"EPSILON\"))),r}return __extends(t,e),t.prototype.applyGradients=function(e){var t=this,n=function(n){var o=ENV.engine.registeredVariables[n];if(null==r.accumulatedGrads[n]){tidy(function(){t.accumulatedGrads[n]=fill(o.shape,t.initialAccumulatorValue).variable(!1);});}var a=e[n],i=r.accumulatedGrads[n];tidy(function(){var e=i.add(a.square());t.accumulatedGrads[n].assign(e);var r=t.c.mul(a.div(e.add(t.epsilon).sqrt())).add(o);o.assign(r);});},r=this;for(var o in e)n(o);},t.prototype.dispose=function(){var e=this;this.epsilon.dispose(),this.c.dispose(),null!=this.accumulatedGrads&&Object.keys(this.accumulatedGrads).forEach(function(t){return e.accumulatedGrads[t].dispose()});},t.prototype.getConfig=function(){return {learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}},t.fromConfig=function(e,t){return new e(t.learningRate,t.initialAccumulatorValue)},t.className=\"AdagradOptimizer\",t}(Optimizer);registerClass(AdagradOptimizer);var AdamOptimizer=function(e){function t(t,n,r,o){void 0===o&&(o=null);var a=e.call(this)||this;return a.learningRate=t,a.beta1=n,a.beta2=r,a.epsilon=o,a.accumulatedFirstMoment={},a.accumulatedSecondMoment={},a.c=keep(scalar(-t)),a.beta1Scalar=keep(scalar(n)),a.beta2Scalar=keep(scalar(r)),tidy(function(){a.accBeta1=scalar(n).variable(),a.accBeta2=scalar(r).variable();}),a.oneMinusBeta1=keep(scalar(1-n)),a.oneMinusBeta2=keep(scalar(1-r)),a.one=keep(scalar(1)),null===o&&(o=ENV.get(\"EPSILON\")),a.epsScalar=keep(scalar(o)),a}return __extends(t,e),t.prototype.applyGradients=function(e){var t=this;tidy(function(){var n=t.one.sub(t.accBeta1),r=t.one.sub(t.accBeta2);for(var o in e){var a=ENV.engine.registeredVariables[o];if(null==t.accumulatedFirstMoment[o]){var i=!1;t.accumulatedFirstMoment[o]=zerosLike(a).variable(i);}if(null==t.accumulatedSecondMoment[o]){i=!1;t.accumulatedSecondMoment[o]=zerosLike(a).variable(i);}var s=e[o],u=t.accumulatedFirstMoment[o],l=t.accumulatedSecondMoment[o],c=t.beta1Scalar.mul(u).add(t.oneMinusBeta1.mul(s)),p=t.beta2Scalar.mul(l).add(t.oneMinusBeta2.mul(s.square())),d=c.div(n),h=p.div(r);t.accumulatedFirstMoment[o].assign(c),t.accumulatedSecondMoment[o].assign(p);var f=t.c.mul(d.div(t.epsScalar.add(h.sqrt()))).add(a);a.assign(f);}t.accBeta1.assign(t.accBeta1.mul(t.beta1Scalar)),t.accBeta2.assign(t.accBeta2.mul(t.beta2Scalar));});},t.prototype.dispose=function(){var e=this;this.c.dispose(),this.epsScalar.dispose(),this.beta1Scalar.dispose(),this.beta2Scalar.dispose(),this.accBeta1.dispose(),this.accBeta2.dispose(),this.oneMinusBeta1.dispose(),this.oneMinusBeta2.dispose(),this.one.dispose(),null!=this.accumulatedFirstMoment&&Object.keys(this.accumulatedFirstMoment).forEach(function(t){return e.accumulatedFirstMoment[t].dispose()}),null!=this.accumulatedSecondMoment&&Object.keys(this.accumulatedSecondMoment).forEach(function(t){return e.accumulatedSecondMoment[t].dispose()});},t.prototype.getConfig=function(){return {learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}},t.fromConfig=function(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)},t.className=\"AdamOptimizer\",t}(Optimizer);registerClass(AdamOptimizer);var AdamaxOptimizer=function(e){function t(t,n,r,o,a){void 0===o&&(o=null),void 0===a&&(a=0);var i=e.call(this)||this;return i.learningRate=t,i.beta1=n,i.beta2=r,i.epsilon=o,i.decay=a,i.accumulatedFirstMoment={},i.accumulatedWeightedInfNorm={},i.c=keep(scalar(-t)),i.beta1Scalar=keep(scalar(n)),i.beta2Scalar=keep(scalar(r)),i.decayScalar=keep(scalar(a)),tidy(function(){i.iteration=scalar(0).variable(),i.accBeta1=scalar(n).variable();}),i.oneMinusBeta1=keep(scalar(1-n)),i.one=keep(scalar(1)),null===o&&(o=ENV.get(\"EPSILON\")),i.epsScalar=keep(scalar(o)),i}return __extends(t,e),t.prototype.applyGradients=function(e){var t=this;tidy(function(){var n=t.one.sub(t.accBeta1),r=t.c.div(t.one.add(t.decayScalar.mul(t.iteration)));for(var o in e){var a=ENV.engine.registeredVariables[o];if(null==t.accumulatedFirstMoment[o]){var i=!1;t.accumulatedFirstMoment[o]=zerosLike(a).variable(i);}if(null==t.accumulatedWeightedInfNorm[o]){i=!1;t.accumulatedWeightedInfNorm[o]=zerosLike(a).variable(i);}var s=e[o],u=t.accumulatedFirstMoment[o],l=t.accumulatedWeightedInfNorm[o],c=t.beta1Scalar.mul(u).add(t.oneMinusBeta1.mul(s)),p=t.beta2Scalar.mul(l),d=s.abs(),h=p.maximum(d);t.accumulatedFirstMoment[o].assign(c),t.accumulatedWeightedInfNorm[o].assign(h);var f=r.div(n).mul(c.div(t.epsScalar.add(h))).add(a);a.assign(f);}t.iteration.assign(t.iteration.add(t.one)),t.accBeta1.assign(t.accBeta1.mul(t.beta1Scalar));});},t.prototype.dispose=function(){var e=this;this.c.dispose(),this.epsScalar.dispose(),this.accBeta1.dispose(),this.beta1Scalar.dispose(),this.beta2Scalar.dispose(),this.oneMinusBeta1.dispose(),this.decayScalar.dispose(),this.iteration.dispose(),this.one.dispose(),null!=this.accumulatedFirstMoment&&Object.keys(this.accumulatedFirstMoment).forEach(function(t){return e.accumulatedFirstMoment[t].dispose()}),null!=this.accumulatedWeightedInfNorm&&Object.keys(this.accumulatedWeightedInfNorm).forEach(function(t){return e.accumulatedWeightedInfNorm[t].dispose()});},t.prototype.getConfig=function(){return {learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}},t.fromConfig=function(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)},t.className=\"AdamaxOptimizer\",t}(Optimizer);registerClass(AdamaxOptimizer);var SGDOptimizer=function(e){function t(t){var n=e.call(this)||this;return n.learningRate=t,n.setLearningRate(t),n}return __extends(t,e),t.prototype.applyGradients=function(e){var t=this;Object.keys(e).forEach(function(n){var r=e[n],o=ENV.engine.registeredVariables[n];tidy(function(){var e=t.c.mul(r).add(o);o.assign(e);});});},t.prototype.setLearningRate=function(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=keep(scalar(-e));},t.prototype.dispose=function(){this.c.dispose();},t.prototype.getConfig=function(){return {learningRate:this.learningRate}},t.fromConfig=function(e,t){return new e(t.learningRate)},t.className=\"SGDOptimizer\",t}(Optimizer);registerClass(SGDOptimizer);var MomentumOptimizer=function(e){function t(t,n,r){void 0===r&&(r=!1);var o=e.call(this,t)||this;return o.learningRate=t,o.momentum=n,o.useNesterov=r,o.m=scalar(o.momentum),o.accumulations={},o}return __extends(t,e),t.prototype.applyGradients=function(e){var t=this,n=function(n){var o=ENV.engine.registeredVariables[n];if(null==r.accumulations[n]){tidy(function(){t.accumulations[n]=zerosLike(o).variable(!1);});}var a=r.accumulations[n],i=e[n];tidy(function(){var e,r=t.m.mul(a).add(i);e=t.useNesterov?t.c.mul(i.add(r.mul(t.m))).add(o):t.c.mul(r).add(o),t.accumulations[n].assign(r),o.assign(e);});},r=this;for(var o in e)n(o);},t.prototype.dispose=function(){if(e.prototype.dispose.call(this),this.m.dispose(),null!=this.accumulations)for(var t in this.accumulations)this.accumulations[t].dispose();},t.prototype.setMomentum=function(e){this.momentum=e;},t.prototype.getConfig=function(){return {learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}},t.fromConfig=function(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)},t.className=\"MomentumOptimizer\",t}(SGDOptimizer);registerClass(MomentumOptimizer);var RMSPropOptimizer=function(e){function t(t,n,r,o,a){void 0===n&&(n=.9),void 0===r&&(r=0),void 0===o&&(o=null),void 0===a&&(a=!1);var i=e.call(this)||this;return i.learningRate=t,i.decay=n,i.momentum=r,i.epsilon=o,i.accumulatedMeanSquares={},i.accumulatedMeanGrads={},i.accumulatedMoments={},i.c=keep(scalar(t)),i.decayScalar=keep(scalar(n)),i.momentumScalar=keep(scalar(r)),i.oneMinusDecay=keep(scalar(1-n)),i.centered=a,null===o&&(o=ENV.get(\"EPSILON\")),i.epsilonScalar=keep(scalar(o)),i}return __extends(t,e),t.prototype.applyGradients=function(e){var t=this,n=function(n){var o=ENV.engine.registeredVariables[n];if(null==r.accumulatedMeanSquares[n]){tidy(function(){t.accumulatedMeanSquares[n]=zerosLike(o).variable(!1);});}if(null==r.accumulatedMeanGrads[n]&&r.centered){tidy(function(){t.accumulatedMeanGrads[n]=zerosLike(o).variable(!1);});}if(null==r.accumulatedMoments[n]){tidy(function(){t.accumulatedMoments[n]=zerosLike(o).variable(!1);});}var a=r.accumulatedMeanSquares[n],i=r.accumulatedMeanGrads[n],s=r.accumulatedMoments[n],u=e[n];tidy(function(){var e=t.decayScalar.mul(a).add(t.oneMinusDecay.mul(u.square()));if(t.centered){var r=t.decayScalar.mul(i).add(t.oneMinusDecay.mul(u)),l=t.momentumScalar.mul(s).add(t.c.mul(u).div(e.sub(r.square().add(t.epsilonScalar)).sqrt()));t.accumulatedMeanSquares[n].assign(e),t.accumulatedMeanGrads[n].assign(r),t.accumulatedMoments[n].assign(l);var c=o.sub(l);o.assign(c);}else{var p=t.decayScalar.mul(a).add(t.oneMinusDecay.mul(u.square()));l=t.momentumScalar.mul(s).add(t.c.mul(u).div(p.add(t.epsilonScalar).sqrt()));t.accumulatedMeanSquares[n].assign(p),t.accumulatedMoments[n].assign(l);c=o.sub(l);o.assign(c);}});},r=this;for(var o in e)n(o);},t.prototype.dispose=function(){var e=this;this.c.dispose(),this.epsilonScalar.dispose(),this.decayScalar.dispose(),this.momentumScalar.dispose(),this.oneMinusDecay.dispose(),null!=this.accumulatedMeanSquares&&Object.keys(this.accumulatedMeanSquares).forEach(function(t){return e.accumulatedMeanSquares[t].dispose()}),null!=this.accumulatedMeanGrads&&this.centered&&Object.keys(this.accumulatedMeanGrads).forEach(function(t){return e.accumulatedMeanGrads[t].dispose()}),null!=this.accumulatedMoments&&Object.keys(this.accumulatedMoments).forEach(function(t){return e.accumulatedMoments[t].dispose()});},t.prototype.getConfig=function(){return {learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}},t.fromConfig=function(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)},t.className=\"RMSPropOptimizer\",t}(Optimizer);registerClass(RMSPropOptimizer);var OptimizerConstructors=function(){function e(){}return e.sgd=function(e){return new SGDOptimizer(e)},e.momentum=function(e,t,n){return void 0===n&&(n=!1),new MomentumOptimizer(e,t,n)},e.rmsprop=function(e,t,n,r,o){return void 0===t&&(t=.9),void 0===n&&(n=0),void 0===r&&(r=null),void 0===o&&(o=!1),new RMSPropOptimizer(e,t,n,r,o)},e.adam=function(e,t,n,r){return void 0===e&&(e=.001),void 0===t&&(t=.9),void 0===n&&(n=.999),void 0===r&&(r=null),new AdamOptimizer(e,t,n,r)},e.adadelta=function(e,t,n){return void 0===e&&(e=.001),void 0===t&&(t=.95),void 0===n&&(n=null),new AdadeltaOptimizer(e,t,n)},e.adamax=function(e,t,n,r,o){return void 0===e&&(e=.002),void 0===t&&(t=.9),void 0===n&&(n=.999),void 0===r&&(r=null),void 0===o&&(o=0),new AdamaxOptimizer(e,t,n,r,o)},e.adagrad=function(e,t){return void 0===t&&(t=.1),new AdagradOptimizer(e,t)},e}(),train={sgd:OptimizerConstructors.sgd,momentum:OptimizerConstructors.momentum,adadelta:OptimizerConstructors.adadelta,adagrad:OptimizerConstructors.adagrad,rmsprop:OptimizerConstructors.rmsprop,adamax:OptimizerConstructors.adamax,adam:OptimizerConstructors.adam},setBackend=Environment.setBackend,getBackend=Environment.getBackend,disposeVariables=Environment.disposeVariables,memory=Environment.memory;setOpHandler(ops);\n\n    var tfCore_esm = /*#__PURE__*/Object.freeze({\n        setBackend: setBackend,\n        getBackend: getBackend,\n        disposeVariables: disposeVariables,\n        memory: memory,\n        version_core: version,\n        nextFrame: nextFrame,\n        environment: environment,\n        io: io,\n        math: math,\n        serialization: serialization,\n        test_util: test_util,\n        util: util,\n        webgl: webgl,\n        AdadeltaOptimizer: AdadeltaOptimizer,\n        AdagradOptimizer: AdagradOptimizer,\n        AdamOptimizer: AdamOptimizer,\n        AdamaxOptimizer: AdamaxOptimizer,\n        MomentumOptimizer: MomentumOptimizer,\n        Optimizer: Optimizer,\n        RMSPropOptimizer: RMSPropOptimizer,\n        SGDOptimizer: SGDOptimizer,\n        Tensor: Tensor,\n        TensorBuffer: TensorBuffer,\n        variable: variable,\n        Variable: Variable,\n        get Rank () { return Rank; },\n        get Reduction () { return Reduction; },\n        ENV: ENV,\n        Environment: Environment,\n        KernelBackend: KernelBackend,\n        DataStorage: DataStorage,\n        image: image_ops,\n        linalg: linalg_ops,\n        losses: loss_ops,\n        spectral: spectral_ops,\n        op: op,\n        batchNormalization2d: batchNormalization2d,\n        batchNormalization3d: batchNormalization3d,\n        batchNormalization4d: batchNormalization4d,\n        batchNormalization: batchNormalization,\n        complex: complex,\n        real: real,\n        imag: imag,\n        concat: concat,\n        concat1d: concat1d,\n        concat2d: concat2d,\n        concat3d: concat3d,\n        concat4d: concat4d,\n        split: split$1,\n        conv1d: conv1d,\n        conv2d: conv2d,\n        conv3d: conv3d,\n        conv2dDerFilter: conv2dDerFilter,\n        depthwiseConv2d: depthwiseConv2d,\n        separableConv2d: separableConv2d,\n        conv2dTranspose: conv2dTranspose,\n        matMul: matMul,\n        dot: dot,\n        outerProduct: outerProduct,\n        reverse: reverse,\n        reverse1d: reverse1d,\n        reverse2d: reverse2d,\n        reverse3d: reverse3d,\n        reverse4d: reverse4d,\n        maxPool: maxPool,\n        avgPool: avgPool,\n        pool: pool,\n        slice: slice,\n        slice1d: slice1d,\n        slice2d: slice2d,\n        slice3d: slice3d,\n        slice4d: slice4d,\n        abs: abs,\n        acos: acos,\n        acosh: acosh,\n        asin: asin,\n        asinh: asinh,\n        atan: atan,\n        atanh: atanh,\n        ceil: ceil,\n        clipByValue: clipByValue,\n        cos: cos,\n        cosh: cosh,\n        erf: erf,\n        exp: exp,\n        expm1: expm1,\n        floor: floor,\n        log: log$1,\n        log1p: log1p,\n        logSigmoid: logSigmoid,\n        neg: neg,\n        reciprocal: reciprocal,\n        round: round,\n        rsqrt: rsqrt,\n        sigmoid: sigmoid,\n        sign: sign,\n        sin: sin,\n        sinh: sinh,\n        softplus: softplus,\n        sqrt: sqrt,\n        square: square,\n        step: step,\n        tan: tan,\n        tanh: tanh$1,\n        all: all,\n        any: any,\n        argMax: argMax,\n        argMin: argMin,\n        logSumExp: logSumExp,\n        max: max,\n        mean: mean,\n        min: min,\n        moments: moments,\n        sum: sum$1,\n        prod: prod,\n        equal: equal,\n        equalStrict: equalStrict,\n        greater: greater,\n        greaterEqual: greaterEqual,\n        greaterEqualStrict: greaterEqualStrict,\n        greaterStrict: greaterStrict,\n        less: less,\n        lessEqual: lessEqual,\n        lessEqualStrict: lessEqualStrict,\n        lessStrict: lessStrict,\n        notEqual: notEqual,\n        notEqualStrict: notEqualStrict,\n        add: add,\n        addN: addN,\n        addStrict: addStrict,\n        atan2: atan2,\n        div: div,\n        divStrict: divStrict,\n        floorDiv: floorDiv,\n        maximum: maximum,\n        maximumStrict: maximumStrict,\n        minimum: minimum,\n        minimumStrict: minimumStrict,\n        mod: mod,\n        modStrict: modStrict,\n        mul: mul,\n        mulStrict: mulStrict,\n        pow: pow,\n        powStrict: powStrict,\n        squaredDifference: squaredDifference,\n        squaredDifferenceStrict: squaredDifferenceStrict,\n        sub: sub,\n        subStrict: subStrict,\n        elu: elu,\n        leakyRelu: leakyRelu,\n        prelu: prelu,\n        relu: relu,\n        selu: selu,\n        logicalAnd: logicalAnd,\n        logicalNot: logicalNot,\n        logicalOr: logicalOr,\n        logicalXor: logicalXor,\n        where: where,\n        whereAsync: whereAsync,\n        buffer: buffer,\n        toPixels: toPixels,\n        print: print,\n        batchToSpaceND: batchToSpaceND,\n        cast: cast,\n        clone: clone,\n        cumsum: cumsum,\n        depthToSpace: depthToSpace,\n        expandDims: expandDims,\n        eye: eye,\n        fromPixels: fromPixels,\n        multinomial: multinomial,\n        oneHot: oneHot,\n        pad: pad,\n        pad1d: pad1d,\n        pad2d: pad2d,\n        pad3d: pad3d,\n        pad4d: pad4d,\n        rand: rand,\n        randomNormal: randomNormal,\n        randomUniform: randomUniform,\n        reshape: reshape,\n        spaceToBatchND: spaceToBatchND,\n        squeeze: squeeze,\n        stack: stack,\n        tile: tile,\n        truncatedNormal: truncatedNormal,\n        unstack: unstack,\n        setdiff1dAsync: setdiff1dAsync,\n        fill: fill,\n        linspace: linspace,\n        ones: ones$1,\n        range: range,\n        scalar: scalar,\n        tensor: tensor,\n        tensor1d: tensor1d,\n        tensor2d: tensor2d,\n        tensor3d: tensor3d,\n        tensor4d: tensor4d,\n        tensor5d: tensor5d,\n        tensor6d: tensor6d,\n        zeros: zeros,\n        onesLike: onesLike,\n        zerosLike: zerosLike,\n        transpose: transpose,\n        softmax: softmax,\n        logSoftmax: logSoftmax,\n        localResponseNormalization: localResponseNormalization,\n        norm: norm,\n        gather: gather,\n        unsortedSegmentSum: unsortedSegmentSum,\n        basicLSTMCell: basicLSTMCell,\n        multiRNNCell: multiRNNCell,\n        movingAverage: movingAverage,\n        stridedSlice: stridedSlice,\n        topk: topk,\n        scatterND: scatterND,\n        fft: fft,\n        ifft: ifft,\n        rfft: rfft,\n        irfft: irfft,\n        sparseToDense: sparseToDense,\n        gatherND: gatherND,\n        train: train,\n        tidy: tidy,\n        keep: keep,\n        dispose: dispose,\n        time: time,\n        profile: profile,\n        customGrad: customGrad,\n        grad: grad,\n        grads: grads,\n        valueAndGrad: valueAndGrad,\n        valueAndGrads: valueAndGrads,\n        variableGrads: variableGrads\n    });\n\n    function convLayer(x, params, padding, withRelu) {\n        if (padding === void 0) { padding = 'same'; }\n        if (withRelu === void 0) { withRelu = false; }\n        return tidy(function () {\n            var out = add(conv2d(x, params.filters, [1, 1], padding), params.bias);\n            return withRelu ? relu(out) : out;\n        });\n    }\n\n    function disposeUnusedWeightTensors(weightMap, paramMappings) {\n        Object.keys(weightMap).forEach(function (path) {\n            if (!paramMappings.some(function (pm) { return pm.originalPath === path; })) {\n                weightMap[path].dispose();\n            }\n        });\n    }\n\n    function extractConvParamsFactory(extractWeights, paramMappings) {\n        return function (channelsIn, channelsOut, filterSize, mappedPrefix) {\n            var filters = tensor4d(extractWeights(channelsIn * channelsOut * filterSize * filterSize), [filterSize, filterSize, channelsIn, channelsOut]);\n            var bias = tensor1d(extractWeights(channelsOut));\n            paramMappings.push({ paramPath: mappedPrefix + \"/filters\" }, { paramPath: mappedPrefix + \"/bias\" });\n            return { filters: filters, bias: bias };\n        };\n    }\n\n    function extractFCParamsFactory(extractWeights, paramMappings) {\n        return function (channelsIn, channelsOut, mappedPrefix) {\n            var fc_weights = tensor2d(extractWeights(channelsIn * channelsOut), [channelsIn, channelsOut]);\n            var fc_bias = tensor1d(extractWeights(channelsOut));\n            paramMappings.push({ paramPath: mappedPrefix + \"/weights\" }, { paramPath: mappedPrefix + \"/bias\" });\n            return {\n                weights: fc_weights,\n                bias: fc_bias\n            };\n        };\n    }\n\n    var SeparableConvParams = /** @class */ (function () {\n        function SeparableConvParams(depthwise_filter, pointwise_filter, bias) {\n            this.depthwise_filter = depthwise_filter;\n            this.pointwise_filter = pointwise_filter;\n            this.bias = bias;\n        }\n        return SeparableConvParams;\n    }());\n\n    function extractSeparableConvParamsFactory(extractWeights, paramMappings) {\n        return function (channelsIn, channelsOut, mappedPrefix) {\n            var depthwise_filter = tensor4d(extractWeights(3 * 3 * channelsIn), [3, 3, channelsIn, 1]);\n            var pointwise_filter = tensor4d(extractWeights(channelsIn * channelsOut), [1, 1, channelsIn, channelsOut]);\n            var bias = tensor1d(extractWeights(channelsOut));\n            paramMappings.push({ paramPath: mappedPrefix + \"/depthwise_filter\" }, { paramPath: mappedPrefix + \"/pointwise_filter\" }, { paramPath: mappedPrefix + \"/bias\" });\n            return new SeparableConvParams(depthwise_filter, pointwise_filter, bias);\n        };\n    }\n    function loadSeparableConvParamsFactory(extractWeightEntry) {\n        return function (prefix) {\n            var depthwise_filter = extractWeightEntry(prefix + \"/depthwise_filter\", 4);\n            var pointwise_filter = extractWeightEntry(prefix + \"/pointwise_filter\", 4);\n            var bias = extractWeightEntry(prefix + \"/bias\", 1);\n            return new SeparableConvParams(depthwise_filter, pointwise_filter, bias);\n        };\n    }\n\n    var Dimensions = /** @class */ (function () {\n        function Dimensions(width, height) {\n            if (!isValidNumber(width) || !isValidNumber(height)) {\n                throw new Error(\"Dimensions.constructor - expected width and height to be valid numbers, instead have \" + JSON.stringify({ width: width, height: height }));\n            }\n            this._width = width;\n            this._height = height;\n        }\n        Object.defineProperty(Dimensions.prototype, \"width\", {\n            get: function () { return this._width; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Dimensions.prototype, \"height\", {\n            get: function () { return this._height; },\n            enumerable: true,\n            configurable: true\n        });\n        Dimensions.prototype.reverse = function () {\n            return new Dimensions(1 / this.width, 1 / this.height);\n        };\n        return Dimensions;\n    }());\n\n    var Point = /** @class */ (function () {\n        function Point(x, y) {\n            this._x = x;\n            this._y = y;\n        }\n        Object.defineProperty(Point.prototype, \"x\", {\n            get: function () { return this._x; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Point.prototype, \"y\", {\n            get: function () { return this._y; },\n            enumerable: true,\n            configurable: true\n        });\n        Point.prototype.add = function (pt) {\n            return new Point(this.x + pt.x, this.y + pt.y);\n        };\n        Point.prototype.sub = function (pt) {\n            return new Point(this.x - pt.x, this.y - pt.y);\n        };\n        Point.prototype.mul = function (pt) {\n            return new Point(this.x * pt.x, this.y * pt.y);\n        };\n        Point.prototype.div = function (pt) {\n            return new Point(this.x / pt.x, this.y / pt.y);\n        };\n        Point.prototype.abs = function () {\n            return new Point(Math.abs(this.x), Math.abs(this.y));\n        };\n        Point.prototype.magnitude = function () {\n            return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2));\n        };\n        Point.prototype.floor = function () {\n            return new Point(Math.floor(this.x), Math.floor(this.y));\n        };\n        return Point;\n    }());\n\n    function isTensor(tensor$$1, dim) {\n        return tensor$$1 instanceof Tensor && tensor$$1.shape.length === dim;\n    }\n    function isTensor1D(tensor$$1) {\n        return isTensor(tensor$$1, 1);\n    }\n    function isTensor2D(tensor$$1) {\n        return isTensor(tensor$$1, 2);\n    }\n    function isTensor3D(tensor$$1) {\n        return isTensor(tensor$$1, 3);\n    }\n    function isTensor4D(tensor$$1) {\n        return isTensor(tensor$$1, 4);\n    }\n    function isFloat(num) {\n        return num % 1 !== 0;\n    }\n    function isEven$1(num) {\n        return num % 2 === 0;\n    }\n    function round$1(num, prec) {\n        if (prec === void 0) { prec = 2; }\n        var f = Math.pow(10, prec);\n        return Math.floor(num * f) / f;\n    }\n    function isDimensions(obj) {\n        return obj && obj.width && obj.height;\n    }\n    function computeReshapedDimensions(_a, inputSize) {\n        var width = _a.width, height = _a.height;\n        var scale = inputSize / Math.max(height, width);\n        return new Dimensions(Math.round(width * scale), Math.round(height * scale));\n    }\n    function getCenterPoint(pts) {\n        return pts.reduce(function (sum, pt) { return sum.add(pt); }, new Point(0, 0))\n            .div(new Point(pts.length, pts.length));\n    }\n    function range$1(num, start, step$$1) {\n        return Array(num).fill(0).map(function (_, i) { return start + (i * step$$1); });\n    }\n    function isValidNumber(num) {\n        return !!num && num !== Infinity && num !== -Infinity && !isNaN(num) || num === 0;\n    }\n    function isValidProbablitiy(num) {\n        return isValidNumber(num) && 0 <= num && num <= 1.0;\n    }\n\n    function extractWeightEntryFactory(weightMap, paramMappings) {\n        return function (originalPath, paramRank, mappedPath) {\n            var tensor = weightMap[originalPath];\n            if (!isTensor(tensor, paramRank)) {\n                throw new Error(\"expected weightMap[\" + originalPath + \"] to be a Tensor\" + paramRank + \"D, instead have \" + tensor);\n            }\n            paramMappings.push({ originalPath: originalPath, paramPath: mappedPath || originalPath });\n            return tensor;\n        };\n    }\n\n    function extractWeightsFactory(weights) {\n        var remainingWeights = weights;\n        function extractWeights(numWeights) {\n            var ret = remainingWeights.slice(0, numWeights);\n            remainingWeights = remainingWeights.slice(numWeights);\n            return ret;\n        }\n        function getRemainingWeights() {\n            return remainingWeights;\n        }\n        return {\n            extractWeights: extractWeights,\n            getRemainingWeights: getRemainingWeights\n        };\n    }\n\n    function getModelUris(uri, defaultModelName) {\n        var defaultManifestFilename = defaultModelName + \"-weights_manifest.json\";\n        if (!uri) {\n            return {\n                modelBaseUri: '',\n                manifestUri: defaultManifestFilename\n            };\n        }\n        if (uri === '/') {\n            return {\n                modelBaseUri: '/',\n                manifestUri: \"/\" + defaultManifestFilename\n            };\n        }\n        var protocol = uri.startsWith('http://') ? 'http://' : uri.startsWith('https://') ? 'https://' : '';\n        uri = uri.replace(protocol, '');\n        var parts = uri.split('/').filter(function (s) { return s; });\n        var manifestFile = uri.endsWith('.json')\n            ? parts[parts.length - 1]\n            : defaultManifestFilename;\n        var modelBaseUri = protocol + (uri.endsWith('.json') ? parts.slice(0, parts.length - 1) : parts).join('/');\n        modelBaseUri = uri.startsWith('/') ? \"/\" + modelBaseUri : modelBaseUri;\n        return {\n            modelBaseUri: modelBaseUri,\n            manifestUri: modelBaseUri === '/' ? \"/\" + manifestFile : modelBaseUri + \"/\" + manifestFile\n        };\n    }\n\n    /*! *****************************************************************************\n    Copyright (c) Microsoft Corporation. All rights reserved.\n    Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n    this file except in compliance with the License. You may obtain a copy of the\n    License at http://www.apache.org/licenses/LICENSE-2.0\n    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\n    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\n    MERCHANTABLITY OR NON-INFRINGEMENT.\n    See the Apache Version 2.0 License for specific language governing permissions\n    and limitations under the License.\n    ***************************************************************************** */\n    /* global Reflect, Promise */\n\n    var extendStatics$1 = function(d, b) {\n        extendStatics$1 = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics$1(d, b);\n    };\n\n    function __extends$1(d, b) {\n        extendStatics$1(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    }\n\n    var __assign$1 = function() {\n        __assign$1 = Object.assign || function __assign(t) {\n            for (var s, i = 1, n = arguments.length; i < n; i++) {\n                s = arguments[i];\n                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n            return t;\n        };\n        return __assign$1.apply(this, arguments);\n    };\n\n    function __awaiter$1(thisArg, _arguments, P, generator) {\n        return new (P || (P = Promise))(function (resolve, reject) {\n            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n            function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n            step((generator = generator.apply(thisArg, _arguments || [])).next());\n        });\n    }\n\n    function __generator$1(thisArg, body) {\n        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n        return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n        function verb(n) { return function (v) { return step([n, v]); }; }\n        function step(op) {\n            if (f) throw new TypeError(\"Generator is already executing.\");\n            while (_) try {\n                if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n                if (y = 0, t) op = [op[0] & 2, t.value];\n                switch (op[0]) {\n                    case 0: case 1: t = op; break;\n                    case 4: _.label++; return { value: op[1], done: false };\n                    case 5: _.label++; y = op[1]; op = [0]; continue;\n                    case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                    default:\n                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                        if (t[2]) _.ops.pop();\n                        _.trys.pop(); continue;\n                }\n                op = body.call(thisArg, _);\n            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n        }\n    }\n\n    var Box = /** @class */ (function () {\n        // TODO: MTCNN boxes sometimes have negative widths or heights, figure out why and remove\n        // allowNegativeDimensions flag again\n        function Box(_box, allowNegativeDimensions) {\n            if (allowNegativeDimensions === void 0) { allowNegativeDimensions = false; }\n            var box = (_box || {});\n            var isBbox = [box.left, box.top, box.right, box.bottom].every(isValidNumber);\n            var isRect = [box.x, box.y, box.width, box.height].every(isValidNumber);\n            if (!isRect && !isBbox) {\n                throw new Error(\"Box.constructor - expected box to be IBoundingBox | IRect, instead have \" + JSON.stringify(box));\n            }\n            var _a = isRect\n                ? [box.x, box.y, box.width, box.height]\n                : [box.left, box.top, box.right - box.left, box.bottom - box.top], x = _a[0], y = _a[1], width = _a[2], height = _a[3];\n            Box.assertIsValidBox({ x: x, y: y, width: width, height: height }, 'Box.constructor', allowNegativeDimensions);\n            this._x = x;\n            this._y = y;\n            this._width = width;\n            this._height = height;\n        }\n        Box.isRect = function (rect) {\n            return !!rect && [rect.x, rect.y, rect.width, rect.height].every(isValidNumber);\n        };\n        Box.assertIsValidBox = function (box, callee, allowNegativeDimensions) {\n            if (allowNegativeDimensions === void 0) { allowNegativeDimensions = false; }\n            if (!Box.isRect(box)) {\n                throw new Error(callee + \" - invalid box: \" + JSON.stringify(box) + \", expected object with properties x, y, width, height\");\n            }\n            if (!allowNegativeDimensions && (box.width < 0 || box.height < 0)) {\n                throw new Error(callee + \" - width (\" + box.width + \") and height (\" + box.height + \") must be positive numbers\");\n            }\n        };\n        Object.defineProperty(Box.prototype, \"x\", {\n            get: function () { return this._x; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Box.prototype, \"y\", {\n            get: function () { return this._y; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Box.prototype, \"width\", {\n            get: function () { return this._width; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Box.prototype, \"height\", {\n            get: function () { return this._height; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Box.prototype, \"left\", {\n            get: function () { return this.x; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Box.prototype, \"top\", {\n            get: function () { return this.y; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Box.prototype, \"right\", {\n            get: function () { return this.x + this.width; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Box.prototype, \"bottom\", {\n            get: function () { return this.y + this.height; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Box.prototype, \"area\", {\n            get: function () { return this.width * this.height; },\n            enumerable: true,\n            configurable: true\n        });\n        Box.prototype.round = function () {\n            var _a = [this.x, this.y, this.width, this.height]\n                .map(function (val) { return Math.round(val); }), x = _a[0], y = _a[1], width = _a[2], height = _a[3];\n            return new Box({ x: x, y: y, width: width, height: height });\n        };\n        Box.prototype.floor = function () {\n            var _a = [this.x, this.y, this.width, this.height]\n                .map(function (val) { return Math.floor(val); }), x = _a[0], y = _a[1], width = _a[2], height = _a[3];\n            return new Box({ x: x, y: y, width: width, height: height });\n        };\n        Box.prototype.toSquare = function () {\n            var _a = this, x = _a.x, y = _a.y, width = _a.width, height = _a.height;\n            var diff = Math.abs(width - height);\n            if (width < height) {\n                x -= (diff / 2);\n                width += diff;\n            }\n            if (height < width) {\n                y -= (diff / 2);\n                height += diff;\n            }\n            return new Box({ x: x, y: y, width: width, height: height });\n        };\n        Box.prototype.rescale = function (s) {\n            var scaleX = isDimensions(s) ? s.width : s;\n            var scaleY = isDimensions(s) ? s.height : s;\n            return new Box({\n                x: this.x * scaleX,\n                y: this.y * scaleY,\n                width: this.width * scaleX,\n                height: this.height * scaleY\n            });\n        };\n        Box.prototype.pad = function (padX, padY) {\n            var _a = [\n                this.x - (padX / 2),\n                this.y - (padY / 2),\n                this.width + padX,\n                this.height + padY\n            ], x = _a[0], y = _a[1], width = _a[2], height = _a[3];\n            return new Box({ x: x, y: y, width: width, height: height });\n        };\n        Box.prototype.clipAtImageBorders = function (imgWidth, imgHeight) {\n            var _a = this, x = _a.x, y = _a.y, right = _a.right, bottom = _a.bottom;\n            var clippedX = Math.max(x, 0);\n            var clippedY = Math.max(y, 0);\n            var newWidth = right - clippedX;\n            var newHeight = bottom - clippedY;\n            var clippedWidth = Math.min(newWidth, imgWidth - clippedX);\n            var clippedHeight = Math.min(newHeight, imgHeight - clippedY);\n            return (new Box({ x: clippedX, y: clippedY, width: clippedWidth, height: clippedHeight })).floor();\n        };\n        Box.prototype.shift = function (sx, sy) {\n            var _a = this, width = _a.width, height = _a.height;\n            var x = this.x + sx;\n            var y = this.y + sy;\n            return new Box({ x: x, y: y, width: width, height: height });\n        };\n        Box.prototype.padAtBorders = function (imageHeight, imageWidth) {\n            var w = this.width + 1;\n            var h = this.height + 1;\n            var dx = 1;\n            var dy = 1;\n            var edx = w;\n            var edy = h;\n            var x = this.left;\n            var y = this.top;\n            var ex = this.right;\n            var ey = this.bottom;\n            if (ex > imageWidth) {\n                edx = -ex + imageWidth + w;\n                ex = imageWidth;\n            }\n            if (ey > imageHeight) {\n                edy = -ey + imageHeight + h;\n                ey = imageHeight;\n            }\n            if (x < 1) {\n                edy = 2 - x;\n                x = 1;\n            }\n            if (y < 1) {\n                edy = 2 - y;\n                y = 1;\n            }\n            return { dy: dy, edy: edy, dx: dx, edx: edx, y: y, ey: ey, x: x, ex: ex, w: w, h: h };\n        };\n        Box.prototype.calibrate = function (region) {\n            return new Box({\n                left: this.left + (region.left * this.width),\n                top: this.top + (region.top * this.height),\n                right: this.right + (region.right * this.width),\n                bottom: this.bottom + (region.bottom * this.height)\n            }).toSquare().round();\n        };\n        return Box;\n    }());\n\n    var BoundingBox = /** @class */ (function (_super) {\n        __extends$1(BoundingBox, _super);\n        function BoundingBox(left, top, right, bottom) {\n            return _super.call(this, { left: left, top: top, right: right, bottom: bottom }) || this;\n        }\n        return BoundingBox;\n    }(Box));\n\n    var ObjectDetection = /** @class */ (function () {\n        function ObjectDetection(score, classScore, className, relativeBox, imageDims) {\n            this._imageDims = new Dimensions(imageDims.width, imageDims.height);\n            this._score = score;\n            this._classScore = classScore;\n            this._className = className;\n            this._box = new Box(relativeBox).rescale(this._imageDims);\n        }\n        Object.defineProperty(ObjectDetection.prototype, \"score\", {\n            get: function () { return this._score; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ObjectDetection.prototype, \"classScore\", {\n            get: function () { return this._classScore; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ObjectDetection.prototype, \"className\", {\n            get: function () { return this._className; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ObjectDetection.prototype, \"box\", {\n            get: function () { return this._box; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ObjectDetection.prototype, \"imageDims\", {\n            get: function () { return this._imageDims; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ObjectDetection.prototype, \"imageWidth\", {\n            get: function () { return this.imageDims.width; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ObjectDetection.prototype, \"imageHeight\", {\n            get: function () { return this.imageDims.height; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ObjectDetection.prototype, \"relativeBox\", {\n            get: function () { return new Box(this._box).rescale(this.imageDims.reverse()); },\n            enumerable: true,\n            configurable: true\n        });\n        ObjectDetection.prototype.forSize = function (width, height) {\n            return new ObjectDetection(this.score, this.classScore, this.className, this.relativeBox, { width: width, height: height });\n        };\n        return ObjectDetection;\n    }());\n\n    function createBrowserEnv() {\n        var fetch = window['fetch'] || function () {\n            throw new Error('fetch - missing fetch implementation for browser environment');\n        };\n        var readFile = function () {\n            throw new Error('readFile - filesystem not available for browser environment');\n        };\n        return {\n            Canvas: HTMLCanvasElement,\n            Image: HTMLImageElement,\n            ImageData: ImageData,\n            Video: HTMLVideoElement,\n            createCanvasElement: function () { return document.createElement('canvas'); },\n            createImageElement: function () { return document.createElement('img'); },\n            fetch: fetch,\n            readFile: readFile\n        };\n    }\n\n    function createFileSystem(fs) {\n        var requireFsError = '';\n        if (!fs) {\n            try {\n                fs = require('fs');\n            }\n            catch (err) {\n                requireFsError = err.toString();\n            }\n        }\n        var readFile = fs\n            ? function (filePath) {\n                return new Promise(function (res, rej) {\n                    fs.readFile(filePath, function (err, buffer) {\n                        return err ? rej(err) : res(buffer);\n                    });\n                });\n            }\n            : function () {\n                throw new Error(\"readFile - failed to require fs in nodejs environment with error: \" + requireFsError);\n            };\n        return {\n            readFile: readFile\n        };\n    }\n\n    function createNodejsEnv() {\n        var Canvas = global['Canvas'] || global['HTMLCanvasElement'];\n        var Image = global['Image'] || global['HTMLImageElement'];\n        var createCanvasElement = function () {\n            if (Canvas) {\n                return new Canvas();\n            }\n            throw new Error('createCanvasElement - missing Canvas implementation for nodejs environment');\n        };\n        var createImageElement = function () {\n            if (Image) {\n                return new Image();\n            }\n            throw new Error('createImageElement - missing Image implementation for nodejs environment');\n        };\n        var fetch = global['fetch'] || function () {\n            throw new Error('fetch - missing fetch implementation for nodejs environment');\n        };\n        var fileSystem = createFileSystem();\n        return __assign$1({ Canvas: Canvas || /** @class */ (function () {\n                function Canvas() {\n                }\n                return Canvas;\n            }()), Image: Image || /** @class */ (function () {\n                function Image() {\n                }\n                return Image;\n            }()), ImageData: global['ImageData'] || /** @class */ (function () {\n                function class_1() {\n                }\n                return class_1;\n            }()), Video: global['HTMLVideoElement'] || /** @class */ (function () {\n                function class_2() {\n                }\n                return class_2;\n            }()), createCanvasElement: createCanvasElement,\n            createImageElement: createImageElement,\n            fetch: fetch }, fileSystem);\n    }\n\n    function isBrowser() {\n        return typeof window === 'object'\n            && typeof document !== 'undefined'\n            && typeof HTMLImageElement !== 'undefined'\n            && typeof HTMLCanvasElement !== 'undefined'\n            && typeof HTMLVideoElement !== 'undefined'\n            && typeof ImageData !== 'undefined';\n    }\n\n    function isNodejs() {\n        return typeof global === 'object'\n            && typeof require === 'function'\n            && typeof module !== 'undefined'\n            // issues with gatsby.js: module.exports is undefined\n            // && !!module.exports\n            && typeof process !== 'undefined' && !!process.version;\n    }\n\n    var environment$1;\n    function getEnv() {\n        if (!environment$1) {\n            throw new Error('getEnv - environment is not defined, check isNodejs() and isBrowser()');\n        }\n        return environment$1;\n    }\n    function setEnv(env) {\n        environment$1 = env;\n    }\n    function initialize() {\n        // check for isBrowser() first to prevent electron renderer process\n        // to be initialized with wrong environment due to isNodejs() returning true\n        if (isBrowser()) {\n            setEnv(createBrowserEnv());\n        }\n        if (isNodejs()) {\n            setEnv(createNodejsEnv());\n        }\n    }\n    function monkeyPatch(env) {\n        if (!environment$1) {\n            initialize();\n        }\n        if (!environment$1) {\n            throw new Error('monkeyPatch - environment is not defined, check isNodejs() and isBrowser()');\n        }\n        var _a = env.Canvas, Canvas = _a === void 0 ? environment$1.Canvas : _a, _b = env.Image, Image = _b === void 0 ? environment$1.Image : _b;\n        environment$1.Canvas = Canvas;\n        environment$1.Image = Image;\n        environment$1.createCanvasElement = env.createCanvasElement || (function () { return new Canvas(); });\n        environment$1.createImageElement = env.createImageElement || (function () { return new Image(); });\n        environment$1.ImageData = env.ImageData || environment$1.ImageData;\n        environment$1.Video = env.Video || environment$1.Video;\n        environment$1.fetch = env.fetch || environment$1.fetch;\n        environment$1.readFile = env.readFile || environment$1.readFile;\n    }\n    var env = {\n        getEnv: getEnv,\n        setEnv: setEnv,\n        initialize: initialize,\n        createBrowserEnv: createBrowserEnv,\n        createFileSystem: createFileSystem,\n        createNodejsEnv: createNodejsEnv,\n        monkeyPatch: monkeyPatch,\n        isBrowser: isBrowser,\n        isNodejs: isNodejs\n    };\n    initialize();\n\n    function isMediaLoaded(media) {\n        var _a = env.getEnv(), Image = _a.Image, Video = _a.Video;\n        return (media instanceof Image && media.complete)\n            || (media instanceof Video && media.readyState >= 3);\n    }\n\n    function awaitMediaLoaded(media) {\n        return new Promise(function (resolve, reject) {\n            if (media instanceof env.getEnv().Canvas || isMediaLoaded(media)) {\n                return resolve();\n            }\n            function onLoad(e) {\n                if (!e.currentTarget)\n                    return;\n                e.currentTarget.removeEventListener('load', onLoad);\n                e.currentTarget.removeEventListener('error', onError);\n                resolve(e);\n            }\n            function onError(e) {\n                if (!e.currentTarget)\n                    return;\n                e.currentTarget.removeEventListener('load', onLoad);\n                e.currentTarget.removeEventListener('error', onError);\n                reject(e);\n            }\n            media.addEventListener('load', onLoad);\n            media.addEventListener('error', onError);\n        });\n    }\n\n    function bufferToImage(buf) {\n        return new Promise(function (resolve, reject) {\n            if (!(buf instanceof Blob)) {\n                return reject('bufferToImage - expected buf to be of type: Blob');\n            }\n            var reader = new FileReader();\n            reader.onload = function () {\n                if (typeof reader.result !== 'string') {\n                    return reject('bufferToImage - expected reader.result to be a string, in onload');\n                }\n                var img = env.getEnv().createImageElement();\n                img.onload = function () { return resolve(img); };\n                img.onerror = reject;\n                img.src = reader.result;\n            };\n            reader.onerror = reject;\n            reader.readAsDataURL(buf);\n        });\n    }\n\n    function getContext2dOrThrow(canvas) {\n        var ctx = canvas.getContext('2d');\n        if (!ctx) {\n            throw new Error('canvas 2d context is null');\n        }\n        return ctx;\n    }\n\n    function getMediaDimensions(input) {\n        var _a = env.getEnv(), Image = _a.Image, Video = _a.Video;\n        if (input instanceof Image) {\n            return new Dimensions(input.naturalWidth, input.naturalHeight);\n        }\n        if (input instanceof Video) {\n            return new Dimensions(input.videoWidth, input.videoHeight);\n        }\n        return new Dimensions(input.width, input.height);\n    }\n\n    function createCanvas(_a) {\n        var width = _a.width, height = _a.height;\n        var createCanvasElement = env.getEnv().createCanvasElement;\n        var canvas = createCanvasElement();\n        canvas.width = width;\n        canvas.height = height;\n        return canvas;\n    }\n    function createCanvasFromMedia(media, dims) {\n        var ImageData = env.getEnv().ImageData;\n        if (!(media instanceof ImageData) && !isMediaLoaded(media)) {\n            throw new Error('createCanvasFromMedia - media has not finished loading yet');\n        }\n        var _a = dims || getMediaDimensions(media), width = _a.width, height = _a.height;\n        var canvas = createCanvas({ width: width, height: height });\n        if (media instanceof ImageData) {\n            getContext2dOrThrow(canvas).putImageData(media, 0, 0);\n        }\n        else {\n            getContext2dOrThrow(canvas).drawImage(media, 0, 0, width, height);\n        }\n        return canvas;\n    }\n\n    function getDefaultDrawOptions(options) {\n        if (options === void 0) { options = {}; }\n        return Object.assign({}, {\n            boxColor: 'blue',\n            textColor: 'red',\n            lineWidth: 2,\n            fontSize: 20,\n            fontStyle: 'Georgia',\n            withScore: true,\n            withClassName: true\n        }, options);\n    }\n\n    function drawBox(ctx, x, y, w, h, options) {\n        var drawOptions = Object.assign(getDefaultDrawOptions(), (options || {}));\n        ctx.strokeStyle = drawOptions.boxColor;\n        ctx.lineWidth = drawOptions.lineWidth;\n        ctx.strokeRect(x, y, w, h);\n    }\n\n    var BoxWithText = /** @class */ (function (_super) {\n        __extends$1(BoxWithText, _super);\n        function BoxWithText(box, text) {\n            var _this = _super.call(this, box) || this;\n            _this._text = text;\n            return _this;\n        }\n        Object.defineProperty(BoxWithText.prototype, \"text\", {\n            get: function () { return this._text; },\n            enumerable: true,\n            configurable: true\n        });\n        return BoxWithText;\n    }(Box));\n\n    var LabeledBox = /** @class */ (function (_super) {\n        __extends$1(LabeledBox, _super);\n        function LabeledBox(box, label) {\n            var _this = _super.call(this, box) || this;\n            _this._label = label;\n            return _this;\n        }\n        LabeledBox.assertIsValidLabeledBox = function (box, callee) {\n            Box.assertIsValidBox(box, callee);\n            if (!isValidNumber(box.label)) {\n                throw new Error(callee + \" - expected property label (\" + box.label + \") to be a number\");\n            }\n        };\n        Object.defineProperty(LabeledBox.prototype, \"label\", {\n            get: function () { return this._label; },\n            enumerable: true,\n            configurable: true\n        });\n        return LabeledBox;\n    }(Box));\n\n    var PredictedBox = /** @class */ (function (_super) {\n        __extends$1(PredictedBox, _super);\n        function PredictedBox(box, label, score, classScore) {\n            var _this = _super.call(this, box, label) || this;\n            _this._score = score;\n            _this._classScore = classScore;\n            return _this;\n        }\n        PredictedBox.assertIsValidPredictedBox = function (box, callee) {\n            LabeledBox.assertIsValidLabeledBox(box, callee);\n            if (!isValidProbablitiy(box.score)\n                || !isValidProbablitiy(box.classScore)) {\n                throw new Error(callee + \" - expected properties score (\" + box.score + \") and (\" + box.classScore + \") to be a number between [0, 1]\");\n            }\n        };\n        Object.defineProperty(PredictedBox.prototype, \"score\", {\n            get: function () { return this._score; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PredictedBox.prototype, \"classScore\", {\n            get: function () { return this._classScore; },\n            enumerable: true,\n            configurable: true\n        });\n        return PredictedBox;\n    }(LabeledBox));\n\n    function drawText(ctx, x, y, text, options) {\n        if (options === void 0) { options = {}; }\n        var drawOptions = Object.assign(getDefaultDrawOptions(), options);\n        var padText = 2 + drawOptions.lineWidth;\n        ctx.fillStyle = drawOptions.textColor;\n        ctx.font = drawOptions.fontSize + \"px \" + drawOptions.fontStyle;\n        ctx.fillText(text, x + padText, y + padText + (drawOptions.fontSize * 0.6));\n    }\n\n    function resolveInput(arg) {\n        if (!env.isNodejs() && typeof arg === 'string') {\n            return document.getElementById(arg);\n        }\n        return arg;\n    }\n\n    function drawDetection(canvasArg, detection, options) {\n        var Canvas = env.getEnv().Canvas;\n        var canvas = resolveInput(canvasArg);\n        if (!(canvas instanceof Canvas)) {\n            throw new Error('drawDetection - expected canvas to be of type: HTMLCanvasElement');\n        }\n        var detectionArray = Array.isArray(detection)\n            ? detection\n            : [detection];\n        detectionArray.forEach(function (det) {\n            var _a = det instanceof ObjectDetection ? det.box : det, x = _a.x, y = _a.y, width = _a.width, height = _a.height;\n            var drawOptions = getDefaultDrawOptions(options);\n            var ctx = getContext2dOrThrow(canvas);\n            drawBox(ctx, x, y, width, height, drawOptions);\n            var withScore = drawOptions.withScore;\n            var text = det instanceof BoxWithText\n                ? det.text\n                : ((withScore && det instanceof PredictedBox)\n                    ? \"\" + round$1(det.score)\n                    : (det instanceof ObjectDetection\n                        ? \"\" + det.className + (withScore ? \" (\" + round$1(det.score) + \")\" : '')\n                        : ''));\n            if (text) {\n                drawText(ctx, x, y + height, text, drawOptions);\n            }\n        });\n    }\n\n    function fetchOrThrow(url, init) {\n        return __awaiter$1(this, void 0, void 0, function () {\n            var fetch, res;\n            return __generator$1(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        fetch = env.getEnv().fetch;\n                        return [4 /*yield*/, fetch(url, init)];\n                    case 1:\n                        res = _a.sent();\n                        if (!(res.status < 400)) {\n                            throw new Error(\"failed to fetch: (\" + res.status + \") \" + res.statusText + \", from url: \" + res.url);\n                        }\n                        return [2 /*return*/, res];\n                }\n            });\n        });\n    }\n\n    function fetchImage(uri) {\n        return __awaiter$1(this, void 0, void 0, function () {\n            var res, blob;\n            return __generator$1(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, fetchOrThrow(uri)];\n                    case 1:\n                        res = _a.sent();\n                        return [4 /*yield*/, (res).blob()];\n                    case 2:\n                        blob = _a.sent();\n                        if (!blob.type.startsWith('image/')) {\n                            throw new Error(\"fetchImage - expected blob type to be of type image/*, instead have: \" + blob.type + \", for url: \" + res.url);\n                        }\n                        return [2 /*return*/, bufferToImage(blob)];\n                }\n            });\n        });\n    }\n\n    function fetchJson(uri) {\n        return __awaiter$1(this, void 0, void 0, function () {\n            return __generator$1(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, fetchOrThrow(uri)];\n                    case 1: return [2 /*return*/, (_a.sent()).json()];\n                }\n            });\n        });\n    }\n\n    function fetchNetWeights(uri) {\n        return __awaiter$1(this, void 0, void 0, function () {\n            var _a;\n            return __generator$1(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _a = Float32Array.bind;\n                        return [4 /*yield*/, fetchOrThrow(uri)];\n                    case 1: return [4 /*yield*/, (_b.sent()).arrayBuffer()];\n                    case 2: return [2 /*return*/, new (_a.apply(Float32Array, [void 0, _b.sent()]))()];\n                }\n            });\n        });\n    }\n\n    function imageTensorToCanvas(imgTensor, canvas) {\n        return __awaiter$1(this, void 0, void 0, function () {\n            var targetCanvas, _a, height, width, numChannels, imgTensor3D;\n            return __generator$1(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        targetCanvas = canvas || env.getEnv().createCanvasElement();\n                        _a = imgTensor.shape.slice(isTensor4D(imgTensor) ? 1 : 0), height = _a[0], width = _a[1], numChannels = _a[2];\n                        imgTensor3D = tidy(function () { return imgTensor.as3D(height, width, numChannels).toInt(); });\n                        return [4 /*yield*/, toPixels(imgTensor3D, targetCanvas)];\n                    case 1:\n                        _b.sent();\n                        imgTensor3D.dispose();\n                        return [2 /*return*/, targetCanvas];\n                }\n            });\n        });\n    }\n\n    function imageToSquare(input, inputSize, centerImage) {\n        if (centerImage === void 0) { centerImage = false; }\n        var _a = env.getEnv(), Image = _a.Image, Canvas = _a.Canvas;\n        if (!(input instanceof Image || input instanceof Canvas)) {\n            throw new Error('imageToSquare - expected arg0 to be HTMLImageElement | HTMLCanvasElement');\n        }\n        var dims = getMediaDimensions(input);\n        var scale = inputSize / Math.max(dims.height, dims.width);\n        var width = scale * dims.width;\n        var height = scale * dims.height;\n        var targetCanvas = createCanvas({ width: inputSize, height: inputSize });\n        var inputCanvas = input instanceof Canvas ? input : createCanvasFromMedia(input);\n        var offset = Math.abs(width - height) / 2;\n        var dx = centerImage && width < height ? offset : 0;\n        var dy = centerImage && height < width ? offset : 0;\n        getContext2dOrThrow(targetCanvas).drawImage(inputCanvas, dx, dy, width, height);\n        return targetCanvas;\n    }\n\n    function isMediaElement(input) {\n        var _a = env.getEnv(), Image = _a.Image, Canvas = _a.Canvas, Video = _a.Video;\n        return input instanceof Image\n            || input instanceof Canvas\n            || input instanceof Video;\n    }\n\n    function loadWeightMap(uri, defaultModelName) {\n        return __awaiter$1(this, void 0, void 0, function () {\n            var _a, manifestUri, modelBaseUri, manifest;\n            return __generator$1(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _a = getModelUris(uri, defaultModelName), manifestUri = _a.manifestUri, modelBaseUri = _a.modelBaseUri;\n                        return [4 /*yield*/, fetchJson(manifestUri)];\n                    case 1:\n                        manifest = _b.sent();\n                        return [2 /*return*/, io.loadWeights(manifest, modelBaseUri)];\n                }\n            });\n        });\n    }\n\n    /**\n     * Pads the smaller dimension of an image tensor with zeros, such that width === height.\n     *\n     * @param imgTensor The image tensor.\n     * @param isCenterImage (optional, default: false) If true, add an equal amount of padding on\n     * both sides of the minor dimension oof the image.\n     * @returns The padded tensor with width === height.\n     */\n    function padToSquare(imgTensor, isCenterImage) {\n        if (isCenterImage === void 0) { isCenterImage = false; }\n        return tidy(function () {\n            var _a = imgTensor.shape.slice(1), height = _a[0], width = _a[1];\n            if (height === width) {\n                return imgTensor;\n            }\n            var dimDiff = Math.abs(height - width);\n            var paddingAmount = Math.round(dimDiff * (isCenterImage ? 0.5 : 1));\n            var paddingAxis = height > width ? 2 : 1;\n            var createPaddingTensor = function (paddingAmount) {\n                var paddingTensorShape = imgTensor.shape.slice();\n                paddingTensorShape[paddingAxis] = paddingAmount;\n                return fill(paddingTensorShape, 0);\n            };\n            var paddingTensorAppend = createPaddingTensor(paddingAmount);\n            var remainingPaddingAmount = dimDiff - paddingTensorAppend.shape[paddingAxis];\n            var paddingTensorPrepend = isCenterImage && remainingPaddingAmount\n                ? createPaddingTensor(remainingPaddingAmount)\n                : null;\n            var tensorsToStack = [\n                paddingTensorPrepend,\n                imgTensor,\n                paddingTensorAppend\n            ]\n                .filter(function (t) { return !!t; })\n                .map(function (t) { return t.toFloat(); });\n            return concat(tensorsToStack, paddingAxis);\n        });\n    }\n\n    var NetInput = /** @class */ (function () {\n        function NetInput(inputs, treatAsBatchInput) {\n            if (treatAsBatchInput === void 0) { treatAsBatchInput = false; }\n            var _this = this;\n            this._imageTensors = [];\n            this._canvases = [];\n            this._treatAsBatchInput = false;\n            this._inputDimensions = [];\n            if (!Array.isArray(inputs)) {\n                throw new Error(\"NetInput.constructor - expected inputs to be an Array of TResolvedNetInput or to be instanceof tf.Tensor4D, instead have \" + inputs);\n            }\n            this._treatAsBatchInput = treatAsBatchInput;\n            this._batchSize = inputs.length;\n            inputs.forEach(function (input, idx) {\n                if (isTensor3D(input)) {\n                    _this._imageTensors[idx] = input;\n                    _this._inputDimensions[idx] = input.shape;\n                    return;\n                }\n                if (isTensor4D(input)) {\n                    var batchSize = input.shape[0];\n                    if (batchSize !== 1) {\n                        throw new Error(\"NetInput - tf.Tensor4D with batchSize \" + batchSize + \" passed, but not supported in input array\");\n                    }\n                    _this._imageTensors[idx] = input;\n                    _this._inputDimensions[idx] = input.shape.slice(1);\n                    return;\n                }\n                var canvas = input instanceof env.getEnv().Canvas ? input : createCanvasFromMedia(input);\n                _this._canvases[idx] = canvas;\n                _this._inputDimensions[idx] = [canvas.height, canvas.width, 3];\n            });\n        }\n        Object.defineProperty(NetInput.prototype, \"imageTensors\", {\n            get: function () {\n                return this._imageTensors;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NetInput.prototype, \"canvases\", {\n            get: function () {\n                return this._canvases;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NetInput.prototype, \"isBatchInput\", {\n            get: function () {\n                return this.batchSize > 1 || this._treatAsBatchInput;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NetInput.prototype, \"batchSize\", {\n            get: function () {\n                return this._batchSize;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NetInput.prototype, \"inputDimensions\", {\n            get: function () {\n                return this._inputDimensions;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NetInput.prototype, \"inputSize\", {\n            get: function () {\n                return this._inputSize;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NetInput.prototype, \"reshapedInputDimensions\", {\n            get: function () {\n                var _this = this;\n                return range$1(this.batchSize, 0, 1).map(function (_, batchIdx) { return _this.getReshapedInputDimensions(batchIdx); });\n            },\n            enumerable: true,\n            configurable: true\n        });\n        NetInput.prototype.getInput = function (batchIdx) {\n            return this.canvases[batchIdx] || this.imageTensors[batchIdx];\n        };\n        NetInput.prototype.getInputDimensions = function (batchIdx) {\n            return this._inputDimensions[batchIdx];\n        };\n        NetInput.prototype.getInputHeight = function (batchIdx) {\n            return this._inputDimensions[batchIdx][0];\n        };\n        NetInput.prototype.getInputWidth = function (batchIdx) {\n            return this._inputDimensions[batchIdx][1];\n        };\n        NetInput.prototype.getReshapedInputDimensions = function (batchIdx) {\n            if (typeof this.inputSize !== 'number') {\n                throw new Error('getReshapedInputDimensions - inputSize not set, toBatchTensor has not been called yet');\n            }\n            var width = this.getInputWidth(batchIdx);\n            var height = this.getInputHeight(batchIdx);\n            return computeReshapedDimensions({ width: width, height: height }, this.inputSize);\n        };\n        /**\n         * Create a batch tensor from all input canvases and tensors\n         * with size [batchSize, inputSize, inputSize, 3].\n         *\n         * @param inputSize Height and width of the tensor.\n         * @param isCenterImage (optional, default: false) If true, add an equal amount of padding on\n         * both sides of the minor dimension oof the image.\n         * @returns The batch tensor.\n         */\n        NetInput.prototype.toBatchTensor = function (inputSize, isCenterInputs) {\n            var _this = this;\n            if (isCenterInputs === void 0) { isCenterInputs = true; }\n            this._inputSize = inputSize;\n            return tidy(function () {\n                var inputTensors = range$1(_this.batchSize, 0, 1).map(function (batchIdx) {\n                    var input = _this.getInput(batchIdx);\n                    if (input instanceof Tensor) {\n                        var imgTensor = isTensor4D(input) ? input : input.expandDims();\n                        imgTensor = padToSquare(imgTensor, isCenterInputs);\n                        if (imgTensor.shape[1] !== inputSize || imgTensor.shape[2] !== inputSize) {\n                            imgTensor = image_ops.resizeBilinear(imgTensor, [inputSize, inputSize]);\n                        }\n                        return imgTensor.as3D(inputSize, inputSize, 3);\n                    }\n                    if (input instanceof env.getEnv().Canvas) {\n                        return fromPixels(imageToSquare(input, inputSize, isCenterInputs));\n                    }\n                    throw new Error(\"toBatchTensor - at batchIdx \" + batchIdx + \", expected input to be instanceof tf.Tensor or instanceof HTMLCanvasElement, instead have \" + input);\n                });\n                var batchTensor = stack(inputTensors.map(function (t) { return t.toFloat(); })).as4D(_this.batchSize, inputSize, inputSize, 3);\n                return batchTensor;\n            });\n        };\n        return NetInput;\n    }());\n\n    /**\n     * Validates the input to make sure, they are valid net inputs and awaits all media elements\n     * to be finished loading.\n     *\n     * @param input The input, which can be a media element or an array of different media elements.\n     * @returns A NetInput instance, which can be passed into one of the neural networks.\n     */\n    function toNetInput(inputs) {\n        return __awaiter$1(this, void 0, void 0, function () {\n            var inputArgArray, getIdxHint, inputArray;\n            return __generator$1(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (inputs instanceof NetInput) {\n                            return [2 /*return*/, inputs];\n                        }\n                        inputArgArray = Array.isArray(inputs)\n                            ? inputs\n                            : [inputs];\n                        if (!inputArgArray.length) {\n                            throw new Error('toNetInput - empty array passed as input');\n                        }\n                        getIdxHint = function (idx) { return Array.isArray(inputs) ? \" at input index \" + idx + \":\" : ''; };\n                        inputArray = inputArgArray.map(resolveInput);\n                        inputArray.forEach(function (input, i) {\n                            if (!isMediaElement(input) && !isTensor3D(input) && !isTensor4D(input)) {\n                                if (typeof inputArgArray[i] === 'string') {\n                                    throw new Error(\"toNetInput -\" + getIdxHint(i) + \" string passed, but could not resolve HTMLElement for element id \" + inputArgArray[i]);\n                                }\n                                throw new Error(\"toNetInput -\" + getIdxHint(i) + \" expected media to be of type HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | tf.Tensor3D, or to be an element id\");\n                            }\n                            if (isTensor4D(input)) {\n                                // if tf.Tensor4D is passed in the input array, the batch size has to be 1\n                                var batchSize = input.shape[0];\n                                if (batchSize !== 1) {\n                                    throw new Error(\"toNetInput -\" + getIdxHint(i) + \" tf.Tensor4D with batchSize \" + batchSize + \" passed, but not supported in input array\");\n                                }\n                            }\n                        });\n                        // wait for all media elements being loaded\n                        return [4 /*yield*/, Promise.all(inputArray.map(function (input) { return isMediaElement(input) && awaitMediaLoaded(input); }))];\n                    case 1:\n                        // wait for all media elements being loaded\n                        _a.sent();\n                        return [2 /*return*/, new NetInput(inputArray, Array.isArray(inputs))];\n                }\n            });\n        });\n    }\n\n    var NeuralNetwork = /** @class */ (function () {\n        function NeuralNetwork(_name) {\n            this._name = _name;\n            this._params = undefined;\n            this._paramMappings = [];\n        }\n        Object.defineProperty(NeuralNetwork.prototype, \"params\", {\n            get: function () { return this._params; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NeuralNetwork.prototype, \"paramMappings\", {\n            get: function () { return this._paramMappings; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NeuralNetwork.prototype, \"isLoaded\", {\n            get: function () { return !!this.params; },\n            enumerable: true,\n            configurable: true\n        });\n        NeuralNetwork.prototype.getParamFromPath = function (paramPath) {\n            var _a = this.traversePropertyPath(paramPath), obj = _a.obj, objProp = _a.objProp;\n            return obj[objProp];\n        };\n        NeuralNetwork.prototype.reassignParamFromPath = function (paramPath, tensor$$1) {\n            var _a = this.traversePropertyPath(paramPath), obj = _a.obj, objProp = _a.objProp;\n            obj[objProp].dispose();\n            obj[objProp] = tensor$$1;\n        };\n        NeuralNetwork.prototype.getParamList = function () {\n            var _this = this;\n            return this._paramMappings.map(function (_a) {\n                var paramPath = _a.paramPath;\n                return ({\n                    path: paramPath,\n                    tensor: _this.getParamFromPath(paramPath)\n                });\n            });\n        };\n        NeuralNetwork.prototype.getTrainableParams = function () {\n            return this.getParamList().filter(function (param) { return param.tensor instanceof Variable; });\n        };\n        NeuralNetwork.prototype.getFrozenParams = function () {\n            return this.getParamList().filter(function (param) { return !(param.tensor instanceof Variable); });\n        };\n        NeuralNetwork.prototype.variable = function () {\n            var _this = this;\n            this.getFrozenParams().forEach(function (_a) {\n                var path = _a.path, tensor$$1 = _a.tensor;\n                _this.reassignParamFromPath(path, tensor$$1.variable());\n            });\n        };\n        NeuralNetwork.prototype.freeze = function () {\n            var _this = this;\n            this.getTrainableParams().forEach(function (_a) {\n                var path = _a.path, variable$$1 = _a.tensor;\n                var tensor$$1 = tensor(variable$$1.dataSync());\n                variable$$1.dispose();\n                _this.reassignParamFromPath(path, tensor$$1);\n            });\n        };\n        NeuralNetwork.prototype.dispose = function (throwOnRedispose) {\n            if (throwOnRedispose === void 0) { throwOnRedispose = true; }\n            this.getParamList().forEach(function (param) {\n                if (throwOnRedispose && param.tensor.isDisposed) {\n                    throw new Error(\"param tensor has already been disposed for path \" + param.path);\n                }\n                param.tensor.dispose();\n            });\n            this._params = undefined;\n        };\n        NeuralNetwork.prototype.serializeParams = function () {\n            return new Float32Array(this.getParamList()\n                .map(function (_a) {\n                var tensor$$1 = _a.tensor;\n                return Array.from(tensor$$1.dataSync());\n            })\n                .reduce(function (flat, arr) { return flat.concat(arr); }));\n        };\n        NeuralNetwork.prototype.load = function (weightsOrUrl) {\n            return __awaiter$1(this, void 0, void 0, function () {\n                return __generator$1(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            if (weightsOrUrl instanceof Float32Array) {\n                                this.extractWeights(weightsOrUrl);\n                                return [2 /*return*/];\n                            }\n                            return [4 /*yield*/, this.loadFromUri(weightsOrUrl)];\n                        case 1:\n                            _a.sent();\n                            return [2 /*return*/];\n                    }\n                });\n            });\n        };\n        NeuralNetwork.prototype.loadFromUri = function (uri) {\n            return __awaiter$1(this, void 0, void 0, function () {\n                var weightMap;\n                return __generator$1(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            if (uri && typeof uri !== 'string') {\n                                throw new Error(this._name + \".loadFromUri - expected model uri\");\n                            }\n                            return [4 /*yield*/, loadWeightMap(uri, this.getDefaultModelName())];\n                        case 1:\n                            weightMap = _a.sent();\n                            this.loadFromWeightMap(weightMap);\n                            return [2 /*return*/];\n                    }\n                });\n            });\n        };\n        NeuralNetwork.prototype.loadFromDisk = function (filePath) {\n            return __awaiter$1(this, void 0, void 0, function () {\n                var readFile, _a, manifestUri, modelBaseUri, fetchWeightsFromDisk, loadWeights, manifest, _b, _c, weightMap;\n                return __generator$1(this, function (_d) {\n                    switch (_d.label) {\n                        case 0:\n                            if (filePath && typeof filePath !== 'string') {\n                                throw new Error(this._name + \".loadFromDisk - expected model file path\");\n                            }\n                            readFile = env.getEnv().readFile;\n                            _a = getModelUris(filePath, this.getDefaultModelName()), manifestUri = _a.manifestUri, modelBaseUri = _a.modelBaseUri;\n                            fetchWeightsFromDisk = function (filePaths) { return Promise.all(filePaths.map(function (filePath) { return readFile(filePath).then(function (buf) { return buf.buffer; }); })); };\n                            loadWeights = io.weightsLoaderFactory(fetchWeightsFromDisk);\n                            _c = (_b = JSON).parse;\n                            return [4 /*yield*/, readFile(manifestUri)];\n                        case 1:\n                            manifest = _c.apply(_b, [(_d.sent()).toString()]);\n                            return [4 /*yield*/, loadWeights(manifest, modelBaseUri)];\n                        case 2:\n                            weightMap = _d.sent();\n                            this.loadFromWeightMap(weightMap);\n                            return [2 /*return*/];\n                    }\n                });\n            });\n        };\n        NeuralNetwork.prototype.loadFromWeightMap = function (weightMap) {\n            var _a = this.extractParamsFromWeigthMap(weightMap), paramMappings = _a.paramMappings, params = _a.params;\n            this._paramMappings = paramMappings;\n            this._params = params;\n        };\n        NeuralNetwork.prototype.extractWeights = function (weights) {\n            var _a = this.extractParams(weights), paramMappings = _a.paramMappings, params = _a.params;\n            this._paramMappings = paramMappings;\n            this._params = params;\n        };\n        NeuralNetwork.prototype.traversePropertyPath = function (paramPath) {\n            if (!this.params) {\n                throw new Error(\"traversePropertyPath - model has no loaded params\");\n            }\n            var result = paramPath.split('/').reduce(function (res, objProp) {\n                if (!res.nextObj.hasOwnProperty(objProp)) {\n                    throw new Error(\"traversePropertyPath - object does not have property \" + objProp + \", for path \" + paramPath);\n                }\n                return { obj: res.nextObj, objProp: objProp, nextObj: res.nextObj[objProp] };\n            }, { nextObj: this.params });\n            var obj = result.obj, objProp = result.objProp;\n            if (!obj || !objProp || !(obj[objProp] instanceof Tensor)) {\n                throw new Error(\"traversePropertyPath - parameter is not a tensor, for path \" + paramPath);\n            }\n            return { obj: obj, objProp: objProp };\n        };\n        return NeuralNetwork;\n    }());\n\n    function iou(box1, box2, isIOU) {\n        if (isIOU === void 0) { isIOU = true; }\n        var width = Math.max(0.0, Math.min(box1.right, box2.right) - Math.max(box1.left, box2.left));\n        var height = Math.max(0.0, Math.min(box1.bottom, box2.bottom) - Math.max(box1.top, box2.top));\n        var interSection = width * height;\n        return isIOU\n            ? interSection / (box1.area + box2.area - interSection)\n            : interSection / Math.min(box1.area, box2.area);\n    }\n\n    function nonMaxSuppression$1(boxes, scores, iouThreshold, isIOU) {\n        if (isIOU === void 0) { isIOU = true; }\n        var indicesSortedByScore = scores\n            .map(function (score, boxIndex) { return ({ score: score, boxIndex: boxIndex }); })\n            .sort(function (c1, c2) { return c1.score - c2.score; })\n            .map(function (c) { return c.boxIndex; });\n        var pick = [];\n        var _loop_1 = function () {\n            var curr = indicesSortedByScore.pop();\n            pick.push(curr);\n            var indices = indicesSortedByScore;\n            var outputs = [];\n            for (var i = 0; i < indices.length; i++) {\n                var idx = indices[i];\n                var currBox = boxes[curr];\n                var idxBox = boxes[idx];\n                outputs.push(iou(currBox, idxBox, isIOU));\n            }\n            indicesSortedByScore = indicesSortedByScore.filter(function (_, j) { return outputs[j] <= iouThreshold; });\n        };\n        while (indicesSortedByScore.length > 0) {\n            _loop_1();\n        }\n        return pick;\n    }\n\n    function normalize(x, meanRgb) {\n        return tidy(function () {\n            var r = meanRgb[0], g = meanRgb[1], b = meanRgb[2];\n            var avg_r = fill(x.shape.slice(0, 3).concat([1]), r);\n            var avg_g = fill(x.shape.slice(0, 3).concat([1]), g);\n            var avg_b = fill(x.shape.slice(0, 3).concat([1]), b);\n            var avg_rgb = concat([avg_r, avg_g, avg_b], 3);\n            return sub(x, avg_rgb);\n        });\n    }\n\n    function shuffleArray(inputArray) {\n        var array = inputArray.slice();\n        for (var i = array.length - 1; i > 0; i--) {\n            var j = Math.floor(Math.random() * (i + 1));\n            var x = array[i];\n            array[i] = array[j];\n            array[j] = x;\n        }\n        return array;\n    }\n\n    function sigmoid$1(x) {\n        return 1 / (1 + Math.exp(-x));\n    }\n    function inverseSigmoid(x) {\n        return Math.log(x / (1 - x));\n    }\n\n    var isNumber$1 = function (arg) { return typeof arg === 'number'; };\n    function validateConfig(config) {\n        if (!config) {\n            throw new Error(\"invalid config: \" + config);\n        }\n        if (typeof config.withSeparableConvs !== 'boolean') {\n            throw new Error(\"config.withSeparableConvs has to be a boolean, have: \" + config.withSeparableConvs);\n        }\n        if (!isNumber$1(config.iouThreshold) || config.iouThreshold < 0 || config.iouThreshold > 1.0) {\n            throw new Error(\"config.iouThreshold has to be a number between [0, 1], have: \" + config.iouThreshold);\n        }\n        if (!Array.isArray(config.classes)\n            || !config.classes.length\n            || !config.classes.every(function (c) { return typeof c === 'string'; })) {\n            throw new Error(\"config.classes has to be an array class names: string[], have: \" + JSON.stringify(config.classes));\n        }\n        if (!Array.isArray(config.anchors)\n            || !config.anchors.length\n            || !config.anchors.map(function (a) { return a || {}; }).every(function (a) { return isNumber$1(a.x) && isNumber$1(a.y); })) {\n            throw new Error(\"config.anchors has to be an array of { x: number, y: number }, have: \" + JSON.stringify(config.anchors));\n        }\n        if (config.meanRgb && (!Array.isArray(config.meanRgb)\n            || config.meanRgb.length !== 3\n            || !config.meanRgb.every(isNumber$1))) {\n            throw new Error(\"config.meanRgb has to be an array of shape [number, number, number], have: \" + JSON.stringify(config.meanRgb));\n        }\n    }\n\n    function leaky(x) {\n        return tidy(function () {\n            var min$$1 = mul(x, scalar(0.10000000149011612));\n            return add(relu(sub(x, min$$1)), min$$1);\n            //return tf.maximum(x, min)\n        });\n    }\n\n    function convWithBatchNorm(x, params) {\n        return tidy(function () {\n            var out = pad(x, [[0, 0], [1, 1], [1, 1], [0, 0]]);\n            out = conv2d(out, params.conv.filters, [1, 1], 'valid');\n            out = sub(out, params.bn.sub);\n            out = mul(out, params.bn.truediv);\n            out = add(out, params.conv.bias);\n            return leaky(out);\n        });\n    }\n\n    function depthwiseSeparableConv(x, params) {\n        return tidy(function () {\n            var out = pad(x, [[0, 0], [1, 1], [1, 1], [0, 0]]);\n            out = separableConv2d(out, params.depthwise_filter, params.pointwise_filter, [1, 1], 'valid');\n            out = add(out, params.bias);\n            return leaky(out);\n        });\n    }\n\n    function extractorsFactory(extractWeights, paramMappings) {\n        var extractConvParams = extractConvParamsFactory(extractWeights, paramMappings);\n        function extractBatchNormParams(size, mappedPrefix) {\n            var sub$$1 = tensor1d(extractWeights(size));\n            var truediv = tensor1d(extractWeights(size));\n            paramMappings.push({ paramPath: mappedPrefix + \"/sub\" }, { paramPath: mappedPrefix + \"/truediv\" });\n            return { sub: sub$$1, truediv: truediv };\n        }\n        function extractConvWithBatchNormParams(channelsIn, channelsOut, mappedPrefix) {\n            var conv = extractConvParams(channelsIn, channelsOut, 3, mappedPrefix + \"/conv\");\n            var bn = extractBatchNormParams(channelsOut, mappedPrefix + \"/bn\");\n            return { conv: conv, bn: bn };\n        }\n        var extractSeparableConvParams = extractSeparableConvParamsFactory(extractWeights, paramMappings);\n        return {\n            extractConvParams: extractConvParams,\n            extractConvWithBatchNormParams: extractConvWithBatchNormParams,\n            extractSeparableConvParams: extractSeparableConvParams\n        };\n    }\n    function extractParams(weights, config, boxEncodingSize, filterSizes) {\n        var _a = extractWeightsFactory(weights), extractWeights = _a.extractWeights, getRemainingWeights = _a.getRemainingWeights;\n        var paramMappings = [];\n        var _b = extractorsFactory(extractWeights, paramMappings), extractConvParams = _b.extractConvParams, extractConvWithBatchNormParams = _b.extractConvWithBatchNormParams, extractSeparableConvParams = _b.extractSeparableConvParams;\n        var params;\n        if (config.withSeparableConvs) {\n            var s0 = filterSizes[0], s1 = filterSizes[1], s2 = filterSizes[2], s3 = filterSizes[3], s4 = filterSizes[4], s5 = filterSizes[5], s6 = filterSizes[6], s7 = filterSizes[7], s8 = filterSizes[8];\n            var conv0 = config.isFirstLayerConv2d\n                ? extractConvParams(s0, s1, 3, 'conv0')\n                : extractSeparableConvParams(s0, s1, 'conv0');\n            var conv1 = extractSeparableConvParams(s1, s2, 'conv1');\n            var conv2 = extractSeparableConvParams(s2, s3, 'conv2');\n            var conv3 = extractSeparableConvParams(s3, s4, 'conv3');\n            var conv4 = extractSeparableConvParams(s4, s5, 'conv4');\n            var conv5 = extractSeparableConvParams(s5, s6, 'conv5');\n            var conv6 = s7 ? extractSeparableConvParams(s6, s7, 'conv6') : undefined;\n            var conv7 = s8 ? extractSeparableConvParams(s7, s8, 'conv7') : undefined;\n            var conv8 = extractConvParams(s8 || s7 || s6, 5 * boxEncodingSize, 1, 'conv8');\n            params = { conv0: conv0, conv1: conv1, conv2: conv2, conv3: conv3, conv4: conv4, conv5: conv5, conv6: conv6, conv7: conv7, conv8: conv8 };\n        }\n        else {\n            var s0 = filterSizes[0], s1 = filterSizes[1], s2 = filterSizes[2], s3 = filterSizes[3], s4 = filterSizes[4], s5 = filterSizes[5], s6 = filterSizes[6], s7 = filterSizes[7], s8 = filterSizes[8];\n            var conv0 = extractConvWithBatchNormParams(s0, s1, 'conv0');\n            var conv1 = extractConvWithBatchNormParams(s1, s2, 'conv1');\n            var conv2 = extractConvWithBatchNormParams(s2, s3, 'conv2');\n            var conv3 = extractConvWithBatchNormParams(s3, s4, 'conv3');\n            var conv4 = extractConvWithBatchNormParams(s4, s5, 'conv4');\n            var conv5 = extractConvWithBatchNormParams(s5, s6, 'conv5');\n            var conv6 = extractConvWithBatchNormParams(s6, s7, 'conv6');\n            var conv7 = extractConvWithBatchNormParams(s7, s8, 'conv7');\n            var conv8 = extractConvParams(s8, 5 * boxEncodingSize, 1, 'conv8');\n            params = { conv0: conv0, conv1: conv1, conv2: conv2, conv3: conv3, conv4: conv4, conv5: conv5, conv6: conv6, conv7: conv7, conv8: conv8 };\n        }\n        if (getRemainingWeights().length !== 0) {\n            throw new Error(\"weights remaing after extract: \" + getRemainingWeights().length);\n        }\n        return { params: params, paramMappings: paramMappings };\n    }\n\n    function extractorsFactory$1(weightMap, paramMappings) {\n        var extractWeightEntry = extractWeightEntryFactory(weightMap, paramMappings);\n        function extractBatchNormParams(prefix) {\n            var sub = extractWeightEntry(prefix + \"/sub\", 1);\n            var truediv = extractWeightEntry(prefix + \"/truediv\", 1);\n            return { sub: sub, truediv: truediv };\n        }\n        function extractConvParams(prefix) {\n            var filters = extractWeightEntry(prefix + \"/filters\", 4);\n            var bias = extractWeightEntry(prefix + \"/bias\", 1);\n            return { filters: filters, bias: bias };\n        }\n        function extractConvWithBatchNormParams(prefix) {\n            var conv = extractConvParams(prefix + \"/conv\");\n            var bn = extractBatchNormParams(prefix + \"/bn\");\n            return { conv: conv, bn: bn };\n        }\n        var extractSeparableConvParams = loadSeparableConvParamsFactory(extractWeightEntry);\n        return {\n            extractConvParams: extractConvParams,\n            extractConvWithBatchNormParams: extractConvWithBatchNormParams,\n            extractSeparableConvParams: extractSeparableConvParams\n        };\n    }\n    function extractParamsFromWeigthMap(weightMap, config) {\n        var paramMappings = [];\n        var _a = extractorsFactory$1(weightMap, paramMappings), extractConvParams = _a.extractConvParams, extractConvWithBatchNormParams = _a.extractConvWithBatchNormParams, extractSeparableConvParams = _a.extractSeparableConvParams;\n        var params;\n        if (config.withSeparableConvs) {\n            var numFilters = (config.filterSizes && config.filterSizes.length || 9);\n            params = {\n                conv0: config.isFirstLayerConv2d ? extractConvParams('conv0') : extractSeparableConvParams('conv0'),\n                conv1: extractSeparableConvParams('conv1'),\n                conv2: extractSeparableConvParams('conv2'),\n                conv3: extractSeparableConvParams('conv3'),\n                conv4: extractSeparableConvParams('conv4'),\n                conv5: extractSeparableConvParams('conv5'),\n                conv6: numFilters > 7 ? extractSeparableConvParams('conv6') : undefined,\n                conv7: numFilters > 8 ? extractSeparableConvParams('conv7') : undefined,\n                conv8: extractConvParams('conv8')\n            };\n        }\n        else {\n            params = {\n                conv0: extractConvWithBatchNormParams('conv0'),\n                conv1: extractConvWithBatchNormParams('conv1'),\n                conv2: extractConvWithBatchNormParams('conv2'),\n                conv3: extractConvWithBatchNormParams('conv3'),\n                conv4: extractConvWithBatchNormParams('conv4'),\n                conv5: extractConvWithBatchNormParams('conv5'),\n                conv6: extractConvWithBatchNormParams('conv6'),\n                conv7: extractConvWithBatchNormParams('conv7'),\n                conv8: extractConvParams('conv8')\n            };\n        }\n        disposeUnusedWeightTensors(weightMap, paramMappings);\n        return { params: params, paramMappings: paramMappings };\n    }\n\n    var TinyYolov2SizeType;\n    (function (TinyYolov2SizeType) {\n        TinyYolov2SizeType[TinyYolov2SizeType[\"XS\"] = 224] = \"XS\";\n        TinyYolov2SizeType[TinyYolov2SizeType[\"SM\"] = 320] = \"SM\";\n        TinyYolov2SizeType[TinyYolov2SizeType[\"MD\"] = 416] = \"MD\";\n        TinyYolov2SizeType[TinyYolov2SizeType[\"LG\"] = 608] = \"LG\";\n    })(TinyYolov2SizeType || (TinyYolov2SizeType = {}));\n    var TinyYolov2Options = /** @class */ (function () {\n        function TinyYolov2Options(_a) {\n            var _b = _a === void 0 ? {} : _a, inputSize = _b.inputSize, scoreThreshold = _b.scoreThreshold;\n            this._name = 'TinyYolov2Options';\n            this._inputSize = inputSize || 416;\n            this._scoreThreshold = scoreThreshold || 0.5;\n            if (typeof this._inputSize !== 'number' || this._inputSize % 32 !== 0) {\n                throw new Error(this._name + \" - expected inputSize to be a number divisible by 32\");\n            }\n            if (typeof this._scoreThreshold !== 'number' || this._scoreThreshold <= 0 || this._scoreThreshold >= 1) {\n                throw new Error(this._name + \" - expected scoreThreshold to be a number between 0 and 1\");\n            }\n        }\n        Object.defineProperty(TinyYolov2Options.prototype, \"inputSize\", {\n            get: function () { return this._inputSize; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(TinyYolov2Options.prototype, \"scoreThreshold\", {\n            get: function () { return this._scoreThreshold; },\n            enumerable: true,\n            configurable: true\n        });\n        return TinyYolov2Options;\n    }());\n\n    var TinyYolov2 = /** @class */ (function (_super) {\n        __extends$1(TinyYolov2, _super);\n        function TinyYolov2(config) {\n            var _this = _super.call(this, 'TinyYolov2') || this;\n            validateConfig(config);\n            _this._config = config;\n            return _this;\n        }\n        Object.defineProperty(TinyYolov2.prototype, \"config\", {\n            get: function () {\n                return this._config;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(TinyYolov2.prototype, \"withClassScores\", {\n            get: function () {\n                return this.config.withClassScores || this.config.classes.length > 1;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(TinyYolov2.prototype, \"boxEncodingSize\", {\n            get: function () {\n                return 5 + (this.withClassScores ? this.config.classes.length : 0);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        TinyYolov2.prototype.runTinyYolov2 = function (x, params) {\n            var out = convWithBatchNorm(x, params.conv0);\n            out = maxPool(out, [2, 2], [2, 2], 'same');\n            out = convWithBatchNorm(out, params.conv1);\n            out = maxPool(out, [2, 2], [2, 2], 'same');\n            out = convWithBatchNorm(out, params.conv2);\n            out = maxPool(out, [2, 2], [2, 2], 'same');\n            out = convWithBatchNorm(out, params.conv3);\n            out = maxPool(out, [2, 2], [2, 2], 'same');\n            out = convWithBatchNorm(out, params.conv4);\n            out = maxPool(out, [2, 2], [2, 2], 'same');\n            out = convWithBatchNorm(out, params.conv5);\n            out = maxPool(out, [2, 2], [1, 1], 'same');\n            out = convWithBatchNorm(out, params.conv6);\n            out = convWithBatchNorm(out, params.conv7);\n            return convLayer(out, params.conv8, 'valid', false);\n        };\n        TinyYolov2.prototype.runMobilenet = function (x, params) {\n            var out = this.config.isFirstLayerConv2d\n                ? leaky(convLayer(x, params.conv0, 'valid', false))\n                : depthwiseSeparableConv(x, params.conv0);\n            out = maxPool(out, [2, 2], [2, 2], 'same');\n            out = depthwiseSeparableConv(out, params.conv1);\n            out = maxPool(out, [2, 2], [2, 2], 'same');\n            out = depthwiseSeparableConv(out, params.conv2);\n            out = maxPool(out, [2, 2], [2, 2], 'same');\n            out = depthwiseSeparableConv(out, params.conv3);\n            out = maxPool(out, [2, 2], [2, 2], 'same');\n            out = depthwiseSeparableConv(out, params.conv4);\n            out = maxPool(out, [2, 2], [2, 2], 'same');\n            out = depthwiseSeparableConv(out, params.conv5);\n            out = maxPool(out, [2, 2], [1, 1], 'same');\n            out = params.conv6 ? depthwiseSeparableConv(out, params.conv6) : out;\n            out = params.conv7 ? depthwiseSeparableConv(out, params.conv7) : out;\n            return convLayer(out, params.conv8, 'valid', false);\n        };\n        TinyYolov2.prototype.forwardInput = function (input, inputSize) {\n            var _this = this;\n            var params = this.params;\n            if (!params) {\n                throw new Error('TinyYolov2 - load model before inference');\n            }\n            return tidy(function () {\n                var batchTensor = input.toBatchTensor(inputSize, false).toFloat();\n                batchTensor = _this.config.meanRgb\n                    ? normalize(batchTensor, _this.config.meanRgb)\n                    : batchTensor;\n                batchTensor = batchTensor.div(scalar(256));\n                return _this.config.withSeparableConvs\n                    ? _this.runMobilenet(batchTensor, params)\n                    : _this.runTinyYolov2(batchTensor, params);\n            });\n        };\n        TinyYolov2.prototype.forward = function (input, inputSize) {\n            return __awaiter$1(this, void 0, void 0, function () {\n                var _a;\n                return __generator$1(this, function (_b) {\n                    switch (_b.label) {\n                        case 0:\n                            _a = this.forwardInput;\n                            return [4 /*yield*/, toNetInput(input)];\n                        case 1: return [4 /*yield*/, _a.apply(this, [_b.sent(), inputSize])];\n                        case 2: return [2 /*return*/, _b.sent()];\n                    }\n                });\n            });\n        };\n        TinyYolov2.prototype.detect = function (input, forwardParams) {\n            if (forwardParams === void 0) { forwardParams = {}; }\n            return __awaiter$1(this, void 0, void 0, function () {\n                var _a, inputSize, scoreThreshold, netInput, out, out0, inputDimensions, results, boxes, scores, classScores, classNames, indices, detections;\n                var _this = this;\n                return __generator$1(this, function (_b) {\n                    switch (_b.label) {\n                        case 0:\n                            _a = new TinyYolov2Options(forwardParams), inputSize = _a.inputSize, scoreThreshold = _a.scoreThreshold;\n                            return [4 /*yield*/, toNetInput(input)];\n                        case 1:\n                            netInput = _b.sent();\n                            return [4 /*yield*/, this.forwardInput(netInput, inputSize)];\n                        case 2:\n                            out = _b.sent();\n                            out0 = tidy(function () { return unstack(out)[0].expandDims(); });\n                            inputDimensions = {\n                                width: netInput.getInputWidth(0),\n                                height: netInput.getInputHeight(0)\n                            };\n                            results = this.extractBoxes(out0, netInput.getReshapedInputDimensions(0), scoreThreshold);\n                            out.dispose();\n                            out0.dispose();\n                            boxes = results.map(function (res) { return res.box; });\n                            scores = results.map(function (res) { return res.score; });\n                            classScores = results.map(function (res) { return res.classScore; });\n                            classNames = results.map(function (res) { return _this.config.classes[res.label]; });\n                            indices = nonMaxSuppression$1(boxes.map(function (box) { return box.rescale(inputSize); }), scores, this.config.iouThreshold, true);\n                            detections = indices.map(function (idx) {\n                                return new ObjectDetection(scores[idx], classScores[idx], classNames[idx], boxes[idx], inputDimensions);\n                            });\n                            return [2 /*return*/, detections];\n                    }\n                });\n            });\n        };\n        TinyYolov2.prototype.getDefaultModelName = function () {\n            return '';\n        };\n        TinyYolov2.prototype.extractParamsFromWeigthMap = function (weightMap) {\n            return extractParamsFromWeigthMap(weightMap, this.config);\n        };\n        TinyYolov2.prototype.extractParams = function (weights) {\n            var filterSizes = this.config.filterSizes || TinyYolov2.DEFAULT_FILTER_SIZES;\n            var numFilters = filterSizes ? filterSizes.length : undefined;\n            if (numFilters !== 7 && numFilters !== 8 && numFilters !== 9) {\n                throw new Error(\"TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found \" + numFilters + \" filterSizes in config\");\n            }\n            return extractParams(weights, this.config, this.boxEncodingSize, filterSizes);\n        };\n        TinyYolov2.prototype.extractBoxes = function (outputTensor, inputBlobDimensions, scoreThreshold) {\n            var _this = this;\n            var width = inputBlobDimensions.width, height = inputBlobDimensions.height;\n            var inputSize = Math.max(width, height);\n            var correctionFactorX = inputSize / width;\n            var correctionFactorY = inputSize / height;\n            var numCells = outputTensor.shape[1];\n            var numBoxes = this.config.anchors.length;\n            var _a = tidy(function () {\n                var reshaped = outputTensor.reshape([numCells, numCells, numBoxes, _this.boxEncodingSize]);\n                var boxes = reshaped.slice([0, 0, 0, 0], [numCells, numCells, numBoxes, 4]);\n                var scores = reshaped.slice([0, 0, 0, 4], [numCells, numCells, numBoxes, 1]);\n                var classScores = _this.withClassScores\n                    ? softmax(reshaped.slice([0, 0, 0, 5], [numCells, numCells, numBoxes, _this.config.classes.length]), 3)\n                    : scalar(0);\n                return [boxes, scores, classScores];\n            }), boxesTensor = _a[0], scoresTensor = _a[1], classScoresTensor = _a[2];\n            var results = [];\n            for (var row = 0; row < numCells; row++) {\n                for (var col = 0; col < numCells; col++) {\n                    for (var anchor = 0; anchor < numBoxes; anchor++) {\n                        var score = sigmoid$1(scoresTensor.get(row, col, anchor, 0));\n                        if (!scoreThreshold || score > scoreThreshold) {\n                            var ctX = ((col + sigmoid$1(boxesTensor.get(row, col, anchor, 0))) / numCells) * correctionFactorX;\n                            var ctY = ((row + sigmoid$1(boxesTensor.get(row, col, anchor, 1))) / numCells) * correctionFactorY;\n                            var width_1 = ((Math.exp(boxesTensor.get(row, col, anchor, 2)) * this.config.anchors[anchor].x) / numCells) * correctionFactorX;\n                            var height_1 = ((Math.exp(boxesTensor.get(row, col, anchor, 3)) * this.config.anchors[anchor].y) / numCells) * correctionFactorY;\n                            var x = (ctX - (width_1 / 2));\n                            var y = (ctY - (height_1 / 2));\n                            var pos = { row: row, col: col, anchor: anchor };\n                            var _b = this.withClassScores\n                                ? this.extractPredictedClass(classScoresTensor, pos)\n                                : { classScore: 1, label: 0 }, classScore = _b.classScore, label = _b.label;\n                            results.push(__assign$1({ box: new BoundingBox(x, y, x + width_1, y + height_1), score: score, classScore: score * classScore, label: label }, pos));\n                        }\n                    }\n                }\n            }\n            boxesTensor.dispose();\n            scoresTensor.dispose();\n            classScoresTensor.dispose();\n            return results;\n        };\n        TinyYolov2.prototype.extractPredictedClass = function (classesTensor, pos) {\n            var row = pos.row, col = pos.col, anchor = pos.anchor;\n            return Array(this.config.classes.length).fill(0)\n                .map(function (_, i) { return classesTensor.get(row, col, anchor, i); })\n                .map(function (classScore, label) { return ({\n                classScore: classScore,\n                label: label\n            }); })\n                .reduce(function (max$$1, curr) { return max$$1.classScore > curr.classScore ? max$$1 : curr; });\n        };\n        TinyYolov2.DEFAULT_FILTER_SIZES = [\n            3, 16, 32, 64, 128, 256, 512, 1024, 1024\n        ];\n        return TinyYolov2;\n    }(NeuralNetwork));\n\n\n\n    var tfjsImageRecognitionBase = /*#__PURE__*/Object.freeze({\n        convLayer: convLayer,\n        disposeUnusedWeightTensors: disposeUnusedWeightTensors,\n        extractConvParamsFactory: extractConvParamsFactory,\n        extractFCParamsFactory: extractFCParamsFactory,\n        extractSeparableConvParamsFactory: extractSeparableConvParamsFactory,\n        loadSeparableConvParamsFactory: loadSeparableConvParamsFactory,\n        extractWeightEntryFactory: extractWeightEntryFactory,\n        extractWeightsFactory: extractWeightsFactory,\n        getModelUris: getModelUris,\n        SeparableConvParams: SeparableConvParams,\n        TinyYolov2: TinyYolov2,\n        get TinyYolov2SizeType () { return TinyYolov2SizeType; },\n        TinyYolov2Options: TinyYolov2Options,\n        validateConfig: validateConfig\n    });\n\n    var Rect = /** @class */ (function (_super) {\n        __extends$1(Rect, _super);\n        function Rect(x, y, width, height) {\n            return _super.call(this, { x: x, y: y, width: width, height: height }) || this;\n        }\n        return Rect;\n    }(Box));\n\n    var FaceDetection = /** @class */ (function (_super) {\n        __extends$1(FaceDetection, _super);\n        function FaceDetection(score, relativeBox, imageDims) {\n            return _super.call(this, score, score, '', relativeBox, imageDims) || this;\n        }\n        FaceDetection.prototype.forSize = function (width, height) {\n            return _super.prototype.forSize.call(this, width, height);\n        };\n        return FaceDetection;\n    }(ObjectDetection));\n\n    // face alignment constants\n    var relX = 0.5;\n    var relY = 0.43;\n    var relScale = 0.45;\n    var FaceLandmarks = /** @class */ (function () {\n        function FaceLandmarks(relativeFaceLandmarkPositions, imgDims, shift) {\n            if (shift === void 0) { shift = new Point(0, 0); }\n            var width = imgDims.width, height = imgDims.height;\n            this._imgDims = new Dimensions(width, height);\n            this._shift = shift;\n            this._positions = relativeFaceLandmarkPositions.map(function (pt) { return pt.mul(new Point(width, height)).add(shift); });\n        }\n        Object.defineProperty(FaceLandmarks.prototype, \"shift\", {\n            get: function () { return new Point(this._shift.x, this._shift.y); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FaceLandmarks.prototype, \"imageWidth\", {\n            get: function () { return this._imgDims.width; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FaceLandmarks.prototype, \"imageHeight\", {\n            get: function () { return this._imgDims.height; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FaceLandmarks.prototype, \"positions\", {\n            get: function () { return this._positions; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FaceLandmarks.prototype, \"relativePositions\", {\n            get: function () {\n                var _this = this;\n                return this._positions.map(function (pt) { return pt.sub(_this._shift).div(new Point(_this.imageWidth, _this.imageHeight)); });\n            },\n            enumerable: true,\n            configurable: true\n        });\n        FaceLandmarks.prototype.forSize = function (width, height) {\n            return new this.constructor(this.relativePositions, { width: width, height: height });\n        };\n        FaceLandmarks.prototype.shiftBy = function (x, y) {\n            return new this.constructor(this.relativePositions, this._imgDims, new Point(x, y));\n        };\n        FaceLandmarks.prototype.shiftByPoint = function (pt) {\n            return this.shiftBy(pt.x, pt.y);\n        };\n        /**\n         * Aligns the face landmarks after face detection from the relative positions of the faces\n         * bounding box, or it's current shift. This function should be used to align the face images\n         * after face detection has been performed, before they are passed to the face recognition net.\n         * This will make the computed face descriptor more accurate.\n         *\n         * @param detection (optional) The bounding box of the face or the face detection result. If\n         * no argument was passed the position of the face landmarks are assumed to be relative to\n         * it's current shift.\n         * @returns The bounding box of the aligned face.\n         */\n        FaceLandmarks.prototype.align = function (detection) {\n            if (detection) {\n                var box = detection instanceof FaceDetection\n                    ? detection.box.floor()\n                    : detection;\n                return this.shiftBy(box.x, box.y).align();\n            }\n            var centers = this.getRefPointsForAlignment();\n            var leftEyeCenter = centers[0], rightEyeCenter = centers[1], mouthCenter = centers[2];\n            var distToMouth = function (pt) { return mouthCenter.sub(pt).magnitude(); };\n            var eyeToMouthDist = (distToMouth(leftEyeCenter) + distToMouth(rightEyeCenter)) / 2;\n            var size = Math.floor(eyeToMouthDist / relScale);\n            var refPoint = getCenterPoint(centers);\n            // TODO: pad in case rectangle is out of image bounds\n            var x = Math.floor(Math.max(0, refPoint.x - (relX * size)));\n            var y = Math.floor(Math.max(0, refPoint.y - (relY * size)));\n            return new Rect(x, y, Math.min(size, this.imageWidth + x), Math.min(size, this.imageHeight + y));\n        };\n        FaceLandmarks.prototype.getRefPointsForAlignment = function () {\n            throw new Error('getRefPointsForAlignment not implemented by base class');\n        };\n        return FaceLandmarks;\n    }());\n\n    var FaceLandmarks5 = /** @class */ (function (_super) {\n        __extends$1(FaceLandmarks5, _super);\n        function FaceLandmarks5() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        FaceLandmarks5.prototype.getRefPointsForAlignment = function () {\n            var pts = this.positions;\n            return [\n                pts[0],\n                pts[1],\n                getCenterPoint([pts[3], pts[4]])\n            ];\n        };\n        return FaceLandmarks5;\n    }(FaceLandmarks));\n\n    var FaceLandmarks68 = /** @class */ (function (_super) {\n        __extends$1(FaceLandmarks68, _super);\n        function FaceLandmarks68() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        FaceLandmarks68.prototype.getJawOutline = function () {\n            return this.positions.slice(0, 17);\n        };\n        FaceLandmarks68.prototype.getLeftEyeBrow = function () {\n            return this.positions.slice(17, 22);\n        };\n        FaceLandmarks68.prototype.getRightEyeBrow = function () {\n            return this.positions.slice(22, 27);\n        };\n        FaceLandmarks68.prototype.getNose = function () {\n            return this.positions.slice(27, 36);\n        };\n        FaceLandmarks68.prototype.getLeftEye = function () {\n            return this.positions.slice(36, 42);\n        };\n        FaceLandmarks68.prototype.getRightEye = function () {\n            return this.positions.slice(42, 48);\n        };\n        FaceLandmarks68.prototype.getMouth = function () {\n            return this.positions.slice(48, 68);\n        };\n        FaceLandmarks68.prototype.getRefPointsForAlignment = function () {\n            return [\n                this.getLeftEye(),\n                this.getRightEye(),\n                this.getMouth()\n            ].map(getCenterPoint);\n        };\n        return FaceLandmarks68;\n    }(FaceLandmarks));\n\n    var FaceMatch = /** @class */ (function () {\n        function FaceMatch(label, distance) {\n            this._label = label;\n            this._distance = distance;\n        }\n        Object.defineProperty(FaceMatch.prototype, \"label\", {\n            get: function () { return this._label; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FaceMatch.prototype, \"distance\", {\n            get: function () { return this._distance; },\n            enumerable: true,\n            configurable: true\n        });\n        FaceMatch.prototype.toString = function (withDistance) {\n            if (withDistance === void 0) { withDistance = true; }\n            return \"\" + this.label + (withDistance ? \" (\" + round$1(this.distance) + \")\" : '');\n        };\n        return FaceMatch;\n    }());\n\n    var LabeledFaceDescriptors = /** @class */ (function () {\n        function LabeledFaceDescriptors(label, descriptors) {\n            if (!(typeof label === 'string')) {\n                throw new Error('LabeledFaceDescriptors - constructor expected label to be a string');\n            }\n            if (!Array.isArray(descriptors) || descriptors.some(function (desc) { return !(desc instanceof Float32Array); })) {\n                throw new Error('LabeledFaceDescriptors - constructor expected descriptors to be an array of Float32Array');\n            }\n            this._label = label;\n            this._descriptors = descriptors;\n        }\n        Object.defineProperty(LabeledFaceDescriptors.prototype, \"label\", {\n            get: function () { return this._label; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(LabeledFaceDescriptors.prototype, \"descriptors\", {\n            get: function () { return this._descriptors; },\n            enumerable: true,\n            configurable: true\n        });\n        return LabeledFaceDescriptors;\n    }());\n\n    function drawContour(ctx, points, isClosed) {\n        if (isClosed === void 0) { isClosed = false; }\n        ctx.beginPath();\n        points.slice(1).forEach(function (_a, prevIdx) {\n            var x = _a.x, y = _a.y;\n            var from = points[prevIdx];\n            ctx.moveTo(from.x, from.y);\n            ctx.lineTo(x, y);\n        });\n        if (isClosed) {\n            var from = points[points.length - 1];\n            var to = points[0];\n            if (!from || !to) {\n                return;\n            }\n            ctx.moveTo(from.x, from.y);\n            ctx.lineTo(to.x, to.y);\n        }\n        ctx.stroke();\n    }\n\n    function drawLandmarks(canvasArg, faceLandmarks, options) {\n        var canvas = resolveInput(canvasArg);\n        if (!(canvas instanceof env.getEnv().Canvas)) {\n            throw new Error('drawLandmarks - expected canvas to be of type: HTMLCanvasElement');\n        }\n        var drawOptions = Object.assign(getDefaultDrawOptions(options), (options || {}));\n        var drawLines = Object.assign({ drawLines: false }, (options || {})).drawLines;\n        var ctx = getContext2dOrThrow(canvas);\n        var lineWidth = drawOptions.lineWidth, _a = drawOptions.color, color = _a === void 0 ? 'blue' : _a;\n        var faceLandmarksArray = Array.isArray(faceLandmarks) ? faceLandmarks : [faceLandmarks];\n        faceLandmarksArray.forEach(function (landmarks) {\n            if (drawLines && landmarks instanceof FaceLandmarks68) {\n                ctx.strokeStyle = color;\n                ctx.lineWidth = lineWidth;\n                drawContour(ctx, landmarks.getJawOutline());\n                drawContour(ctx, landmarks.getLeftEyeBrow());\n                drawContour(ctx, landmarks.getRightEyeBrow());\n                drawContour(ctx, landmarks.getNose());\n                drawContour(ctx, landmarks.getLeftEye(), true);\n                drawContour(ctx, landmarks.getRightEye(), true);\n                drawContour(ctx, landmarks.getMouth(), true);\n                return;\n            }\n            // else draw points\n            var ptOffset = lineWidth / 2;\n            ctx.fillStyle = color;\n            landmarks.positions.forEach(function (pt) { return ctx.fillRect(pt.x - ptOffset, pt.y - ptOffset, lineWidth, lineWidth); });\n        });\n    }\n\n    function drawFaceExpressions(canvasArg, faceExpressions, options) {\n        var canvas = resolveInput(canvasArg);\n        if (!(canvas instanceof env.getEnv().Canvas)) {\n            throw new Error('drawFaceExpressions - expected canvas to be of type: HTMLCanvasElement');\n        }\n        var drawOptions = Object.assign(getDefaultDrawOptions(options), (options || {}));\n        var ctx = getContext2dOrThrow(canvas);\n        var _a = drawOptions.primaryColor, primaryColor = _a === void 0 ? 'red' : _a, _b = drawOptions.secondaryColor, secondaryColor = _b === void 0 ? 'blue' : _b, _c = drawOptions.primaryFontSize, primaryFontSize = _c === void 0 ? 22 : _c, _d = drawOptions.secondaryFontSize, secondaryFontSize = _d === void 0 ? 16 : _d, _e = drawOptions.minConfidence, minConfidence = _e === void 0 ? 0.2 : _e;\n        var faceExpressionsArray = Array.isArray(faceExpressions)\n            ? faceExpressions\n            : [faceExpressions];\n        faceExpressionsArray.forEach(function (_a) {\n            var position = _a.position, expressions = _a.expressions;\n            var x = position.x, y = position.y;\n            var height = position.height || 0;\n            var sorted = expressions.sort(function (a, b) { return b.probability - a.probability; });\n            var resultsToDisplay = sorted.filter(function (expr) { return expr.probability > minConfidence; });\n            var offset = (y + height + resultsToDisplay.length * primaryFontSize) > canvas.height\n                ? -(resultsToDisplay.length * primaryFontSize)\n                : 0;\n            resultsToDisplay.forEach(function (expr, i) {\n                var text = expr.expression + \" (\" + round$1(expr.probability) + \")\";\n                drawText(ctx, x, y + height + (i * primaryFontSize) + offset, text, {\n                    textColor: i === 0 ? primaryColor : secondaryColor,\n                    fontSize: i === 0 ? primaryFontSize : secondaryFontSize\n                });\n            });\n        });\n    }\n\n    /**\n     * Extracts the image regions containing the detected faces.\n     *\n     * @param input The image that face detection has been performed on.\n     * @param detections The face detection results or face bounding boxes for that image.\n     * @returns The Canvases of the corresponding image region for each detected face.\n     */\n    function extractFaces(input, detections) {\n        return __awaiter$1(this, void 0, void 0, function () {\n            var Canvas, canvas, netInput, tensorOrCanvas, _a, ctx, boxes;\n            return __generator$1(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        Canvas = env.getEnv().Canvas;\n                        canvas = input;\n                        if (!!(input instanceof Canvas)) return [3 /*break*/, 5];\n                        return [4 /*yield*/, toNetInput(input)];\n                    case 1:\n                        netInput = _b.sent();\n                        if (netInput.batchSize > 1) {\n                            throw new Error('extractFaces - batchSize > 1 not supported');\n                        }\n                        tensorOrCanvas = netInput.getInput(0);\n                        if (!(tensorOrCanvas instanceof Canvas)) return [3 /*break*/, 2];\n                        _a = tensorOrCanvas;\n                        return [3 /*break*/, 4];\n                    case 2: return [4 /*yield*/, imageTensorToCanvas(tensorOrCanvas)];\n                    case 3:\n                        _a = _b.sent();\n                        _b.label = 4;\n                    case 4:\n                        canvas = _a;\n                        _b.label = 5;\n                    case 5:\n                        ctx = getContext2dOrThrow(canvas);\n                        boxes = detections.map(function (det) { return det instanceof FaceDetection\n                            ? det.forSize(canvas.width, canvas.height).box.floor()\n                            : det; })\n                            .map(function (box) { return box.clipAtImageBorders(canvas.width, canvas.height); });\n                        return [2 /*return*/, boxes.map(function (_a) {\n                                var x = _a.x, y = _a.y, width = _a.width, height = _a.height;\n                                var faceImg = createCanvas({ width: width, height: height });\n                                getContext2dOrThrow(faceImg)\n                                    .putImageData(ctx.getImageData(x, y, width, height), 0, 0);\n                                return faceImg;\n                            })];\n                }\n            });\n        });\n    }\n\n    /**\n     * Extracts the tensors of the image regions containing the detected faces.\n     * Useful if you want to compute the face descriptors for the face images.\n     * Using this method is faster then extracting a canvas for each face and\n     * converting them to tensors individually.\n     *\n     * @param imageTensor The image tensor that face detection has been performed on.\n     * @param detections The face detection results or face bounding boxes for that image.\n     * @returns Tensors of the corresponding image region for each detected face.\n     */\n    function extractFaceTensors(imageTensor, detections) {\n        return __awaiter$1(this, void 0, void 0, function () {\n            return __generator$1(this, function (_a) {\n                if (!isTensor3D(imageTensor) && !isTensor4D(imageTensor)) {\n                    throw new Error('extractFaceTensors - expected image tensor to be 3D or 4D');\n                }\n                if (isTensor4D(imageTensor) && imageTensor.shape[0] > 1) {\n                    throw new Error('extractFaceTensors - batchSize > 1 not supported');\n                }\n                return [2 /*return*/, tidy(function () {\n                        var _a = imageTensor.shape.slice(isTensor4D(imageTensor) ? 1 : 0), imgHeight = _a[0], imgWidth = _a[1], numChannels = _a[2];\n                        var boxes = detections.map(function (det) { return det instanceof FaceDetection\n                            ? det.forSize(imgWidth, imgHeight).box\n                            : det; })\n                            .map(function (box) { return box.clipAtImageBorders(imgWidth, imgHeight); });\n                        var faceTensors = boxes.map(function (_a) {\n                            var x = _a.x, y = _a.y, width = _a.width, height = _a.height;\n                            return slice3d(imageTensor.as3D(imgHeight, imgWidth, numChannels), [y, x, 0], [height, width, numChannels]);\n                        });\n                        return faceTensors;\n                    })];\n            });\n        });\n    }\n\n    function depthwiseSeparableConv$1(x, params, stride) {\n        return tidy(function () {\n            var out = separableConv2d(x, params.depthwise_filter, params.pointwise_filter, stride, 'same');\n            out = add(out, params.bias);\n            return out;\n        });\n    }\n\n    function denseBlock3(x, denseBlockParams, isFirstLayer) {\n        if (isFirstLayer === void 0) { isFirstLayer = false; }\n        return tidy(function () {\n            var out1 = relu(isFirstLayer\n                ? add(conv2d(x, denseBlockParams.conv0.filters, [2, 2], 'same'), denseBlockParams.conv0.bias)\n                : depthwiseSeparableConv$1(x, denseBlockParams.conv0, [2, 2]));\n            var out2 = depthwiseSeparableConv$1(out1, denseBlockParams.conv1, [1, 1]);\n            var in3 = relu(add(out1, out2));\n            var out3 = depthwiseSeparableConv$1(in3, denseBlockParams.conv2, [1, 1]);\n            return relu(add(out1, add(out2, out3)));\n        });\n    }\n    function denseBlock4(x, denseBlockParams, isFirstLayer, isScaleDown) {\n        if (isFirstLayer === void 0) { isFirstLayer = false; }\n        if (isScaleDown === void 0) { isScaleDown = true; }\n        return tidy(function () {\n            var out1 = relu(isFirstLayer\n                ? add(conv2d(x, denseBlockParams.conv0.filters, isScaleDown ? [2, 2] : [1, 1], 'same'), denseBlockParams.conv0.bias)\n                : depthwiseSeparableConv$1(x, denseBlockParams.conv0, isScaleDown ? [2, 2] : [1, 1]));\n            var out2 = depthwiseSeparableConv$1(out1, denseBlockParams.conv1, [1, 1]);\n            var in3 = relu(add(out1, out2));\n            var out3 = depthwiseSeparableConv$1(in3, denseBlockParams.conv2, [1, 1]);\n            var in4 = relu(add(out1, add(out2, out3)));\n            var out4 = depthwiseSeparableConv$1(in4, denseBlockParams.conv3, [1, 1]);\n            return relu(add(out1, add(out2, add(out3, out4))));\n        });\n    }\n\n    function extractorsFactory$2(extractWeights, paramMappings) {\n        function extractSeparableConvParams(channelsIn, channelsOut, mappedPrefix) {\n            var depthwise_filter = tensor4d(extractWeights(3 * 3 * channelsIn), [3, 3, channelsIn, 1]);\n            var pointwise_filter = tensor4d(extractWeights(channelsIn * channelsOut), [1, 1, channelsIn, channelsOut]);\n            var bias = tensor1d(extractWeights(channelsOut));\n            paramMappings.push({ paramPath: mappedPrefix + \"/depthwise_filter\" }, { paramPath: mappedPrefix + \"/pointwise_filter\" }, { paramPath: mappedPrefix + \"/bias\" });\n            return new SeparableConvParams(depthwise_filter, pointwise_filter, bias);\n        }\n        var extractConvParams = extractConvParamsFactory(extractWeights, paramMappings);\n        function extractDenseBlock3Params(channelsIn, channelsOut, mappedPrefix, isFirstLayer) {\n            if (isFirstLayer === void 0) { isFirstLayer = false; }\n            var conv0 = isFirstLayer\n                ? extractConvParams(channelsIn, channelsOut, 3, mappedPrefix + \"/conv0\")\n                : extractSeparableConvParams(channelsIn, channelsOut, mappedPrefix + \"/conv0\");\n            var conv1 = extractSeparableConvParams(channelsOut, channelsOut, mappedPrefix + \"/conv1\");\n            var conv2 = extractSeparableConvParams(channelsOut, channelsOut, mappedPrefix + \"/conv2\");\n            return { conv0: conv0, conv1: conv1, conv2: conv2 };\n        }\n        function extractDenseBlock4Params(channelsIn, channelsOut, mappedPrefix, isFirstLayer) {\n            if (isFirstLayer === void 0) { isFirstLayer = false; }\n            var _a = extractDenseBlock3Params(channelsIn, channelsOut, mappedPrefix, isFirstLayer), conv0 = _a.conv0, conv1 = _a.conv1, conv2 = _a.conv2;\n            var conv3 = extractSeparableConvParams(channelsOut, channelsOut, mappedPrefix + \"/conv3\");\n            return { conv0: conv0, conv1: conv1, conv2: conv2, conv3: conv3 };\n        }\n        return {\n            extractDenseBlock3Params: extractDenseBlock3Params,\n            extractDenseBlock4Params: extractDenseBlock4Params\n        };\n    }\n\n    function extractParams$1(weights) {\n        var paramMappings = [];\n        var _a = extractWeightsFactory(weights), extractWeights = _a.extractWeights, getRemainingWeights = _a.getRemainingWeights;\n        var extractDenseBlock4Params = extractorsFactory$2(extractWeights, paramMappings).extractDenseBlock4Params;\n        var dense0 = extractDenseBlock4Params(3, 32, 'dense0', true);\n        var dense1 = extractDenseBlock4Params(32, 64, 'dense1');\n        var dense2 = extractDenseBlock4Params(64, 128, 'dense2');\n        var dense3 = extractDenseBlock4Params(128, 256, 'dense3');\n        if (getRemainingWeights().length !== 0) {\n            throw new Error(\"weights remaing after extract: \" + getRemainingWeights().length);\n        }\n        return {\n            paramMappings: paramMappings,\n            params: { dense0: dense0, dense1: dense1, dense2: dense2, dense3: dense3 }\n        };\n    }\n\n    function loadParamsFactory(weightMap, paramMappings) {\n        var extractWeightEntry = extractWeightEntryFactory(weightMap, paramMappings);\n        function extractConvParams(prefix) {\n            var filters = extractWeightEntry(prefix + \"/filters\", 4);\n            var bias = extractWeightEntry(prefix + \"/bias\", 1);\n            return { filters: filters, bias: bias };\n        }\n        function extractSeparableConvParams(prefix) {\n            var depthwise_filter = extractWeightEntry(prefix + \"/depthwise_filter\", 4);\n            var pointwise_filter = extractWeightEntry(prefix + \"/pointwise_filter\", 4);\n            var bias = extractWeightEntry(prefix + \"/bias\", 1);\n            return new SeparableConvParams(depthwise_filter, pointwise_filter, bias);\n        }\n        function extractDenseBlock3Params(prefix, isFirstLayer) {\n            if (isFirstLayer === void 0) { isFirstLayer = false; }\n            var conv0 = isFirstLayer\n                ? extractConvParams(prefix + \"/conv0\")\n                : extractSeparableConvParams(prefix + \"/conv0\");\n            var conv1 = extractSeparableConvParams(prefix + \"/conv1\");\n            var conv2 = extractSeparableConvParams(prefix + \"/conv2\");\n            return { conv0: conv0, conv1: conv1, conv2: conv2 };\n        }\n        function extractDenseBlock4Params(prefix, isFirstLayer) {\n            if (isFirstLayer === void 0) { isFirstLayer = false; }\n            var conv0 = isFirstLayer\n                ? extractConvParams(prefix + \"/conv0\")\n                : extractSeparableConvParams(prefix + \"/conv0\");\n            var conv1 = extractSeparableConvParams(prefix + \"/conv1\");\n            var conv2 = extractSeparableConvParams(prefix + \"/conv2\");\n            var conv3 = extractSeparableConvParams(prefix + \"/conv3\");\n            return { conv0: conv0, conv1: conv1, conv2: conv2, conv3: conv3 };\n        }\n        return {\n            extractDenseBlock3Params: extractDenseBlock3Params,\n            extractDenseBlock4Params: extractDenseBlock4Params\n        };\n    }\n\n    function extractParamsFromWeigthMap$1(weightMap) {\n        var paramMappings = [];\n        var extractDenseBlock4Params = loadParamsFactory(weightMap, paramMappings).extractDenseBlock4Params;\n        var params = {\n            dense0: extractDenseBlock4Params('dense0', true),\n            dense1: extractDenseBlock4Params('dense1'),\n            dense2: extractDenseBlock4Params('dense2'),\n            dense3: extractDenseBlock4Params('dense3')\n        };\n        disposeUnusedWeightTensors(weightMap, paramMappings);\n        return { params: params, paramMappings: paramMappings };\n    }\n\n    var FaceFeatureExtractor = /** @class */ (function (_super) {\n        __extends$1(FaceFeatureExtractor, _super);\n        function FaceFeatureExtractor() {\n            return _super.call(this, 'FaceFeatureExtractor') || this;\n        }\n        FaceFeatureExtractor.prototype.forwardInput = function (input) {\n            var params = this.params;\n            if (!params) {\n                throw new Error('FaceFeatureExtractor - load model before inference');\n            }\n            return tidy(function () {\n                var batchTensor = input.toBatchTensor(112, true);\n                var meanRgb = [122.782, 117.001, 104.298];\n                var normalized = normalize(batchTensor, meanRgb).div(scalar(255));\n                var out = denseBlock4(normalized, params.dense0, true);\n                out = denseBlock4(out, params.dense1);\n                out = denseBlock4(out, params.dense2);\n                out = denseBlock4(out, params.dense3);\n                out = avgPool(out, [7, 7], [2, 2], 'valid');\n                return out;\n            });\n        };\n        FaceFeatureExtractor.prototype.forward = function (input) {\n            return __awaiter$1(this, void 0, void 0, function () {\n                var _a;\n                return __generator$1(this, function (_b) {\n                    switch (_b.label) {\n                        case 0:\n                            _a = this.forwardInput;\n                            return [4 /*yield*/, toNetInput(input)];\n                        case 1: return [2 /*return*/, _a.apply(this, [_b.sent()])];\n                    }\n                });\n            });\n        };\n        FaceFeatureExtractor.prototype.getDefaultModelName = function () {\n            return 'face_feature_extractor_model';\n        };\n        FaceFeatureExtractor.prototype.extractParamsFromWeigthMap = function (weightMap) {\n            return extractParamsFromWeigthMap$1(weightMap);\n        };\n        FaceFeatureExtractor.prototype.extractParams = function (weights) {\n            return extractParams$1(weights);\n        };\n        return FaceFeatureExtractor;\n    }(NeuralNetwork));\n\n    function fullyConnectedLayer(x, params) {\n        return tidy(function () {\n            return add(matMul(x, params.weights), params.bias);\n        });\n    }\n\n    function extractParams$2(weights, channelsIn, channelsOut) {\n        var paramMappings = [];\n        var _a = extractWeightsFactory(weights), extractWeights = _a.extractWeights, getRemainingWeights = _a.getRemainingWeights;\n        var extractFCParams = extractFCParamsFactory(extractWeights, paramMappings);\n        var fc = extractFCParams(channelsIn, channelsOut, 'fc');\n        if (getRemainingWeights().length !== 0) {\n            throw new Error(\"weights remaing after extract: \" + getRemainingWeights().length);\n        }\n        return {\n            paramMappings: paramMappings,\n            params: { fc: fc }\n        };\n    }\n\n    function extractParamsFromWeigthMap$2(weightMap) {\n        var paramMappings = [];\n        var extractWeightEntry = extractWeightEntryFactory(weightMap, paramMappings);\n        function extractFcParams(prefix) {\n            var weights = extractWeightEntry(prefix + \"/weights\", 2);\n            var bias = extractWeightEntry(prefix + \"/bias\", 1);\n            return { weights: weights, bias: bias };\n        }\n        var params = {\n            fc: extractFcParams('fc')\n        };\n        disposeUnusedWeightTensors(weightMap, paramMappings);\n        return { params: params, paramMappings: paramMappings };\n    }\n\n    function seperateWeightMaps(weightMap) {\n        var featureExtractorMap = {};\n        var classifierMap = {};\n        Object.keys(weightMap).forEach(function (key) {\n            var map = key.startsWith('fc') ? classifierMap : featureExtractorMap;\n            map[key] = weightMap[key];\n        });\n        return { featureExtractorMap: featureExtractorMap, classifierMap: classifierMap };\n    }\n\n    var FaceProcessor = /** @class */ (function (_super) {\n        __extends$1(FaceProcessor, _super);\n        function FaceProcessor(_name, faceFeatureExtractor) {\n            var _this = _super.call(this, _name) || this;\n            _this._faceFeatureExtractor = faceFeatureExtractor;\n            return _this;\n        }\n        Object.defineProperty(FaceProcessor.prototype, \"faceFeatureExtractor\", {\n            get: function () {\n                return this._faceFeatureExtractor;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        FaceProcessor.prototype.runNet = function (input) {\n            var _this = this;\n            var params = this.params;\n            if (!params) {\n                throw new Error(this._name + \" - load model before inference\");\n            }\n            return tidy(function () {\n                var bottleneckFeatures = input instanceof NetInput\n                    ? _this.faceFeatureExtractor.forwardInput(input)\n                    : input;\n                return fullyConnectedLayer(bottleneckFeatures.as2D(bottleneckFeatures.shape[0], -1), params.fc);\n            });\n        };\n        FaceProcessor.prototype.dispose = function (throwOnRedispose) {\n            if (throwOnRedispose === void 0) { throwOnRedispose = true; }\n            this.faceFeatureExtractor.dispose(throwOnRedispose);\n            _super.prototype.dispose.call(this, throwOnRedispose);\n        };\n        FaceProcessor.prototype.loadClassifierParams = function (weights) {\n            var _a = this.extractClassifierParams(weights), params = _a.params, paramMappings = _a.paramMappings;\n            this._params = params;\n            this._paramMappings = paramMappings;\n        };\n        FaceProcessor.prototype.extractClassifierParams = function (weights) {\n            return extractParams$2(weights, this.getClassifierChannelsIn(), this.getClassifierChannelsOut());\n        };\n        FaceProcessor.prototype.extractParamsFromWeigthMap = function (weightMap) {\n            var _a = seperateWeightMaps(weightMap), featureExtractorMap = _a.featureExtractorMap, classifierMap = _a.classifierMap;\n            this.faceFeatureExtractor.loadFromWeightMap(featureExtractorMap);\n            return extractParamsFromWeigthMap$2(classifierMap);\n        };\n        FaceProcessor.prototype.extractParams = function (weights) {\n            var cIn = this.getClassifierChannelsIn();\n            var cOut = this.getClassifierChannelsOut();\n            var classifierWeightSize = (cOut * cIn) + cOut;\n            var featureExtractorWeights = weights.slice(0, weights.length - classifierWeightSize);\n            var classifierWeights = weights.slice(weights.length - classifierWeightSize);\n            this.faceFeatureExtractor.extractWeights(featureExtractorWeights);\n            return this.extractClassifierParams(classifierWeights);\n        };\n        return FaceProcessor;\n    }(NeuralNetwork));\n\n    var faceExpressionLabels = {\n        neutral: 0,\n        happy: 1,\n        sad: 2,\n        angry: 3,\n        fearful: 4,\n        disgusted: 5,\n        surprised: 6\n    };\n\n    var FaceExpressionNet = /** @class */ (function (_super) {\n        __extends$1(FaceExpressionNet, _super);\n        function FaceExpressionNet(faceFeatureExtractor) {\n            if (faceFeatureExtractor === void 0) { faceFeatureExtractor = new FaceFeatureExtractor(); }\n            return _super.call(this, 'FaceExpressionNet', faceFeatureExtractor) || this;\n        }\n        FaceExpressionNet.getFaceExpressionLabel = function (faceExpression) {\n            var label = faceExpressionLabels[faceExpression];\n            if (typeof label !== 'number') {\n                throw new Error(\"getFaceExpressionLabel - no label for faceExpression: \" + faceExpression);\n            }\n            return label;\n        };\n        FaceExpressionNet.decodeProbabilites = function (probabilities) {\n            if (probabilities.length !== 7) {\n                throw new Error(\"decodeProbabilites - expected probabilities.length to be 7, have: \" + probabilities.length);\n            }\n            return Object.keys(faceExpressionLabels)\n                .map(function (expression) { return ({ expression: expression, probability: probabilities[faceExpressionLabels[expression]] }); });\n        };\n        FaceExpressionNet.prototype.forwardInput = function (input) {\n            var _this = this;\n            return tidy(function () { return softmax(_this.runNet(input)); });\n        };\n        FaceExpressionNet.prototype.forward = function (input) {\n            return __awaiter$1(this, void 0, void 0, function () {\n                var _a;\n                return __generator$1(this, function (_b) {\n                    switch (_b.label) {\n                        case 0:\n                            _a = this.forwardInput;\n                            return [4 /*yield*/, toNetInput(input)];\n                        case 1: return [2 /*return*/, _a.apply(this, [_b.sent()])];\n                    }\n                });\n            });\n        };\n        FaceExpressionNet.prototype.predictExpressions = function (input) {\n            return __awaiter$1(this, void 0, void 0, function () {\n                var netInput, out, probabilitesByBatch, predictionsByBatch;\n                var _this = this;\n                return __generator$1(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, toNetInput(input)];\n                        case 1:\n                            netInput = _a.sent();\n                            return [4 /*yield*/, this.forwardInput(netInput)];\n                        case 2:\n                            out = _a.sent();\n                            return [4 /*yield*/, Promise.all(unstack(out).map(function (t) { return __awaiter$1(_this, void 0, void 0, function () {\n                                    var data;\n                                    return __generator$1(this, function (_a) {\n                                        switch (_a.label) {\n                                            case 0: return [4 /*yield*/, t.data()];\n                                            case 1:\n                                                data = _a.sent();\n                                                t.dispose();\n                                                return [2 /*return*/, data];\n                                        }\n                                    });\n                                }); }))];\n                        case 3:\n                            probabilitesByBatch = _a.sent();\n                            out.dispose();\n                            predictionsByBatch = probabilitesByBatch\n                                .map(function (propablities) { return FaceExpressionNet.decodeProbabilites(propablities); });\n                            return [2 /*return*/, netInput.isBatchInput\n                                    ? predictionsByBatch\n                                    : predictionsByBatch[0]];\n                    }\n                });\n            });\n        };\n        FaceExpressionNet.prototype.getDefaultModelName = function () {\n            return 'face_expression_model';\n        };\n        FaceExpressionNet.prototype.getClassifierChannelsIn = function () {\n            return 256;\n        };\n        FaceExpressionNet.prototype.getClassifierChannelsOut = function () {\n            return 7;\n        };\n        return FaceExpressionNet;\n    }(FaceProcessor));\n\n    var FaceLandmark68NetBase = /** @class */ (function (_super) {\n        __extends$1(FaceLandmark68NetBase, _super);\n        function FaceLandmark68NetBase() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        FaceLandmark68NetBase.prototype.postProcess = function (output, inputSize, originalDimensions) {\n            var inputDimensions = originalDimensions.map(function (_a) {\n                var width = _a.width, height = _a.height;\n                var scale = inputSize / Math.max(height, width);\n                return {\n                    width: width * scale,\n                    height: height * scale\n                };\n            });\n            var batchSize = inputDimensions.length;\n            return tidy(function () {\n                var createInterleavedTensor = function (fillX, fillY) {\n                    return stack([\n                        fill([68], fillX),\n                        fill([68], fillY)\n                    ], 1).as2D(1, 136).as1D();\n                };\n                var getPadding = function (batchIdx, cond) {\n                    var _a = inputDimensions[batchIdx], width = _a.width, height = _a.height;\n                    return cond(width, height) ? Math.abs(width - height) / 2 : 0;\n                };\n                var getPaddingX = function (batchIdx) { return getPadding(batchIdx, function (w, h) { return w < h; }); };\n                var getPaddingY = function (batchIdx) { return getPadding(batchIdx, function (w, h) { return h < w; }); };\n                var landmarkTensors = output\n                    .mul(fill([batchSize, 136], inputSize))\n                    .sub(stack(Array.from(Array(batchSize), function (_, batchIdx) {\n                    return createInterleavedTensor(getPaddingX(batchIdx), getPaddingY(batchIdx));\n                })))\n                    .div(stack(Array.from(Array(batchSize), function (_, batchIdx) {\n                    return createInterleavedTensor(inputDimensions[batchIdx].width, inputDimensions[batchIdx].height);\n                })));\n                return landmarkTensors;\n            });\n        };\n        FaceLandmark68NetBase.prototype.forwardInput = function (input) {\n            var _this = this;\n            return tidy(function () {\n                var out = _this.runNet(input);\n                return _this.postProcess(out, input.inputSize, input.inputDimensions.map(function (_a) {\n                    var height = _a[0], width = _a[1];\n                    return ({ height: height, width: width });\n                }));\n            });\n        };\n        FaceLandmark68NetBase.prototype.forward = function (input) {\n            return __awaiter$1(this, void 0, void 0, function () {\n                var _a;\n                return __generator$1(this, function (_b) {\n                    switch (_b.label) {\n                        case 0:\n                            _a = this.forwardInput;\n                            return [4 /*yield*/, toNetInput(input)];\n                        case 1: return [2 /*return*/, _a.apply(this, [_b.sent()])];\n                    }\n                });\n            });\n        };\n        FaceLandmark68NetBase.prototype.detectLandmarks = function (input) {\n            return __awaiter$1(this, void 0, void 0, function () {\n                var netInput, landmarkTensors, landmarksForBatch;\n                var _this = this;\n                return __generator$1(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, toNetInput(input)];\n                        case 1:\n                            netInput = _a.sent();\n                            landmarkTensors = tidy(function () { return unstack(_this.forwardInput(netInput)); });\n                            return [4 /*yield*/, Promise.all(landmarkTensors.map(function (landmarkTensor, batchIdx) { return __awaiter$1(_this, void 0, void 0, function () {\n                                    var landmarksArray, _a, _b, xCoords, yCoords;\n                                    return __generator$1(this, function (_c) {\n                                        switch (_c.label) {\n                                            case 0:\n                                                _b = (_a = Array).from;\n                                                return [4 /*yield*/, landmarkTensor.data()];\n                                            case 1:\n                                                landmarksArray = _b.apply(_a, [_c.sent()]);\n                                                xCoords = landmarksArray.filter(function (_, i) { return isEven$1(i); });\n                                                yCoords = landmarksArray.filter(function (_, i) { return !isEven$1(i); });\n                                                return [2 /*return*/, new FaceLandmarks68(Array(68).fill(0).map(function (_, i) { return new Point(xCoords[i], yCoords[i]); }), {\n                                                        height: netInput.getInputHeight(batchIdx),\n                                                        width: netInput.getInputWidth(batchIdx),\n                                                    })];\n                                        }\n                                    });\n                                }); }))];\n                        case 2:\n                            landmarksForBatch = _a.sent();\n                            landmarkTensors.forEach(function (t) { return t.dispose(); });\n                            return [2 /*return*/, netInput.isBatchInput\n                                    ? landmarksForBatch\n                                    : landmarksForBatch[0]];\n                    }\n                });\n            });\n        };\n        FaceLandmark68NetBase.prototype.getClassifierChannelsOut = function () {\n            return 136;\n        };\n        return FaceLandmark68NetBase;\n    }(FaceProcessor));\n\n    var FaceLandmark68Net = /** @class */ (function (_super) {\n        __extends$1(FaceLandmark68Net, _super);\n        function FaceLandmark68Net(faceFeatureExtractor) {\n            if (faceFeatureExtractor === void 0) { faceFeatureExtractor = new FaceFeatureExtractor(); }\n            return _super.call(this, 'FaceLandmark68Net', faceFeatureExtractor) || this;\n        }\n        FaceLandmark68Net.prototype.getDefaultModelName = function () {\n            return 'face_landmark_68_model';\n        };\n        FaceLandmark68Net.prototype.getClassifierChannelsIn = function () {\n            return 256;\n        };\n        return FaceLandmark68Net;\n    }(FaceLandmark68NetBase));\n\n    function extractParamsFromWeigthMapTiny(weightMap) {\n        var paramMappings = [];\n        var extractDenseBlock3Params = loadParamsFactory(weightMap, paramMappings).extractDenseBlock3Params;\n        var params = {\n            dense0: extractDenseBlock3Params('dense0', true),\n            dense1: extractDenseBlock3Params('dense1'),\n            dense2: extractDenseBlock3Params('dense2')\n        };\n        disposeUnusedWeightTensors(weightMap, paramMappings);\n        return { params: params, paramMappings: paramMappings };\n    }\n\n    function extractParamsTiny(weights) {\n        var paramMappings = [];\n        var _a = extractWeightsFactory(weights), extractWeights = _a.extractWeights, getRemainingWeights = _a.getRemainingWeights;\n        var extractDenseBlock3Params = extractorsFactory$2(extractWeights, paramMappings).extractDenseBlock3Params;\n        var dense0 = extractDenseBlock3Params(3, 32, 'dense0', true);\n        var dense1 = extractDenseBlock3Params(32, 64, 'dense1');\n        var dense2 = extractDenseBlock3Params(64, 128, 'dense2');\n        if (getRemainingWeights().length !== 0) {\n            throw new Error(\"weights remaing after extract: \" + getRemainingWeights().length);\n        }\n        return {\n            paramMappings: paramMappings,\n            params: { dense0: dense0, dense1: dense1, dense2: dense2 }\n        };\n    }\n\n    var TinyFaceFeatureExtractor = /** @class */ (function (_super) {\n        __extends$1(TinyFaceFeatureExtractor, _super);\n        function TinyFaceFeatureExtractor() {\n            return _super.call(this, 'TinyFaceFeatureExtractor') || this;\n        }\n        TinyFaceFeatureExtractor.prototype.forwardInput = function (input) {\n            var params = this.params;\n            if (!params) {\n                throw new Error('TinyFaceFeatureExtractor - load model before inference');\n            }\n            return tidy(function () {\n                var batchTensor = input.toBatchTensor(112, true);\n                var meanRgb = [122.782, 117.001, 104.298];\n                var normalized = normalize(batchTensor, meanRgb).div(scalar(255));\n                var out = denseBlock3(normalized, params.dense0, true);\n                out = denseBlock3(out, params.dense1);\n                out = denseBlock3(out, params.dense2);\n                out = avgPool(out, [14, 14], [2, 2], 'valid');\n                return out;\n            });\n        };\n        TinyFaceFeatureExtractor.prototype.forward = function (input) {\n            return __awaiter$1(this, void 0, void 0, function () {\n                var _a;\n                return __generator$1(this, function (_b) {\n                    switch (_b.label) {\n                        case 0:\n                            _a = this.forwardInput;\n                            return [4 /*yield*/, toNetInput(input)];\n                        case 1: return [2 /*return*/, _a.apply(this, [_b.sent()])];\n                    }\n                });\n            });\n        };\n        TinyFaceFeatureExtractor.prototype.getDefaultModelName = function () {\n            return 'face_feature_extractor_tiny_model';\n        };\n        TinyFaceFeatureExtractor.prototype.extractParamsFromWeigthMap = function (weightMap) {\n            return extractParamsFromWeigthMapTiny(weightMap);\n        };\n        TinyFaceFeatureExtractor.prototype.extractParams = function (weights) {\n            return extractParamsTiny(weights);\n        };\n        return TinyFaceFeatureExtractor;\n    }(NeuralNetwork));\n\n    var FaceLandmark68TinyNet = /** @class */ (function (_super) {\n        __extends$1(FaceLandmark68TinyNet, _super);\n        function FaceLandmark68TinyNet(faceFeatureExtractor) {\n            if (faceFeatureExtractor === void 0) { faceFeatureExtractor = new TinyFaceFeatureExtractor(); }\n            return _super.call(this, 'FaceLandmark68TinyNet', faceFeatureExtractor) || this;\n        }\n        FaceLandmark68TinyNet.prototype.getDefaultModelName = function () {\n            return 'face_landmark_68_tiny_model';\n        };\n        FaceLandmark68TinyNet.prototype.getClassifierChannelsIn = function () {\n            return 128;\n        };\n        return FaceLandmark68TinyNet;\n    }(FaceLandmark68NetBase));\n\n    var FaceLandmarkNet = /** @class */ (function (_super) {\n        __extends$1(FaceLandmarkNet, _super);\n        function FaceLandmarkNet() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        return FaceLandmarkNet;\n    }(FaceLandmark68Net));\n\n    function scale(x, params) {\n        return add(mul(x, params.weights), params.biases);\n    }\n\n    function convLayer$1(x, params, strides, withRelu, padding) {\n        if (padding === void 0) { padding = 'same'; }\n        var _a = params.conv, filters = _a.filters, bias = _a.bias;\n        var out = conv2d(x, filters, strides, padding);\n        out = add(out, bias);\n        out = scale(out, params.scale);\n        return withRelu ? relu(out) : out;\n    }\n    function conv(x, params) {\n        return convLayer$1(x, params, [1, 1], true);\n    }\n    function convNoRelu(x, params) {\n        return convLayer$1(x, params, [1, 1], false);\n    }\n    function convDown(x, params) {\n        return convLayer$1(x, params, [2, 2], true, 'valid');\n    }\n\n    function extractorsFactory$3(extractWeights, paramMappings) {\n        function extractFilterValues(numFilterValues, numFilters, filterSize) {\n            var weights = extractWeights(numFilterValues);\n            var depth = weights.length / (numFilters * filterSize * filterSize);\n            if (isFloat(depth)) {\n                throw new Error(\"depth has to be an integer: \" + depth + \", weights.length: \" + weights.length + \", numFilters: \" + numFilters + \", filterSize: \" + filterSize);\n            }\n            return tidy(function () { return transpose(tensor4d(weights, [numFilters, depth, filterSize, filterSize]), [2, 3, 1, 0]); });\n        }\n        function extractConvParams(numFilterValues, numFilters, filterSize, mappedPrefix) {\n            var filters = extractFilterValues(numFilterValues, numFilters, filterSize);\n            var bias = tensor1d(extractWeights(numFilters));\n            paramMappings.push({ paramPath: mappedPrefix + \"/filters\" }, { paramPath: mappedPrefix + \"/bias\" });\n            return { filters: filters, bias: bias };\n        }\n        function extractScaleLayerParams(numWeights, mappedPrefix) {\n            var weights = tensor1d(extractWeights(numWeights));\n            var biases = tensor1d(extractWeights(numWeights));\n            paramMappings.push({ paramPath: mappedPrefix + \"/weights\" }, { paramPath: mappedPrefix + \"/biases\" });\n            return {\n                weights: weights,\n                biases: biases\n            };\n        }\n        function extractConvLayerParams(numFilterValues, numFilters, filterSize, mappedPrefix) {\n            var conv = extractConvParams(numFilterValues, numFilters, filterSize, mappedPrefix + \"/conv\");\n            var scale = extractScaleLayerParams(numFilters, mappedPrefix + \"/scale\");\n            return { conv: conv, scale: scale };\n        }\n        function extractResidualLayerParams(numFilterValues, numFilters, filterSize, mappedPrefix, isDown) {\n            if (isDown === void 0) { isDown = false; }\n            var conv1 = extractConvLayerParams((isDown ? 0.5 : 1) * numFilterValues, numFilters, filterSize, mappedPrefix + \"/conv1\");\n            var conv2 = extractConvLayerParams(numFilterValues, numFilters, filterSize, mappedPrefix + \"/conv2\");\n            return { conv1: conv1, conv2: conv2 };\n        }\n        return {\n            extractConvLayerParams: extractConvLayerParams,\n            extractResidualLayerParams: extractResidualLayerParams\n        };\n    }\n    function extractParams$3(weights) {\n        var _a = extractWeightsFactory(weights), extractWeights = _a.extractWeights, getRemainingWeights = _a.getRemainingWeights;\n        var paramMappings = [];\n        var _b = extractorsFactory$3(extractWeights, paramMappings), extractConvLayerParams = _b.extractConvLayerParams, extractResidualLayerParams = _b.extractResidualLayerParams;\n        var conv32_down = extractConvLayerParams(4704, 32, 7, 'conv32_down');\n        var conv32_1 = extractResidualLayerParams(9216, 32, 3, 'conv32_1');\n        var conv32_2 = extractResidualLayerParams(9216, 32, 3, 'conv32_2');\n        var conv32_3 = extractResidualLayerParams(9216, 32, 3, 'conv32_3');\n        var conv64_down = extractResidualLayerParams(36864, 64, 3, 'conv64_down', true);\n        var conv64_1 = extractResidualLayerParams(36864, 64, 3, 'conv64_1');\n        var conv64_2 = extractResidualLayerParams(36864, 64, 3, 'conv64_2');\n        var conv64_3 = extractResidualLayerParams(36864, 64, 3, 'conv64_3');\n        var conv128_down = extractResidualLayerParams(147456, 128, 3, 'conv128_down', true);\n        var conv128_1 = extractResidualLayerParams(147456, 128, 3, 'conv128_1');\n        var conv128_2 = extractResidualLayerParams(147456, 128, 3, 'conv128_2');\n        var conv256_down = extractResidualLayerParams(589824, 256, 3, 'conv256_down', true);\n        var conv256_1 = extractResidualLayerParams(589824, 256, 3, 'conv256_1');\n        var conv256_2 = extractResidualLayerParams(589824, 256, 3, 'conv256_2');\n        var conv256_down_out = extractResidualLayerParams(589824, 256, 3, 'conv256_down_out');\n        var fc = tidy(function () { return transpose(tensor2d(extractWeights(256 * 128), [128, 256]), [1, 0]); });\n        paramMappings.push({ paramPath: \"fc\" });\n        if (getRemainingWeights().length !== 0) {\n            throw new Error(\"weights remaing after extract: \" + getRemainingWeights().length);\n        }\n        var params = {\n            conv32_down: conv32_down,\n            conv32_1: conv32_1,\n            conv32_2: conv32_2,\n            conv32_3: conv32_3,\n            conv64_down: conv64_down,\n            conv64_1: conv64_1,\n            conv64_2: conv64_2,\n            conv64_3: conv64_3,\n            conv128_down: conv128_down,\n            conv128_1: conv128_1,\n            conv128_2: conv128_2,\n            conv256_down: conv256_down,\n            conv256_1: conv256_1,\n            conv256_2: conv256_2,\n            conv256_down_out: conv256_down_out,\n            fc: fc\n        };\n        return { params: params, paramMappings: paramMappings };\n    }\n\n    function extractorsFactory$4(weightMap, paramMappings) {\n        var extractWeightEntry = extractWeightEntryFactory(weightMap, paramMappings);\n        function extractScaleLayerParams(prefix) {\n            var weights = extractWeightEntry(prefix + \"/scale/weights\", 1);\n            var biases = extractWeightEntry(prefix + \"/scale/biases\", 1);\n            return { weights: weights, biases: biases };\n        }\n        function extractConvLayerParams(prefix) {\n            var filters = extractWeightEntry(prefix + \"/conv/filters\", 4);\n            var bias = extractWeightEntry(prefix + \"/conv/bias\", 1);\n            var scale = extractScaleLayerParams(prefix);\n            return { conv: { filters: filters, bias: bias }, scale: scale };\n        }\n        function extractResidualLayerParams(prefix) {\n            return {\n                conv1: extractConvLayerParams(prefix + \"/conv1\"),\n                conv2: extractConvLayerParams(prefix + \"/conv2\")\n            };\n        }\n        return {\n            extractConvLayerParams: extractConvLayerParams,\n            extractResidualLayerParams: extractResidualLayerParams\n        };\n    }\n    function extractParamsFromWeigthMap$3(weightMap) {\n        var paramMappings = [];\n        var _a = extractorsFactory$4(weightMap, paramMappings), extractConvLayerParams = _a.extractConvLayerParams, extractResidualLayerParams = _a.extractResidualLayerParams;\n        var conv32_down = extractConvLayerParams('conv32_down');\n        var conv32_1 = extractResidualLayerParams('conv32_1');\n        var conv32_2 = extractResidualLayerParams('conv32_2');\n        var conv32_3 = extractResidualLayerParams('conv32_3');\n        var conv64_down = extractResidualLayerParams('conv64_down');\n        var conv64_1 = extractResidualLayerParams('conv64_1');\n        var conv64_2 = extractResidualLayerParams('conv64_2');\n        var conv64_3 = extractResidualLayerParams('conv64_3');\n        var conv128_down = extractResidualLayerParams('conv128_down');\n        var conv128_1 = extractResidualLayerParams('conv128_1');\n        var conv128_2 = extractResidualLayerParams('conv128_2');\n        var conv256_down = extractResidualLayerParams('conv256_down');\n        var conv256_1 = extractResidualLayerParams('conv256_1');\n        var conv256_2 = extractResidualLayerParams('conv256_2');\n        var conv256_down_out = extractResidualLayerParams('conv256_down_out');\n        var fc = weightMap['fc'];\n        paramMappings.push({ originalPath: 'fc', paramPath: 'fc' });\n        if (!isTensor2D(fc)) {\n            throw new Error(\"expected weightMap[fc] to be a Tensor2D, instead have \" + fc);\n        }\n        var params = {\n            conv32_down: conv32_down,\n            conv32_1: conv32_1,\n            conv32_2: conv32_2,\n            conv32_3: conv32_3,\n            conv64_down: conv64_down,\n            conv64_1: conv64_1,\n            conv64_2: conv64_2,\n            conv64_3: conv64_3,\n            conv128_down: conv128_down,\n            conv128_1: conv128_1,\n            conv128_2: conv128_2,\n            conv256_down: conv256_down,\n            conv256_1: conv256_1,\n            conv256_2: conv256_2,\n            conv256_down_out: conv256_down_out,\n            fc: fc\n        };\n        disposeUnusedWeightTensors(weightMap, paramMappings);\n        return { params: params, paramMappings: paramMappings };\n    }\n\n    function residual(x, params) {\n        var out = conv(x, params.conv1);\n        out = convNoRelu(out, params.conv2);\n        out = add(out, x);\n        out = relu(out);\n        return out;\n    }\n    function residualDown(x, params) {\n        var out = convDown(x, params.conv1);\n        out = convNoRelu(out, params.conv2);\n        var pooled = avgPool(x, 2, 2, 'valid');\n        var zeros$$1 = zeros(pooled.shape);\n        var isPad = pooled.shape[3] !== out.shape[3];\n        var isAdjustShape = pooled.shape[1] !== out.shape[1] || pooled.shape[2] !== out.shape[2];\n        if (isAdjustShape) {\n            var padShapeX = out.shape.slice();\n            padShapeX[1] = 1;\n            var zerosW = zeros(padShapeX);\n            out = concat([out, zerosW], 1);\n            var padShapeY = out.shape.slice();\n            padShapeY[2] = 1;\n            var zerosH = zeros(padShapeY);\n            out = concat([out, zerosH], 2);\n        }\n        pooled = isPad ? concat([pooled, zeros$$1], 3) : pooled;\n        out = add(pooled, out);\n        out = relu(out);\n        return out;\n    }\n\n    var FaceRecognitionNet = /** @class */ (function (_super) {\n        __extends$1(FaceRecognitionNet, _super);\n        function FaceRecognitionNet() {\n            return _super.call(this, 'FaceRecognitionNet') || this;\n        }\n        FaceRecognitionNet.prototype.forwardInput = function (input) {\n            var params = this.params;\n            if (!params) {\n                throw new Error('FaceRecognitionNet - load model before inference');\n            }\n            return tidy(function () {\n                var batchTensor = input.toBatchTensor(150, true).toFloat();\n                var meanRgb = [122.782, 117.001, 104.298];\n                var normalized = normalize(batchTensor, meanRgb).div(scalar(256));\n                var out = convDown(normalized, params.conv32_down);\n                out = maxPool(out, 3, 2, 'valid');\n                out = residual(out, params.conv32_1);\n                out = residual(out, params.conv32_2);\n                out = residual(out, params.conv32_3);\n                out = residualDown(out, params.conv64_down);\n                out = residual(out, params.conv64_1);\n                out = residual(out, params.conv64_2);\n                out = residual(out, params.conv64_3);\n                out = residualDown(out, params.conv128_down);\n                out = residual(out, params.conv128_1);\n                out = residual(out, params.conv128_2);\n                out = residualDown(out, params.conv256_down);\n                out = residual(out, params.conv256_1);\n                out = residual(out, params.conv256_2);\n                out = residualDown(out, params.conv256_down_out);\n                var globalAvg = out.mean([1, 2]);\n                var fullyConnected = matMul(globalAvg, params.fc);\n                return fullyConnected;\n            });\n        };\n        FaceRecognitionNet.prototype.forward = function (input) {\n            return __awaiter$1(this, void 0, void 0, function () {\n                var _a;\n                return __generator$1(this, function (_b) {\n                    switch (_b.label) {\n                        case 0:\n                            _a = this.forwardInput;\n                            return [4 /*yield*/, toNetInput(input)];\n                        case 1: return [2 /*return*/, _a.apply(this, [_b.sent()])];\n                    }\n                });\n            });\n        };\n        FaceRecognitionNet.prototype.computeFaceDescriptor = function (input) {\n            return __awaiter$1(this, void 0, void 0, function () {\n                var netInput, faceDescriptorTensors, faceDescriptorsForBatch;\n                var _this = this;\n                return __generator$1(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, toNetInput(input)];\n                        case 1:\n                            netInput = _a.sent();\n                            faceDescriptorTensors = tidy(function () { return unstack(_this.forwardInput(netInput)); });\n                            return [4 /*yield*/, Promise.all(faceDescriptorTensors.map(function (t) { return t.data(); }))];\n                        case 2:\n                            faceDescriptorsForBatch = _a.sent();\n                            faceDescriptorTensors.forEach(function (t) { return t.dispose(); });\n                            return [2 /*return*/, netInput.isBatchInput\n                                    ? faceDescriptorsForBatch\n                                    : faceDescriptorsForBatch[0]];\n                    }\n                });\n            });\n        };\n        FaceRecognitionNet.prototype.getDefaultModelName = function () {\n            return 'face_recognition_model';\n        };\n        FaceRecognitionNet.prototype.extractParamsFromWeigthMap = function (weightMap) {\n            return extractParamsFromWeigthMap$3(weightMap);\n        };\n        FaceRecognitionNet.prototype.extractParams = function (weights) {\n            return extractParams$3(weights);\n        };\n        return FaceRecognitionNet;\n    }(NeuralNetwork));\n\n    function createFaceRecognitionNet(weights) {\n        var net = new FaceRecognitionNet();\n        net.extractWeights(weights);\n        return net;\n    }\n\n    function extendWithFaceDescriptor(sourceObj, descriptor) {\n        var extension = { descriptor: descriptor };\n        return Object.assign({}, sourceObj, extension);\n    }\n\n    function extendWithFaceDetection(sourceObj, detection) {\n        var extension = { detection: detection };\n        return Object.assign({}, sourceObj, extension);\n    }\n\n    function extendWithFaceExpressions(sourceObj, expressions) {\n        var extension = { expressions: expressions };\n        return Object.assign({}, sourceObj, extension);\n    }\n\n    function extendWithFaceLandmarks(sourceObj, unshiftedLandmarks) {\n        var shift = sourceObj.detection.box;\n        var landmarks = unshiftedLandmarks.shiftBy(shift.x, shift.y);\n        var rect = landmarks.align();\n        var imageDims = sourceObj.detection.imageDims;\n        var alignedRect = new FaceDetection(sourceObj.detection.score, rect.rescale(imageDims.reverse()), imageDims);\n        var extension = {\n            landmarks: landmarks,\n            unshiftedLandmarks: unshiftedLandmarks,\n            alignedRect: alignedRect\n        };\n        return Object.assign({}, sourceObj, extension);\n    }\n\n    var MtcnnOptions = /** @class */ (function () {\n        function MtcnnOptions(_a) {\n            var _b = _a === void 0 ? {} : _a, minFaceSize = _b.minFaceSize, scaleFactor = _b.scaleFactor, maxNumScales = _b.maxNumScales, scoreThresholds = _b.scoreThresholds, scaleSteps = _b.scaleSteps;\n            this._name = 'MtcnnOptions';\n            this._minFaceSize = minFaceSize || 20;\n            this._scaleFactor = scaleFactor || 0.709;\n            this._maxNumScales = maxNumScales || 10;\n            this._scoreThresholds = scoreThresholds || [0.6, 0.7, 0.7];\n            this._scaleSteps = scaleSteps;\n            if (typeof this._minFaceSize !== 'number' || this._minFaceSize < 0) {\n                throw new Error(this._name + \" - expected minFaceSize to be a number > 0\");\n            }\n            if (typeof this._scaleFactor !== 'number' || this._scaleFactor <= 0 || this._scaleFactor >= 1) {\n                throw new Error(this._name + \" - expected scaleFactor to be a number between 0 and 1\");\n            }\n            if (typeof this._maxNumScales !== 'number' || this._maxNumScales < 0) {\n                throw new Error(this._name + \" - expected maxNumScales to be a number > 0\");\n            }\n            if (!Array.isArray(this._scoreThresholds)\n                || this._scoreThresholds.length !== 3\n                || this._scoreThresholds.some(function (th) { return typeof th !== 'number'; })) {\n                throw new Error(this._name + \" - expected scoreThresholds to be an array of numbers of length 3\");\n            }\n            if (this._scaleSteps\n                && (!Array.isArray(this._scaleSteps) || this._scaleSteps.some(function (th) { return typeof th !== 'number'; }))) {\n                throw new Error(this._name + \" - expected scaleSteps to be an array of numbers\");\n            }\n        }\n        Object.defineProperty(MtcnnOptions.prototype, \"minFaceSize\", {\n            get: function () { return this._minFaceSize; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MtcnnOptions.prototype, \"scaleFactor\", {\n            get: function () { return this._scaleFactor; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MtcnnOptions.prototype, \"maxNumScales\", {\n            get: function () { return this._maxNumScales; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MtcnnOptions.prototype, \"scoreThresholds\", {\n            get: function () { return this._scoreThresholds; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MtcnnOptions.prototype, \"scaleSteps\", {\n            get: function () { return this._scaleSteps; },\n            enumerable: true,\n            configurable: true\n        });\n        return MtcnnOptions;\n    }());\n\n    function extractorsFactory$5(extractWeights, paramMappings) {\n        function extractDepthwiseConvParams(numChannels, mappedPrefix) {\n            var filters = tensor4d(extractWeights(3 * 3 * numChannels), [3, 3, numChannels, 1]);\n            var batch_norm_scale = tensor1d(extractWeights(numChannels));\n            var batch_norm_offset = tensor1d(extractWeights(numChannels));\n            var batch_norm_mean = tensor1d(extractWeights(numChannels));\n            var batch_norm_variance = tensor1d(extractWeights(numChannels));\n            paramMappings.push({ paramPath: mappedPrefix + \"/filters\" }, { paramPath: mappedPrefix + \"/batch_norm_scale\" }, { paramPath: mappedPrefix + \"/batch_norm_offset\" }, { paramPath: mappedPrefix + \"/batch_norm_mean\" }, { paramPath: mappedPrefix + \"/batch_norm_variance\" });\n            return {\n                filters: filters,\n                batch_norm_scale: batch_norm_scale,\n                batch_norm_offset: batch_norm_offset,\n                batch_norm_mean: batch_norm_mean,\n                batch_norm_variance: batch_norm_variance\n            };\n        }\n        function extractConvParams(channelsIn, channelsOut, filterSize, mappedPrefix, isPointwiseConv) {\n            var filters = tensor4d(extractWeights(channelsIn * channelsOut * filterSize * filterSize), [filterSize, filterSize, channelsIn, channelsOut]);\n            var bias = tensor1d(extractWeights(channelsOut));\n            paramMappings.push({ paramPath: mappedPrefix + \"/filters\" }, { paramPath: mappedPrefix + \"/\" + (isPointwiseConv ? 'batch_norm_offset' : 'bias') });\n            return { filters: filters, bias: bias };\n        }\n        function extractPointwiseConvParams(channelsIn, channelsOut, filterSize, mappedPrefix) {\n            var _a = extractConvParams(channelsIn, channelsOut, filterSize, mappedPrefix, true), filters = _a.filters, bias = _a.bias;\n            return {\n                filters: filters,\n                batch_norm_offset: bias\n            };\n        }\n        function extractConvPairParams(channelsIn, channelsOut, mappedPrefix) {\n            var depthwise_conv = extractDepthwiseConvParams(channelsIn, mappedPrefix + \"/depthwise_conv\");\n            var pointwise_conv = extractPointwiseConvParams(channelsIn, channelsOut, 1, mappedPrefix + \"/pointwise_conv\");\n            return { depthwise_conv: depthwise_conv, pointwise_conv: pointwise_conv };\n        }\n        function extractMobilenetV1Params() {\n            var conv_0 = extractPointwiseConvParams(3, 32, 3, 'mobilenetv1/conv_0');\n            var conv_1 = extractConvPairParams(32, 64, 'mobilenetv1/conv_1');\n            var conv_2 = extractConvPairParams(64, 128, 'mobilenetv1/conv_2');\n            var conv_3 = extractConvPairParams(128, 128, 'mobilenetv1/conv_3');\n            var conv_4 = extractConvPairParams(128, 256, 'mobilenetv1/conv_4');\n            var conv_5 = extractConvPairParams(256, 256, 'mobilenetv1/conv_5');\n            var conv_6 = extractConvPairParams(256, 512, 'mobilenetv1/conv_6');\n            var conv_7 = extractConvPairParams(512, 512, 'mobilenetv1/conv_7');\n            var conv_8 = extractConvPairParams(512, 512, 'mobilenetv1/conv_8');\n            var conv_9 = extractConvPairParams(512, 512, 'mobilenetv1/conv_9');\n            var conv_10 = extractConvPairParams(512, 512, 'mobilenetv1/conv_10');\n            var conv_11 = extractConvPairParams(512, 512, 'mobilenetv1/conv_11');\n            var conv_12 = extractConvPairParams(512, 1024, 'mobilenetv1/conv_12');\n            var conv_13 = extractConvPairParams(1024, 1024, 'mobilenetv1/conv_13');\n            return {\n                conv_0: conv_0,\n                conv_1: conv_1,\n                conv_2: conv_2,\n                conv_3: conv_3,\n                conv_4: conv_4,\n                conv_5: conv_5,\n                conv_6: conv_6,\n                conv_7: conv_7,\n                conv_8: conv_8,\n                conv_9: conv_9,\n                conv_10: conv_10,\n                conv_11: conv_11,\n                conv_12: conv_12,\n                conv_13: conv_13\n            };\n        }\n        function extractPredictionLayerParams() {\n            var conv_0 = extractPointwiseConvParams(1024, 256, 1, 'prediction_layer/conv_0');\n            var conv_1 = extractPointwiseConvParams(256, 512, 3, 'prediction_layer/conv_1');\n            var conv_2 = extractPointwiseConvParams(512, 128, 1, 'prediction_layer/conv_2');\n            var conv_3 = extractPointwiseConvParams(128, 256, 3, 'prediction_layer/conv_3');\n            var conv_4 = extractPointwiseConvParams(256, 128, 1, 'prediction_layer/conv_4');\n            var conv_5 = extractPointwiseConvParams(128, 256, 3, 'prediction_layer/conv_5');\n            var conv_6 = extractPointwiseConvParams(256, 64, 1, 'prediction_layer/conv_6');\n            var conv_7 = extractPointwiseConvParams(64, 128, 3, 'prediction_layer/conv_7');\n            var box_encoding_0_predictor = extractConvParams(512, 12, 1, 'prediction_layer/box_predictor_0/box_encoding_predictor');\n            var class_predictor_0 = extractConvParams(512, 9, 1, 'prediction_layer/box_predictor_0/class_predictor');\n            var box_encoding_1_predictor = extractConvParams(1024, 24, 1, 'prediction_layer/box_predictor_1/box_encoding_predictor');\n            var class_predictor_1 = extractConvParams(1024, 18, 1, 'prediction_layer/box_predictor_1/class_predictor');\n            var box_encoding_2_predictor = extractConvParams(512, 24, 1, 'prediction_layer/box_predictor_2/box_encoding_predictor');\n            var class_predictor_2 = extractConvParams(512, 18, 1, 'prediction_layer/box_predictor_2/class_predictor');\n            var box_encoding_3_predictor = extractConvParams(256, 24, 1, 'prediction_layer/box_predictor_3/box_encoding_predictor');\n            var class_predictor_3 = extractConvParams(256, 18, 1, 'prediction_layer/box_predictor_3/class_predictor');\n            var box_encoding_4_predictor = extractConvParams(256, 24, 1, 'prediction_layer/box_predictor_4/box_encoding_predictor');\n            var class_predictor_4 = extractConvParams(256, 18, 1, 'prediction_layer/box_predictor_4/class_predictor');\n            var box_encoding_5_predictor = extractConvParams(128, 24, 1, 'prediction_layer/box_predictor_5/box_encoding_predictor');\n            var class_predictor_5 = extractConvParams(128, 18, 1, 'prediction_layer/box_predictor_5/class_predictor');\n            var box_predictor_0 = {\n                box_encoding_predictor: box_encoding_0_predictor,\n                class_predictor: class_predictor_0\n            };\n            var box_predictor_1 = {\n                box_encoding_predictor: box_encoding_1_predictor,\n                class_predictor: class_predictor_1\n            };\n            var box_predictor_2 = {\n                box_encoding_predictor: box_encoding_2_predictor,\n                class_predictor: class_predictor_2\n            };\n            var box_predictor_3 = {\n                box_encoding_predictor: box_encoding_3_predictor,\n                class_predictor: class_predictor_3\n            };\n            var box_predictor_4 = {\n                box_encoding_predictor: box_encoding_4_predictor,\n                class_predictor: class_predictor_4\n            };\n            var box_predictor_5 = {\n                box_encoding_predictor: box_encoding_5_predictor,\n                class_predictor: class_predictor_5\n            };\n            return {\n                conv_0: conv_0,\n                conv_1: conv_1,\n                conv_2: conv_2,\n                conv_3: conv_3,\n                conv_4: conv_4,\n                conv_5: conv_5,\n                conv_6: conv_6,\n                conv_7: conv_7,\n                box_predictor_0: box_predictor_0,\n                box_predictor_1: box_predictor_1,\n                box_predictor_2: box_predictor_2,\n                box_predictor_3: box_predictor_3,\n                box_predictor_4: box_predictor_4,\n                box_predictor_5: box_predictor_5\n            };\n        }\n        return {\n            extractMobilenetV1Params: extractMobilenetV1Params,\n            extractPredictionLayerParams: extractPredictionLayerParams\n        };\n    }\n    function extractParams$4(weights) {\n        var paramMappings = [];\n        var _a = extractWeightsFactory(weights), extractWeights = _a.extractWeights, getRemainingWeights = _a.getRemainingWeights;\n        var _b = extractorsFactory$5(extractWeights, paramMappings), extractMobilenetV1Params = _b.extractMobilenetV1Params, extractPredictionLayerParams = _b.extractPredictionLayerParams;\n        var mobilenetv1 = extractMobilenetV1Params();\n        var prediction_layer = extractPredictionLayerParams();\n        var extra_dim = tensor3d(extractWeights(5118 * 4), [1, 5118, 4]);\n        var output_layer = {\n            extra_dim: extra_dim\n        };\n        paramMappings.push({ paramPath: 'output_layer/extra_dim' });\n        if (getRemainingWeights().length !== 0) {\n            throw new Error(\"weights remaing after extract: \" + getRemainingWeights().length);\n        }\n        return {\n            params: {\n                mobilenetv1: mobilenetv1,\n                prediction_layer: prediction_layer,\n                output_layer: output_layer\n            },\n            paramMappings: paramMappings\n        };\n    }\n\n    function extractorsFactory$6(weightMap, paramMappings) {\n        var extractWeightEntry = extractWeightEntryFactory(weightMap, paramMappings);\n        function extractPointwiseConvParams(prefix, idx, mappedPrefix) {\n            var filters = extractWeightEntry(prefix + \"/Conv2d_\" + idx + \"_pointwise/weights\", 4, mappedPrefix + \"/filters\");\n            var batch_norm_offset = extractWeightEntry(prefix + \"/Conv2d_\" + idx + \"_pointwise/convolution_bn_offset\", 1, mappedPrefix + \"/batch_norm_offset\");\n            return { filters: filters, batch_norm_offset: batch_norm_offset };\n        }\n        function extractConvPairParams(idx) {\n            var mappedPrefix = \"mobilenetv1/conv_\" + idx;\n            var prefixDepthwiseConv = \"MobilenetV1/Conv2d_\" + idx + \"_depthwise\";\n            var mappedPrefixDepthwiseConv = mappedPrefix + \"/depthwise_conv\";\n            var mappedPrefixPointwiseConv = mappedPrefix + \"/pointwise_conv\";\n            var filters = extractWeightEntry(prefixDepthwiseConv + \"/depthwise_weights\", 4, mappedPrefixDepthwiseConv + \"/filters\");\n            var batch_norm_scale = extractWeightEntry(prefixDepthwiseConv + \"/BatchNorm/gamma\", 1, mappedPrefixDepthwiseConv + \"/batch_norm_scale\");\n            var batch_norm_offset = extractWeightEntry(prefixDepthwiseConv + \"/BatchNorm/beta\", 1, mappedPrefixDepthwiseConv + \"/batch_norm_offset\");\n            var batch_norm_mean = extractWeightEntry(prefixDepthwiseConv + \"/BatchNorm/moving_mean\", 1, mappedPrefixDepthwiseConv + \"/batch_norm_mean\");\n            var batch_norm_variance = extractWeightEntry(prefixDepthwiseConv + \"/BatchNorm/moving_variance\", 1, mappedPrefixDepthwiseConv + \"/batch_norm_variance\");\n            return {\n                depthwise_conv: {\n                    filters: filters,\n                    batch_norm_scale: batch_norm_scale,\n                    batch_norm_offset: batch_norm_offset,\n                    batch_norm_mean: batch_norm_mean,\n                    batch_norm_variance: batch_norm_variance\n                },\n                pointwise_conv: extractPointwiseConvParams('MobilenetV1', idx, mappedPrefixPointwiseConv)\n            };\n        }\n        function extractMobilenetV1Params() {\n            return {\n                conv_0: extractPointwiseConvParams('MobilenetV1', 0, 'mobilenetv1/conv_0'),\n                conv_1: extractConvPairParams(1),\n                conv_2: extractConvPairParams(2),\n                conv_3: extractConvPairParams(3),\n                conv_4: extractConvPairParams(4),\n                conv_5: extractConvPairParams(5),\n                conv_6: extractConvPairParams(6),\n                conv_7: extractConvPairParams(7),\n                conv_8: extractConvPairParams(8),\n                conv_9: extractConvPairParams(9),\n                conv_10: extractConvPairParams(10),\n                conv_11: extractConvPairParams(11),\n                conv_12: extractConvPairParams(12),\n                conv_13: extractConvPairParams(13)\n            };\n        }\n        function extractConvParams(prefix, mappedPrefix) {\n            var filters = extractWeightEntry(prefix + \"/weights\", 4, mappedPrefix + \"/filters\");\n            var bias = extractWeightEntry(prefix + \"/biases\", 1, mappedPrefix + \"/bias\");\n            return { filters: filters, bias: bias };\n        }\n        function extractBoxPredictorParams(idx) {\n            var box_encoding_predictor = extractConvParams(\"Prediction/BoxPredictor_\" + idx + \"/BoxEncodingPredictor\", \"prediction_layer/box_predictor_\" + idx + \"/box_encoding_predictor\");\n            var class_predictor = extractConvParams(\"Prediction/BoxPredictor_\" + idx + \"/ClassPredictor\", \"prediction_layer/box_predictor_\" + idx + \"/class_predictor\");\n            return { box_encoding_predictor: box_encoding_predictor, class_predictor: class_predictor };\n        }\n        function extractPredictionLayerParams() {\n            return {\n                conv_0: extractPointwiseConvParams('Prediction', 0, 'prediction_layer/conv_0'),\n                conv_1: extractPointwiseConvParams('Prediction', 1, 'prediction_layer/conv_1'),\n                conv_2: extractPointwiseConvParams('Prediction', 2, 'prediction_layer/conv_2'),\n                conv_3: extractPointwiseConvParams('Prediction', 3, 'prediction_layer/conv_3'),\n                conv_4: extractPointwiseConvParams('Prediction', 4, 'prediction_layer/conv_4'),\n                conv_5: extractPointwiseConvParams('Prediction', 5, 'prediction_layer/conv_5'),\n                conv_6: extractPointwiseConvParams('Prediction', 6, 'prediction_layer/conv_6'),\n                conv_7: extractPointwiseConvParams('Prediction', 7, 'prediction_layer/conv_7'),\n                box_predictor_0: extractBoxPredictorParams(0),\n                box_predictor_1: extractBoxPredictorParams(1),\n                box_predictor_2: extractBoxPredictorParams(2),\n                box_predictor_3: extractBoxPredictorParams(3),\n                box_predictor_4: extractBoxPredictorParams(4),\n                box_predictor_5: extractBoxPredictorParams(5)\n            };\n        }\n        return {\n            extractMobilenetV1Params: extractMobilenetV1Params,\n            extractPredictionLayerParams: extractPredictionLayerParams\n        };\n    }\n    function extractParamsFromWeigthMap$4(weightMap) {\n        var paramMappings = [];\n        var _a = extractorsFactory$6(weightMap, paramMappings), extractMobilenetV1Params = _a.extractMobilenetV1Params, extractPredictionLayerParams = _a.extractPredictionLayerParams;\n        var extra_dim = weightMap['Output/extra_dim'];\n        paramMappings.push({ originalPath: 'Output/extra_dim', paramPath: 'output_layer/extra_dim' });\n        if (!isTensor3D(extra_dim)) {\n            throw new Error(\"expected weightMap['Output/extra_dim'] to be a Tensor3D, instead have \" + extra_dim);\n        }\n        var params = {\n            mobilenetv1: extractMobilenetV1Params(),\n            prediction_layer: extractPredictionLayerParams(),\n            output_layer: {\n                extra_dim: extra_dim\n            }\n        };\n        disposeUnusedWeightTensors(weightMap, paramMappings);\n        return { params: params, paramMappings: paramMappings };\n    }\n\n    function pointwiseConvLayer(x, params, strides) {\n        return tidy(function () {\n            var out = conv2d(x, params.filters, strides, 'same');\n            out = add(out, params.batch_norm_offset);\n            return clipByValue(out, 0, 6);\n        });\n    }\n\n    var epsilon = 0.0010000000474974513;\n    function depthwiseConvLayer(x, params, strides) {\n        return tidy(function () {\n            var out = depthwiseConv2d(x, params.filters, strides, 'same');\n            out = batchNormalization(out, params.batch_norm_mean, params.batch_norm_variance, epsilon, params.batch_norm_scale, params.batch_norm_offset);\n            return clipByValue(out, 0, 6);\n        });\n    }\n    function getStridesForLayerIdx(layerIdx) {\n        return [2, 4, 6, 12].some(function (idx) { return idx === layerIdx; }) ? [2, 2] : [1, 1];\n    }\n    function mobileNetV1(x, params) {\n        return tidy(function () {\n            var conv11 = null;\n            var out = pointwiseConvLayer(x, params.conv_0, [2, 2]);\n            var convPairParams = [\n                params.conv_1,\n                params.conv_2,\n                params.conv_3,\n                params.conv_4,\n                params.conv_5,\n                params.conv_6,\n                params.conv_7,\n                params.conv_8,\n                params.conv_9,\n                params.conv_10,\n                params.conv_11,\n                params.conv_12,\n                params.conv_13\n            ];\n            convPairParams.forEach(function (param, i) {\n                var layerIdx = i + 1;\n                var depthwiseConvStrides = getStridesForLayerIdx(layerIdx);\n                out = depthwiseConvLayer(out, param.depthwise_conv, depthwiseConvStrides);\n                out = pointwiseConvLayer(out, param.pointwise_conv, [1, 1]);\n                if (layerIdx === 11) {\n                    conv11 = out;\n                }\n            });\n            if (conv11 === null) {\n                throw new Error('mobileNetV1 - output of conv layer 11 is null');\n            }\n            return {\n                out: out,\n                conv11: conv11\n            };\n        });\n    }\n\n    function nonMaxSuppression$2(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold) {\n        var numBoxes = boxes.shape[0];\n        var outputSize = Math.min(maxOutputSize, numBoxes);\n        var candidates = scores\n            .map(function (score, boxIndex) { return ({ score: score, boxIndex: boxIndex }); })\n            .filter(function (c) { return c.score > scoreThreshold; })\n            .sort(function (c1, c2) { return c2.score - c1.score; });\n        var suppressFunc = function (x) { return x <= iouThreshold ? 1 : 0; };\n        var selected = [];\n        candidates.forEach(function (c) {\n            if (selected.length >= outputSize) {\n                return;\n            }\n            var originalScore = c.score;\n            for (var j = selected.length - 1; j >= 0; --j) {\n                var iou = IOU(boxes, c.boxIndex, selected[j]);\n                if (iou === 0.0) {\n                    continue;\n                }\n                c.score *= suppressFunc(iou);\n                if (c.score <= scoreThreshold) {\n                    break;\n                }\n            }\n            if (originalScore === c.score) {\n                selected.push(c.boxIndex);\n            }\n        });\n        return selected;\n    }\n    function IOU(boxes, i, j) {\n        var yminI = Math.min(boxes.get(i, 0), boxes.get(i, 2));\n        var xminI = Math.min(boxes.get(i, 1), boxes.get(i, 3));\n        var ymaxI = Math.max(boxes.get(i, 0), boxes.get(i, 2));\n        var xmaxI = Math.max(boxes.get(i, 1), boxes.get(i, 3));\n        var yminJ = Math.min(boxes.get(j, 0), boxes.get(j, 2));\n        var xminJ = Math.min(boxes.get(j, 1), boxes.get(j, 3));\n        var ymaxJ = Math.max(boxes.get(j, 0), boxes.get(j, 2));\n        var xmaxJ = Math.max(boxes.get(j, 1), boxes.get(j, 3));\n        var areaI = (ymaxI - yminI) * (xmaxI - xminI);\n        var areaJ = (ymaxJ - yminJ) * (xmaxJ - xminJ);\n        if (areaI <= 0 || areaJ <= 0) {\n            return 0.0;\n        }\n        var intersectionYmin = Math.max(yminI, yminJ);\n        var intersectionXmin = Math.max(xminI, xminJ);\n        var intersectionYmax = Math.min(ymaxI, ymaxJ);\n        var intersectionXmax = Math.min(xmaxI, xmaxJ);\n        var intersectionArea = Math.max(intersectionYmax - intersectionYmin, 0.0) *\n            Math.max(intersectionXmax - intersectionXmin, 0.0);\n        return intersectionArea / (areaI + areaJ - intersectionArea);\n    }\n\n    function getCenterCoordinatesAndSizesLayer(x) {\n        var vec = unstack(transpose(x, [1, 0]));\n        var sizes = [\n            sub(vec[2], vec[0]),\n            sub(vec[3], vec[1])\n        ];\n        var centers = [\n            add(vec[0], div(sizes[0], scalar(2))),\n            add(vec[1], div(sizes[1], scalar(2)))\n        ];\n        return {\n            sizes: sizes,\n            centers: centers\n        };\n    }\n    function decodeBoxesLayer(x0, x1) {\n        var _a = getCenterCoordinatesAndSizesLayer(x0), sizes = _a.sizes, centers = _a.centers;\n        var vec = unstack(transpose(x1, [1, 0]));\n        var div0_out = div(mul(exp(div(vec[2], scalar(5))), sizes[0]), scalar(2));\n        var add0_out = add(mul(div(vec[0], scalar(10)), sizes[0]), centers[0]);\n        var div1_out = div(mul(exp(div(vec[3], scalar(5))), sizes[1]), scalar(2));\n        var add1_out = add(mul(div(vec[1], scalar(10)), sizes[1]), centers[1]);\n        return transpose(stack([\n            sub(add0_out, div0_out),\n            sub(add1_out, div1_out),\n            add(add0_out, div0_out),\n            add(add1_out, div1_out)\n        ]), [1, 0]);\n    }\n    function outputLayer(boxPredictions, classPredictions, params) {\n        return tidy(function () {\n            var batchSize = boxPredictions.shape[0];\n            var boxes = decodeBoxesLayer(reshape(tile(params.extra_dim, [batchSize, 1, 1]), [-1, 4]), reshape(boxPredictions, [-1, 4]));\n            boxes = reshape(boxes, [batchSize, (boxes.shape[0] / batchSize), 4]);\n            var scoresAndClasses = sigmoid(slice(classPredictions, [0, 0, 1], [-1, -1, -1]));\n            var scores = slice(scoresAndClasses, [0, 0, 0], [-1, -1, 1]);\n            scores = reshape(scores, [batchSize, scores.shape[1]]);\n            var boxesByBatch = unstack(boxes);\n            var scoresByBatch = unstack(scores);\n            return {\n                boxes: boxesByBatch,\n                scores: scoresByBatch\n            };\n        });\n    }\n\n    function boxPredictionLayer(x, params) {\n        return tidy(function () {\n            var batchSize = x.shape[0];\n            var boxPredictionEncoding = reshape(convLayer(x, params.box_encoding_predictor), [batchSize, -1, 1, 4]);\n            var classPrediction = reshape(convLayer(x, params.class_predictor), [batchSize, -1, 3]);\n            return {\n                boxPredictionEncoding: boxPredictionEncoding,\n                classPrediction: classPrediction\n            };\n        });\n    }\n\n    function predictionLayer(x, conv11, params) {\n        return tidy(function () {\n            var conv0 = pointwiseConvLayer(x, params.conv_0, [1, 1]);\n            var conv1 = pointwiseConvLayer(conv0, params.conv_1, [2, 2]);\n            var conv2 = pointwiseConvLayer(conv1, params.conv_2, [1, 1]);\n            var conv3 = pointwiseConvLayer(conv2, params.conv_3, [2, 2]);\n            var conv4 = pointwiseConvLayer(conv3, params.conv_4, [1, 1]);\n            var conv5 = pointwiseConvLayer(conv4, params.conv_5, [2, 2]);\n            var conv6 = pointwiseConvLayer(conv5, params.conv_6, [1, 1]);\n            var conv7 = pointwiseConvLayer(conv6, params.conv_7, [2, 2]);\n            var boxPrediction0 = boxPredictionLayer(conv11, params.box_predictor_0);\n            var boxPrediction1 = boxPredictionLayer(x, params.box_predictor_1);\n            var boxPrediction2 = boxPredictionLayer(conv1, params.box_predictor_2);\n            var boxPrediction3 = boxPredictionLayer(conv3, params.box_predictor_3);\n            var boxPrediction4 = boxPredictionLayer(conv5, params.box_predictor_4);\n            var boxPrediction5 = boxPredictionLayer(conv7, params.box_predictor_5);\n            var boxPredictions = concat([\n                boxPrediction0.boxPredictionEncoding,\n                boxPrediction1.boxPredictionEncoding,\n                boxPrediction2.boxPredictionEncoding,\n                boxPrediction3.boxPredictionEncoding,\n                boxPrediction4.boxPredictionEncoding,\n                boxPrediction5.boxPredictionEncoding\n            ], 1);\n            var classPredictions = concat([\n                boxPrediction0.classPrediction,\n                boxPrediction1.classPrediction,\n                boxPrediction2.classPrediction,\n                boxPrediction3.classPrediction,\n                boxPrediction4.classPrediction,\n                boxPrediction5.classPrediction\n            ], 1);\n            return {\n                boxPredictions: boxPredictions,\n                classPredictions: classPredictions\n            };\n        });\n    }\n\n    var SsdMobilenetv1Options = /** @class */ (function () {\n        function SsdMobilenetv1Options(_a) {\n            var _b = _a === void 0 ? {} : _a, minConfidence = _b.minConfidence, maxResults = _b.maxResults;\n            this._name = 'SsdMobilenetv1Options';\n            this._minConfidence = minConfidence || 0.5;\n            this._maxResults = maxResults || 100;\n            if (typeof this._minConfidence !== 'number' || this._minConfidence <= 0 || this._minConfidence >= 1) {\n                throw new Error(this._name + \" - expected minConfidence to be a number between 0 and 1\");\n            }\n            if (typeof this._maxResults !== 'number') {\n                throw new Error(this._name + \" - expected maxResults to be a number\");\n            }\n        }\n        Object.defineProperty(SsdMobilenetv1Options.prototype, \"minConfidence\", {\n            get: function () { return this._minConfidence; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(SsdMobilenetv1Options.prototype, \"maxResults\", {\n            get: function () { return this._maxResults; },\n            enumerable: true,\n            configurable: true\n        });\n        return SsdMobilenetv1Options;\n    }());\n\n    var SsdMobilenetv1 = /** @class */ (function (_super) {\n        __extends$1(SsdMobilenetv1, _super);\n        function SsdMobilenetv1() {\n            return _super.call(this, 'SsdMobilenetv1') || this;\n        }\n        SsdMobilenetv1.prototype.forwardInput = function (input) {\n            var params = this.params;\n            if (!params) {\n                throw new Error('SsdMobilenetv1 - load model before inference');\n            }\n            return tidy(function () {\n                var batchTensor = input.toBatchTensor(512, false).toFloat();\n                var x = sub(mul(batchTensor, scalar(0.007843137718737125)), scalar(1));\n                var features = mobileNetV1(x, params.mobilenetv1);\n                var _a = predictionLayer(features.out, features.conv11, params.prediction_layer), boxPredictions = _a.boxPredictions, classPredictions = _a.classPredictions;\n                return outputLayer(boxPredictions, classPredictions, params.output_layer);\n            });\n        };\n        SsdMobilenetv1.prototype.forward = function (input) {\n            return __awaiter$1(this, void 0, void 0, function () {\n                var _a;\n                return __generator$1(this, function (_b) {\n                    switch (_b.label) {\n                        case 0:\n                            _a = this.forwardInput;\n                            return [4 /*yield*/, toNetInput(input)];\n                        case 1: return [2 /*return*/, _a.apply(this, [_b.sent()])];\n                    }\n                });\n            });\n        };\n        SsdMobilenetv1.prototype.locateFaces = function (input, options) {\n            if (options === void 0) { options = {}; }\n            return __awaiter$1(this, void 0, void 0, function () {\n                var _a, maxResults, minConfidence, netInput, _b, _boxes, _scores, boxes, scores, i, scoresData, _c, _d, iouThreshold, indices, reshapedDims, inputSize, padX, padY, results;\n                return __generator$1(this, function (_e) {\n                    switch (_e.label) {\n                        case 0:\n                            _a = new SsdMobilenetv1Options(options), maxResults = _a.maxResults, minConfidence = _a.minConfidence;\n                            return [4 /*yield*/, toNetInput(input)];\n                        case 1:\n                            netInput = _e.sent();\n                            _b = this.forwardInput(netInput), _boxes = _b.boxes, _scores = _b.scores;\n                            boxes = _boxes[0];\n                            scores = _scores[0];\n                            for (i = 1; i < _boxes.length; i++) {\n                                _boxes[i].dispose();\n                                _scores[i].dispose();\n                            }\n                            _d = (_c = Array).from;\n                            return [4 /*yield*/, scores.data()];\n                        case 2:\n                            scoresData = _d.apply(_c, [_e.sent()]);\n                            iouThreshold = 0.5;\n                            indices = nonMaxSuppression$2(boxes, scoresData, maxResults, iouThreshold, minConfidence);\n                            reshapedDims = netInput.getReshapedInputDimensions(0);\n                            inputSize = netInput.inputSize;\n                            padX = inputSize / reshapedDims.width;\n                            padY = inputSize / reshapedDims.height;\n                            results = indices\n                                .map(function (idx) {\n                                var _a = [\n                                    Math.max(0, boxes.get(idx, 0)),\n                                    Math.min(1.0, boxes.get(idx, 2))\n                                ].map(function (val) { return val * padY; }), top = _a[0], bottom = _a[1];\n                                var _b = [\n                                    Math.max(0, boxes.get(idx, 1)),\n                                    Math.min(1.0, boxes.get(idx, 3))\n                                ].map(function (val) { return val * padX; }), left = _b[0], right = _b[1];\n                                return new FaceDetection(scoresData[idx], new Rect(left, top, right - left, bottom - top), {\n                                    height: netInput.getInputHeight(0),\n                                    width: netInput.getInputWidth(0)\n                                });\n                            });\n                            boxes.dispose();\n                            scores.dispose();\n                            return [2 /*return*/, results];\n                    }\n                });\n            });\n        };\n        SsdMobilenetv1.prototype.getDefaultModelName = function () {\n            return 'ssd_mobilenetv1_model';\n        };\n        SsdMobilenetv1.prototype.extractParamsFromWeigthMap = function (weightMap) {\n            return extractParamsFromWeigthMap$4(weightMap);\n        };\n        SsdMobilenetv1.prototype.extractParams = function (weights) {\n            return extractParams$4(weights);\n        };\n        return SsdMobilenetv1;\n    }(NeuralNetwork));\n\n    function createSsdMobilenetv1(weights) {\n        var net = new SsdMobilenetv1();\n        net.extractWeights(weights);\n        return net;\n    }\n    function createFaceDetectionNet(weights) {\n        return createSsdMobilenetv1(weights);\n    }\n    // alias for backward compatibily\n    var FaceDetectionNet = /** @class */ (function (_super) {\n        __extends$1(FaceDetectionNet, _super);\n        function FaceDetectionNet() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        return FaceDetectionNet;\n    }(SsdMobilenetv1));\n\n    var TinyFaceDetectorOptions = /** @class */ (function (_super) {\n        __extends$1(TinyFaceDetectorOptions, _super);\n        function TinyFaceDetectorOptions() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this._name = 'TinyFaceDetectorOptions';\n            return _this;\n        }\n        return TinyFaceDetectorOptions;\n    }(TinyYolov2Options));\n\n    var ComposableTask = /** @class */ (function () {\n        function ComposableTask() {\n        }\n        ComposableTask.prototype.then = function (onfulfilled) {\n            return __awaiter$1(this, void 0, void 0, function () {\n                var _a;\n                return __generator$1(this, function (_b) {\n                    switch (_b.label) {\n                        case 0:\n                            _a = onfulfilled;\n                            return [4 /*yield*/, this.run()];\n                        case 1: return [2 /*return*/, _a.apply(void 0, [_b.sent()])];\n                    }\n                });\n            });\n        };\n        ComposableTask.prototype.run = function () {\n            return __awaiter$1(this, void 0, void 0, function () {\n                return __generator$1(this, function (_a) {\n                    throw new Error('ComposableTask - run is not implemented');\n                });\n            });\n        };\n        return ComposableTask;\n    }());\n\n    function bgrToRgbTensor(tensor$$1) {\n        return tidy(function () { return stack(unstack(tensor$$1, 3).reverse(), 3); });\n    }\n\n    var CELL_STRIDE = 2;\n    var CELL_SIZE = 12;\n\n    function extractorsFactory$7(extractWeights, paramMappings) {\n        var extractConvParams = extractConvParamsFactory(extractWeights, paramMappings);\n        var extractFCParams = extractFCParamsFactory(extractWeights, paramMappings);\n        function extractPReluParams(size, paramPath) {\n            var alpha = tensor1d(extractWeights(size));\n            paramMappings.push({ paramPath: paramPath });\n            return alpha;\n        }\n        function extractSharedParams(numFilters, mappedPrefix, isRnet) {\n            if (isRnet === void 0) { isRnet = false; }\n            var conv1 = extractConvParams(numFilters[0], numFilters[1], 3, mappedPrefix + \"/conv1\");\n            var prelu1_alpha = extractPReluParams(numFilters[1], mappedPrefix + \"/prelu1_alpha\");\n            var conv2 = extractConvParams(numFilters[1], numFilters[2], 3, mappedPrefix + \"/conv2\");\n            var prelu2_alpha = extractPReluParams(numFilters[2], mappedPrefix + \"/prelu2_alpha\");\n            var conv3 = extractConvParams(numFilters[2], numFilters[3], isRnet ? 2 : 3, mappedPrefix + \"/conv3\");\n            var prelu3_alpha = extractPReluParams(numFilters[3], mappedPrefix + \"/prelu3_alpha\");\n            return { conv1: conv1, prelu1_alpha: prelu1_alpha, conv2: conv2, prelu2_alpha: prelu2_alpha, conv3: conv3, prelu3_alpha: prelu3_alpha };\n        }\n        function extractPNetParams() {\n            var sharedParams = extractSharedParams([3, 10, 16, 32], 'pnet');\n            var conv4_1 = extractConvParams(32, 2, 1, 'pnet/conv4_1');\n            var conv4_2 = extractConvParams(32, 4, 1, 'pnet/conv4_2');\n            return __assign$1({}, sharedParams, { conv4_1: conv4_1, conv4_2: conv4_2 });\n        }\n        function extractRNetParams() {\n            var sharedParams = extractSharedParams([3, 28, 48, 64], 'rnet', true);\n            var fc1 = extractFCParams(576, 128, 'rnet/fc1');\n            var prelu4_alpha = extractPReluParams(128, 'rnet/prelu4_alpha');\n            var fc2_1 = extractFCParams(128, 2, 'rnet/fc2_1');\n            var fc2_2 = extractFCParams(128, 4, 'rnet/fc2_2');\n            return __assign$1({}, sharedParams, { fc1: fc1, prelu4_alpha: prelu4_alpha, fc2_1: fc2_1, fc2_2: fc2_2 });\n        }\n        function extractONetParams() {\n            var sharedParams = extractSharedParams([3, 32, 64, 64], 'onet');\n            var conv4 = extractConvParams(64, 128, 2, 'onet/conv4');\n            var prelu4_alpha = extractPReluParams(128, 'onet/prelu4_alpha');\n            var fc1 = extractFCParams(1152, 256, 'onet/fc1');\n            var prelu5_alpha = extractPReluParams(256, 'onet/prelu5_alpha');\n            var fc2_1 = extractFCParams(256, 2, 'onet/fc2_1');\n            var fc2_2 = extractFCParams(256, 4, 'onet/fc2_2');\n            var fc2_3 = extractFCParams(256, 10, 'onet/fc2_3');\n            return __assign$1({}, sharedParams, { conv4: conv4, prelu4_alpha: prelu4_alpha, fc1: fc1, prelu5_alpha: prelu5_alpha, fc2_1: fc2_1, fc2_2: fc2_2, fc2_3: fc2_3 });\n        }\n        return {\n            extractPNetParams: extractPNetParams,\n            extractRNetParams: extractRNetParams,\n            extractONetParams: extractONetParams\n        };\n    }\n    function extractParams$5(weights) {\n        var _a = extractWeightsFactory(weights), extractWeights = _a.extractWeights, getRemainingWeights = _a.getRemainingWeights;\n        var paramMappings = [];\n        var _b = extractorsFactory$7(extractWeights, paramMappings), extractPNetParams = _b.extractPNetParams, extractRNetParams = _b.extractRNetParams, extractONetParams = _b.extractONetParams;\n        var pnet = extractPNetParams();\n        var rnet = extractRNetParams();\n        var onet = extractONetParams();\n        if (getRemainingWeights().length !== 0) {\n            throw new Error(\"weights remaing after extract: \" + getRemainingWeights().length);\n        }\n        return { params: { pnet: pnet, rnet: rnet, onet: onet }, paramMappings: paramMappings };\n    }\n\n    function extractorsFactory$8(weightMap, paramMappings) {\n        var extractWeightEntry = extractWeightEntryFactory(weightMap, paramMappings);\n        function extractConvParams(prefix) {\n            var filters = extractWeightEntry(prefix + \"/weights\", 4, prefix + \"/filters\");\n            var bias = extractWeightEntry(prefix + \"/bias\", 1);\n            return { filters: filters, bias: bias };\n        }\n        function extractFCParams(prefix) {\n            var weights = extractWeightEntry(prefix + \"/weights\", 2);\n            var bias = extractWeightEntry(prefix + \"/bias\", 1);\n            return { weights: weights, bias: bias };\n        }\n        function extractPReluParams(paramPath) {\n            return extractWeightEntry(paramPath, 1);\n        }\n        function extractSharedParams(prefix) {\n            var conv1 = extractConvParams(prefix + \"/conv1\");\n            var prelu1_alpha = extractPReluParams(prefix + \"/prelu1_alpha\");\n            var conv2 = extractConvParams(prefix + \"/conv2\");\n            var prelu2_alpha = extractPReluParams(prefix + \"/prelu2_alpha\");\n            var conv3 = extractConvParams(prefix + \"/conv3\");\n            var prelu3_alpha = extractPReluParams(prefix + \"/prelu3_alpha\");\n            return { conv1: conv1, prelu1_alpha: prelu1_alpha, conv2: conv2, prelu2_alpha: prelu2_alpha, conv3: conv3, prelu3_alpha: prelu3_alpha };\n        }\n        function extractPNetParams() {\n            var sharedParams = extractSharedParams('pnet');\n            var conv4_1 = extractConvParams('pnet/conv4_1');\n            var conv4_2 = extractConvParams('pnet/conv4_2');\n            return __assign$1({}, sharedParams, { conv4_1: conv4_1, conv4_2: conv4_2 });\n        }\n        function extractRNetParams() {\n            var sharedParams = extractSharedParams('rnet');\n            var fc1 = extractFCParams('rnet/fc1');\n            var prelu4_alpha = extractPReluParams('rnet/prelu4_alpha');\n            var fc2_1 = extractFCParams('rnet/fc2_1');\n            var fc2_2 = extractFCParams('rnet/fc2_2');\n            return __assign$1({}, sharedParams, { fc1: fc1, prelu4_alpha: prelu4_alpha, fc2_1: fc2_1, fc2_2: fc2_2 });\n        }\n        function extractONetParams() {\n            var sharedParams = extractSharedParams('onet');\n            var conv4 = extractConvParams('onet/conv4');\n            var prelu4_alpha = extractPReluParams('onet/prelu4_alpha');\n            var fc1 = extractFCParams('onet/fc1');\n            var prelu5_alpha = extractPReluParams('onet/prelu5_alpha');\n            var fc2_1 = extractFCParams('onet/fc2_1');\n            var fc2_2 = extractFCParams('onet/fc2_2');\n            var fc2_3 = extractFCParams('onet/fc2_3');\n            return __assign$1({}, sharedParams, { conv4: conv4, prelu4_alpha: prelu4_alpha, fc1: fc1, prelu5_alpha: prelu5_alpha, fc2_1: fc2_1, fc2_2: fc2_2, fc2_3: fc2_3 });\n        }\n        return {\n            extractPNetParams: extractPNetParams,\n            extractRNetParams: extractRNetParams,\n            extractONetParams: extractONetParams\n        };\n    }\n    function extractParamsFromWeigthMap$5(weightMap) {\n        var paramMappings = [];\n        var _a = extractorsFactory$8(weightMap, paramMappings), extractPNetParams = _a.extractPNetParams, extractRNetParams = _a.extractRNetParams, extractONetParams = _a.extractONetParams;\n        var pnet = extractPNetParams();\n        var rnet = extractRNetParams();\n        var onet = extractONetParams();\n        disposeUnusedWeightTensors(weightMap, paramMappings);\n        return { params: { pnet: pnet, rnet: rnet, onet: onet }, paramMappings: paramMappings };\n    }\n\n    function getSizesForScale(scale, _a) {\n        var height = _a[0], width = _a[1];\n        return {\n            height: Math.floor(height * scale),\n            width: Math.floor(width * scale)\n        };\n    }\n\n    function pyramidDown(minFaceSize, scaleFactor, dims) {\n        var height = dims[0], width = dims[1];\n        var m = CELL_SIZE / minFaceSize;\n        var scales = [];\n        var minLayer = Math.min(height, width) * m;\n        var exp = 0;\n        while (minLayer >= 12) {\n            scales.push(m * Math.pow(scaleFactor, exp));\n            minLayer = minLayer * scaleFactor;\n            exp += 1;\n        }\n        return scales;\n    }\n\n    var MtcnnBox = /** @class */ (function (_super) {\n        __extends$1(MtcnnBox, _super);\n        function MtcnnBox(left, top, right, bottom) {\n            return _super.call(this, { left: left, top: top, right: right, bottom: bottom }, true) || this;\n        }\n        return MtcnnBox;\n    }(Box));\n\n    function normalize$1(x) {\n        return tidy(function () { return mul(sub(x, scalar(127.5)), scalar(0.0078125)); });\n    }\n\n    function prelu$1(x, alpha) {\n        return tidy(function () {\n            return add(relu(x), mul(alpha, neg(relu(neg(x)))));\n        });\n    }\n\n    function sharedLayer(x, params, isPnet) {\n        if (isPnet === void 0) { isPnet = false; }\n        return tidy(function () {\n            var out = convLayer(x, params.conv1, 'valid');\n            out = prelu$1(out, params.prelu1_alpha);\n            out = maxPool(out, isPnet ? [2, 2] : [3, 3], [2, 2], 'same');\n            out = convLayer(out, params.conv2, 'valid');\n            out = prelu$1(out, params.prelu2_alpha);\n            out = isPnet ? out : maxPool(out, [3, 3], [2, 2], 'valid');\n            out = convLayer(out, params.conv3, 'valid');\n            out = prelu$1(out, params.prelu3_alpha);\n            return out;\n        });\n    }\n\n    function PNet(x, params) {\n        return tidy(function () {\n            var out = sharedLayer(x, params, true);\n            var conv = convLayer(out, params.conv4_1, 'valid');\n            var max$$1 = expandDims(max(conv, 3), 3);\n            var prob = softmax(sub(conv, max$$1), 3);\n            var regions = convLayer(out, params.conv4_2, 'valid');\n            return { prob: prob, regions: regions };\n        });\n    }\n\n    function rescaleAndNormalize(x, scale) {\n        return tidy(function () {\n            var _a = getSizesForScale(scale, x.shape.slice(1)), height = _a.height, width = _a.width;\n            var resized = image_ops.resizeBilinear(x, [height, width]);\n            var normalized = normalize$1(resized);\n            return transpose(normalized, [0, 2, 1, 3]);\n        });\n    }\n    function extractBoundingBoxes(scoresTensor, regionsTensor, scale, scoreThreshold) {\n        // TODO: fix this!, maybe better to use tf.gather here\n        var indices = [];\n        for (var y = 0; y < scoresTensor.shape[0]; y++) {\n            for (var x = 0; x < scoresTensor.shape[1]; x++) {\n                if (scoresTensor.get(y, x) >= scoreThreshold) {\n                    indices.push(new Point(x, y));\n                }\n            }\n        }\n        var boundingBoxes = indices.map(function (idx) {\n            var cell = new BoundingBox(Math.round((idx.y * CELL_STRIDE + 1) / scale), Math.round((idx.x * CELL_STRIDE + 1) / scale), Math.round((idx.y * CELL_STRIDE + CELL_SIZE) / scale), Math.round((idx.x * CELL_STRIDE + CELL_SIZE) / scale));\n            var score = scoresTensor.get(idx.y, idx.x);\n            var region = new MtcnnBox(regionsTensor.get(idx.y, idx.x, 0), regionsTensor.get(idx.y, idx.x, 1), regionsTensor.get(idx.y, idx.x, 2), regionsTensor.get(idx.y, idx.x, 3));\n            return {\n                cell: cell,\n                score: score,\n                region: region\n            };\n        });\n        return boundingBoxes;\n    }\n    function stage1(imgTensor, scales, scoreThreshold, params, stats) {\n        stats.stage1 = [];\n        var pnetOutputs = scales.map(function (scale) { return tidy(function () {\n            var statsForScale = { scale: scale };\n            var resized = rescaleAndNormalize(imgTensor, scale);\n            var ts = Date.now();\n            var _a = PNet(resized, params), prob = _a.prob, regions = _a.regions;\n            statsForScale.pnet = Date.now() - ts;\n            var scoresTensor = unstack(unstack(prob, 3)[1])[0];\n            var regionsTensor = unstack(regions)[0];\n            return {\n                scoresTensor: scoresTensor,\n                regionsTensor: regionsTensor,\n                scale: scale,\n                statsForScale: statsForScale\n            };\n        }); });\n        var boxesForScale = pnetOutputs.map(function (_a) {\n            var scoresTensor = _a.scoresTensor, regionsTensor = _a.regionsTensor, scale = _a.scale, statsForScale = _a.statsForScale;\n            var boundingBoxes = extractBoundingBoxes(scoresTensor, regionsTensor, scale, scoreThreshold);\n            scoresTensor.dispose();\n            regionsTensor.dispose();\n            if (!boundingBoxes.length) {\n                stats.stage1.push(statsForScale);\n                return [];\n            }\n            var ts = Date.now();\n            var indices = nonMaxSuppression$1(boundingBoxes.map(function (bbox) { return bbox.cell; }), boundingBoxes.map(function (bbox) { return bbox.score; }), 0.5);\n            statsForScale.nms = Date.now() - ts;\n            statsForScale.numBoxes = indices.length;\n            stats.stage1.push(statsForScale);\n            return indices.map(function (boxIdx) { return boundingBoxes[boxIdx]; });\n        });\n        var allBoxes = boxesForScale.reduce(function (all$$1, boxes) { return all$$1.concat(boxes); }, []);\n        var finalBoxes = [];\n        var finalScores = [];\n        if (allBoxes.length > 0) {\n            var ts = Date.now();\n            var indices = nonMaxSuppression$1(allBoxes.map(function (bbox) { return bbox.cell; }), allBoxes.map(function (bbox) { return bbox.score; }), 0.7);\n            stats.stage1_nms = Date.now() - ts;\n            finalScores = indices.map(function (idx) { return allBoxes[idx].score; });\n            finalBoxes = indices\n                .map(function (idx) { return allBoxes[idx]; })\n                .map(function (_a) {\n                var cell = _a.cell, region = _a.region;\n                return new BoundingBox(cell.left + (region.left * cell.width), cell.top + (region.top * cell.height), cell.right + (region.right * cell.width), cell.bottom + (region.bottom * cell.height)).toSquare().round();\n            });\n        }\n        return {\n            boxes: finalBoxes,\n            scores: finalScores\n        };\n    }\n\n    function extractImagePatches(img, boxes, _a) {\n        var width = _a.width, height = _a.height;\n        return __awaiter$1(this, void 0, void 0, function () {\n            var imgCtx, bitmaps, imagePatchesDatas;\n            var _this = this;\n            return __generator$1(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        imgCtx = getContext2dOrThrow(img);\n                        return [4 /*yield*/, Promise.all(boxes.map(function (box) { return __awaiter$1(_this, void 0, void 0, function () {\n                                var _a, y, ey, x, ex, fromX, fromY, imgData;\n                                return __generator$1(this, function (_b) {\n                                    _a = box.padAtBorders(img.height, img.width), y = _a.y, ey = _a.ey, x = _a.x, ex = _a.ex;\n                                    fromX = x - 1;\n                                    fromY = y - 1;\n                                    imgData = imgCtx.getImageData(fromX, fromY, (ex - fromX), (ey - fromY));\n                                    return [2 /*return*/, env.isNodejs() ? createCanvasFromMedia(imgData) : createImageBitmap(imgData)];\n                                });\n                            }); }))];\n                    case 1:\n                        bitmaps = _b.sent();\n                        imagePatchesDatas = [];\n                        bitmaps.forEach(function (bmp) {\n                            var patch = createCanvas({ width: width, height: height });\n                            var patchCtx = getContext2dOrThrow(patch);\n                            patchCtx.drawImage(bmp, 0, 0, width, height);\n                            var data = patchCtx.getImageData(0, 0, width, height).data;\n                            var currData = [];\n                            // RGBA -> BGR\n                            for (var i = 0; i < data.length; i += 4) {\n                                currData.push(data[i + 2]);\n                                currData.push(data[i + 1]);\n                                currData.push(data[i]);\n                            }\n                            imagePatchesDatas.push(currData);\n                        });\n                        return [2 /*return*/, imagePatchesDatas.map(function (data) {\n                                var t = tidy(function () {\n                                    var imagePatchTensor = transpose(tensor4d(data, [1, width, height, 3]), [0, 2, 1, 3]).toFloat();\n                                    return normalize$1(imagePatchTensor);\n                                });\n                                return t;\n                            })];\n                }\n            });\n        });\n    }\n\n    function RNet(x, params) {\n        return tidy(function () {\n            var convOut = sharedLayer(x, params);\n            var vectorized = reshape(convOut, [convOut.shape[0], params.fc1.weights.shape[0]]);\n            var fc1 = fullyConnectedLayer(vectorized, params.fc1);\n            var prelu4 = prelu$1(fc1, params.prelu4_alpha);\n            var fc2_1 = fullyConnectedLayer(prelu4, params.fc2_1);\n            var max$$1 = expandDims(max(fc2_1, 1), 1);\n            var prob = softmax(sub(fc2_1, max$$1), 1);\n            var regions = fullyConnectedLayer(prelu4, params.fc2_2);\n            var scores = unstack(prob, 1)[1];\n            return { scores: scores, regions: regions };\n        });\n    }\n\n    function stage2(img, inputBoxes, scoreThreshold, params, stats) {\n        return __awaiter$1(this, void 0, void 0, function () {\n            var ts, rnetInputs, rnetOuts, scoresTensor, scores, _a, _b, indices, filteredBoxes, filteredScores, finalBoxes, finalScores, indicesNms, regions_1;\n            return __generator$1(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        ts = Date.now();\n                        return [4 /*yield*/, extractImagePatches(img, inputBoxes, { width: 24, height: 24 })];\n                    case 1:\n                        rnetInputs = _c.sent();\n                        stats.stage2_extractImagePatches = Date.now() - ts;\n                        ts = Date.now();\n                        rnetOuts = rnetInputs.map(function (rnetInput) {\n                            var out = RNet(rnetInput, params);\n                            rnetInput.dispose();\n                            return out;\n                        });\n                        stats.stage2_rnet = Date.now() - ts;\n                        scoresTensor = rnetOuts.length > 1\n                            ? concat(rnetOuts.map(function (out) { return out.scores; }))\n                            : rnetOuts[0].scores;\n                        _b = (_a = Array).from;\n                        return [4 /*yield*/, scoresTensor.data()];\n                    case 2:\n                        scores = _b.apply(_a, [_c.sent()]);\n                        scoresTensor.dispose();\n                        indices = scores\n                            .map(function (score, idx) { return ({ score: score, idx: idx }); })\n                            .filter(function (c) { return c.score > scoreThreshold; })\n                            .map(function (_a) {\n                            var idx = _a.idx;\n                            return idx;\n                        });\n                        filteredBoxes = indices.map(function (idx) { return inputBoxes[idx]; });\n                        filteredScores = indices.map(function (idx) { return scores[idx]; });\n                        finalBoxes = [];\n                        finalScores = [];\n                        if (filteredBoxes.length > 0) {\n                            ts = Date.now();\n                            indicesNms = nonMaxSuppression$1(filteredBoxes, filteredScores, 0.7);\n                            stats.stage2_nms = Date.now() - ts;\n                            regions_1 = indicesNms.map(function (idx) {\n                                return new MtcnnBox(rnetOuts[indices[idx]].regions.get(0, 0), rnetOuts[indices[idx]].regions.get(0, 1), rnetOuts[indices[idx]].regions.get(0, 2), rnetOuts[indices[idx]].regions.get(0, 3));\n                            });\n                            finalScores = indicesNms.map(function (idx) { return filteredScores[idx]; });\n                            finalBoxes = indicesNms.map(function (idx, i) { return filteredBoxes[idx].calibrate(regions_1[i]); });\n                        }\n                        rnetOuts.forEach(function (t) {\n                            t.regions.dispose();\n                            t.scores.dispose();\n                        });\n                        return [2 /*return*/, {\n                                boxes: finalBoxes,\n                                scores: finalScores\n                            }];\n                }\n            });\n        });\n    }\n\n    function ONet(x, params) {\n        return tidy(function () {\n            var out = sharedLayer(x, params);\n            out = maxPool(out, [2, 2], [2, 2], 'same');\n            out = convLayer(out, params.conv4, 'valid');\n            out = prelu$1(out, params.prelu4_alpha);\n            var vectorized = reshape(out, [out.shape[0], params.fc1.weights.shape[0]]);\n            var fc1 = fullyConnectedLayer(vectorized, params.fc1);\n            var prelu5 = prelu$1(fc1, params.prelu5_alpha);\n            var fc2_1 = fullyConnectedLayer(prelu5, params.fc2_1);\n            var max$$1 = expandDims(max(fc2_1, 1), 1);\n            var prob = softmax(sub(fc2_1, max$$1), 1);\n            var regions = fullyConnectedLayer(prelu5, params.fc2_2);\n            var points = fullyConnectedLayer(prelu5, params.fc2_3);\n            var scores = unstack(prob, 1)[1];\n            return { scores: scores, regions: regions, points: points };\n        });\n    }\n\n    function stage3(img, inputBoxes, scoreThreshold, params, stats) {\n        return __awaiter$1(this, void 0, void 0, function () {\n            var ts, onetInputs, onetOuts, scoresTensor, scores, _a, _b, indices, filteredRegions, filteredBoxes, filteredScores, finalBoxes, finalScores, points, indicesNms;\n            return __generator$1(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        ts = Date.now();\n                        return [4 /*yield*/, extractImagePatches(img, inputBoxes, { width: 48, height: 48 })];\n                    case 1:\n                        onetInputs = _c.sent();\n                        stats.stage3_extractImagePatches = Date.now() - ts;\n                        ts = Date.now();\n                        onetOuts = onetInputs.map(function (onetInput) {\n                            var out = ONet(onetInput, params);\n                            onetInput.dispose();\n                            return out;\n                        });\n                        stats.stage3_onet = Date.now() - ts;\n                        scoresTensor = onetOuts.length > 1\n                            ? concat(onetOuts.map(function (out) { return out.scores; }))\n                            : onetOuts[0].scores;\n                        _b = (_a = Array).from;\n                        return [4 /*yield*/, scoresTensor.data()];\n                    case 2:\n                        scores = _b.apply(_a, [_c.sent()]);\n                        scoresTensor.dispose();\n                        indices = scores\n                            .map(function (score, idx) { return ({ score: score, idx: idx }); })\n                            .filter(function (c) { return c.score > scoreThreshold; })\n                            .map(function (_a) {\n                            var idx = _a.idx;\n                            return idx;\n                        });\n                        filteredRegions = indices.map(function (idx) { return new MtcnnBox(onetOuts[idx].regions.get(0, 0), onetOuts[idx].regions.get(0, 1), onetOuts[idx].regions.get(0, 2), onetOuts[idx].regions.get(0, 3)); });\n                        filteredBoxes = indices\n                            .map(function (idx, i) { return inputBoxes[idx].calibrate(filteredRegions[i]); });\n                        filteredScores = indices.map(function (idx) { return scores[idx]; });\n                        finalBoxes = [];\n                        finalScores = [];\n                        points = [];\n                        if (filteredBoxes.length > 0) {\n                            ts = Date.now();\n                            indicesNms = nonMaxSuppression$1(filteredBoxes, filteredScores, 0.7, false);\n                            stats.stage3_nms = Date.now() - ts;\n                            finalBoxes = indicesNms.map(function (idx) { return filteredBoxes[idx]; });\n                            finalScores = indicesNms.map(function (idx) { return filteredScores[idx]; });\n                            points = indicesNms.map(function (idx, i) {\n                                return Array(5).fill(0).map(function (_, ptIdx) {\n                                    return new Point(((onetOuts[idx].points.get(0, ptIdx) * (finalBoxes[i].width + 1)) + finalBoxes[i].left), ((onetOuts[idx].points.get(0, ptIdx + 5) * (finalBoxes[i].height + 1)) + finalBoxes[i].top));\n                                });\n                            });\n                        }\n                        onetOuts.forEach(function (t) {\n                            t.regions.dispose();\n                            t.scores.dispose();\n                            t.points.dispose();\n                        });\n                        return [2 /*return*/, {\n                                boxes: finalBoxes,\n                                scores: finalScores,\n                                points: points\n                            }];\n                }\n            });\n        });\n    }\n\n    var Mtcnn = /** @class */ (function (_super) {\n        __extends$1(Mtcnn, _super);\n        function Mtcnn() {\n            return _super.call(this, 'Mtcnn') || this;\n        }\n        Mtcnn.prototype.forwardInput = function (input, forwardParams) {\n            if (forwardParams === void 0) { forwardParams = {}; }\n            return __awaiter$1(this, void 0, void 0, function () {\n                var params, inputCanvas, stats, tsTotal, imgTensor, onReturn, _a, height, width, _b, minFaceSize, scaleFactor, maxNumScales, scoreThresholds, scaleSteps, scales, ts, out1, out2, out3, results;\n                return __generator$1(this, function (_c) {\n                    switch (_c.label) {\n                        case 0:\n                            params = this.params;\n                            if (!params) {\n                                throw new Error('Mtcnn - load model before inference');\n                            }\n                            inputCanvas = input.canvases[0];\n                            if (!inputCanvas) {\n                                throw new Error('Mtcnn - inputCanvas is not defined, note that passing tensors into Mtcnn.forwardInput is not supported yet.');\n                            }\n                            stats = {};\n                            tsTotal = Date.now();\n                            imgTensor = tidy(function () {\n                                return bgrToRgbTensor(expandDims(fromPixels(inputCanvas)).toFloat());\n                            });\n                            onReturn = function (results) {\n                                // dispose tensors on return\n                                imgTensor.dispose();\n                                stats.total = Date.now() - tsTotal;\n                                return results;\n                            };\n                            _a = imgTensor.shape.slice(1), height = _a[0], width = _a[1];\n                            _b = new MtcnnOptions(forwardParams), minFaceSize = _b.minFaceSize, scaleFactor = _b.scaleFactor, maxNumScales = _b.maxNumScales, scoreThresholds = _b.scoreThresholds, scaleSteps = _b.scaleSteps;\n                            scales = (scaleSteps || pyramidDown(minFaceSize, scaleFactor, [height, width]))\n                                .filter(function (scale) {\n                                var sizes = getSizesForScale(scale, [height, width]);\n                                return Math.min(sizes.width, sizes.height) > CELL_SIZE;\n                            })\n                                .slice(0, maxNumScales);\n                            stats.scales = scales;\n                            stats.pyramid = scales.map(function (scale) { return getSizesForScale(scale, [height, width]); });\n                            ts = Date.now();\n                            return [4 /*yield*/, stage1(imgTensor, scales, scoreThresholds[0], params.pnet, stats)];\n                        case 1:\n                            out1 = _c.sent();\n                            stats.total_stage1 = Date.now() - ts;\n                            if (!out1.boxes.length) {\n                                return [2 /*return*/, onReturn({ results: [], stats: stats })];\n                            }\n                            stats.stage2_numInputBoxes = out1.boxes.length;\n                            // using the inputCanvas to extract and resize the image patches, since it is faster\n                            // than doing this on the gpu\n                            ts = Date.now();\n                            return [4 /*yield*/, stage2(inputCanvas, out1.boxes, scoreThresholds[1], params.rnet, stats)];\n                        case 2:\n                            out2 = _c.sent();\n                            stats.total_stage2 = Date.now() - ts;\n                            if (!out2.boxes.length) {\n                                return [2 /*return*/, onReturn({ results: [], stats: stats })];\n                            }\n                            stats.stage3_numInputBoxes = out2.boxes.length;\n                            ts = Date.now();\n                            return [4 /*yield*/, stage3(inputCanvas, out2.boxes, scoreThresholds[2], params.onet, stats)];\n                        case 3:\n                            out3 = _c.sent();\n                            stats.total_stage3 = Date.now() - ts;\n                            results = out3.boxes.map(function (box, idx) { return extendWithFaceLandmarks(extendWithFaceDetection({}, new FaceDetection(out3.scores[idx], new Rect(box.left / width, box.top / height, box.width / width, box.height / height), {\n                                height: height,\n                                width: width\n                            })), new FaceLandmarks5(out3.points[idx].map(function (pt) { return pt.sub(new Point(box.left, box.top)).div(new Point(box.width, box.height)); }), { width: box.width, height: box.height })); });\n                            return [2 /*return*/, onReturn({ results: results, stats: stats })];\n                    }\n                });\n            });\n        };\n        Mtcnn.prototype.forward = function (input, forwardParams) {\n            if (forwardParams === void 0) { forwardParams = {}; }\n            return __awaiter$1(this, void 0, void 0, function () {\n                var _a;\n                return __generator$1(this, function (_b) {\n                    switch (_b.label) {\n                        case 0:\n                            _a = this.forwardInput;\n                            return [4 /*yield*/, toNetInput(input)];\n                        case 1: return [4 /*yield*/, _a.apply(this, [_b.sent(),\n                                forwardParams])];\n                        case 2: return [2 /*return*/, (_b.sent()).results];\n                    }\n                });\n            });\n        };\n        Mtcnn.prototype.forwardWithStats = function (input, forwardParams) {\n            if (forwardParams === void 0) { forwardParams = {}; }\n            return __awaiter$1(this, void 0, void 0, function () {\n                var _a;\n                return __generator$1(this, function (_b) {\n                    switch (_b.label) {\n                        case 0:\n                            _a = this.forwardInput;\n                            return [4 /*yield*/, toNetInput(input)];\n                        case 1: return [2 /*return*/, _a.apply(this, [_b.sent(),\n                                forwardParams])];\n                    }\n                });\n            });\n        };\n        Mtcnn.prototype.getDefaultModelName = function () {\n            return 'mtcnn_model';\n        };\n        Mtcnn.prototype.extractParamsFromWeigthMap = function (weightMap) {\n            return extractParamsFromWeigthMap$5(weightMap);\n        };\n        Mtcnn.prototype.extractParams = function (weights) {\n            return extractParams$5(weights);\n        };\n        return Mtcnn;\n    }(NeuralNetwork));\n\n    var IOU_THRESHOLD = 0.4;\n    var BOX_ANCHORS = [\n        new Point(1.603231, 2.094468),\n        new Point(6.041143, 7.080126),\n        new Point(2.882459, 3.518061),\n        new Point(4.266906, 5.178857),\n        new Point(9.041765, 10.66308)\n    ];\n    var MEAN_RGB = [117.001, 114.697, 97.404];\n\n    var TinyFaceDetector = /** @class */ (function (_super) {\n        __extends$1(TinyFaceDetector, _super);\n        function TinyFaceDetector() {\n            var _this = this;\n            var config = {\n                withSeparableConvs: true,\n                iouThreshold: IOU_THRESHOLD,\n                classes: ['face'],\n                anchors: BOX_ANCHORS,\n                meanRgb: MEAN_RGB,\n                isFirstLayerConv2d: true,\n                filterSizes: [3, 16, 32, 64, 128, 256, 512]\n            };\n            _this = _super.call(this, config) || this;\n            return _this;\n        }\n        Object.defineProperty(TinyFaceDetector.prototype, \"anchors\", {\n            get: function () {\n                return this.config.anchors;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        TinyFaceDetector.prototype.locateFaces = function (input, forwardParams) {\n            return __awaiter$1(this, void 0, void 0, function () {\n                var objectDetections;\n                return __generator$1(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.detect(input, forwardParams)];\n                        case 1:\n                            objectDetections = _a.sent();\n                            return [2 /*return*/, objectDetections.map(function (det) { return new FaceDetection(det.score, det.relativeBox, { width: det.imageWidth, height: det.imageHeight }); })];\n                    }\n                });\n            });\n        };\n        TinyFaceDetector.prototype.getDefaultModelName = function () {\n            return 'tiny_face_detector_model';\n        };\n        TinyFaceDetector.prototype.extractParamsFromWeigthMap = function (weightMap) {\n            return _super.prototype.extractParamsFromWeigthMap.call(this, weightMap);\n        };\n        return TinyFaceDetector;\n    }(TinyYolov2));\n\n    var IOU_THRESHOLD$1 = 0.4;\n    var BOX_ANCHORS$1 = [\n        new Point(0.738768, 0.874946),\n        new Point(2.42204, 2.65704),\n        new Point(4.30971, 7.04493),\n        new Point(10.246, 4.59428),\n        new Point(12.6868, 11.8741)\n    ];\n    var BOX_ANCHORS_SEPARABLE = [\n        new Point(1.603231, 2.094468),\n        new Point(6.041143, 7.080126),\n        new Point(2.882459, 3.518061),\n        new Point(4.266906, 5.178857),\n        new Point(9.041765, 10.66308)\n    ];\n    var MEAN_RGB_SEPARABLE = [117.001, 114.697, 97.404];\n    var DEFAULT_MODEL_NAME = 'tiny_yolov2_model';\n    var DEFAULT_MODEL_NAME_SEPARABLE_CONV = 'tiny_yolov2_separable_conv_model';\n\n    var TinyYolov2$1 = /** @class */ (function (_super) {\n        __extends$1(TinyYolov2, _super);\n        function TinyYolov2(withSeparableConvs) {\n            if (withSeparableConvs === void 0) { withSeparableConvs = true; }\n            var _this = this;\n            var config = Object.assign({}, {\n                withSeparableConvs: withSeparableConvs,\n                iouThreshold: IOU_THRESHOLD$1,\n                classes: ['face']\n            }, withSeparableConvs\n                ? {\n                    anchors: BOX_ANCHORS_SEPARABLE,\n                    meanRgb: MEAN_RGB_SEPARABLE\n                }\n                : {\n                    anchors: BOX_ANCHORS$1,\n                    withClassScores: true\n                });\n            _this = _super.call(this, config) || this;\n            return _this;\n        }\n        Object.defineProperty(TinyYolov2.prototype, \"withSeparableConvs\", {\n            get: function () {\n                return this.config.withSeparableConvs;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(TinyYolov2.prototype, \"anchors\", {\n            get: function () {\n                return this.config.anchors;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        TinyYolov2.prototype.locateFaces = function (input, forwardParams) {\n            return __awaiter$1(this, void 0, void 0, function () {\n                var objectDetections;\n                return __generator$1(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.detect(input, forwardParams)];\n                        case 1:\n                            objectDetections = _a.sent();\n                            return [2 /*return*/, objectDetections.map(function (det) { return new FaceDetection(det.score, det.relativeBox, { width: det.imageWidth, height: det.imageHeight }); })];\n                    }\n                });\n            });\n        };\n        TinyYolov2.prototype.getDefaultModelName = function () {\n            return this.withSeparableConvs ? DEFAULT_MODEL_NAME_SEPARABLE_CONV : DEFAULT_MODEL_NAME;\n        };\n        TinyYolov2.prototype.extractParamsFromWeigthMap = function (weightMap) {\n            return _super.prototype.extractParamsFromWeigthMap.call(this, weightMap);\n        };\n        return TinyYolov2;\n    }(TinyYolov2));\n\n    function createTinyYolov2(weights, withSeparableConvs) {\n        if (withSeparableConvs === void 0) { withSeparableConvs = true; }\n        var net = new TinyYolov2$1(withSeparableConvs);\n        net.extractWeights(weights);\n        return net;\n    }\n\n    var nets = {\n        ssdMobilenetv1: new SsdMobilenetv1(),\n        tinyFaceDetector: new TinyFaceDetector(),\n        tinyYolov2: new TinyYolov2$1(),\n        mtcnn: new Mtcnn(),\n        faceLandmark68Net: new FaceLandmark68Net(),\n        faceLandmark68TinyNet: new FaceLandmark68TinyNet(),\n        faceRecognitionNet: new FaceRecognitionNet(),\n        faceExpressionNet: new FaceExpressionNet()\n    };\n    /**\n     * Attempts to detect all faces in an image using SSD Mobilenetv1 Network.\n     *\n     * @param input The input image.\n     * @param options (optional, default: see SsdMobilenetv1Options constructor for default parameters).\n     * @returns Bounding box of each face with score.\n     */\n    var ssdMobilenetv1 = function (input, options) {\n        return nets.ssdMobilenetv1.locateFaces(input, options);\n    };\n    /**\n     * Attempts to detect all faces in an image using the Tiny Face Detector.\n     *\n     * @param input The input image.\n     * @param options (optional, default: see TinyFaceDetectorOptions constructor for default parameters).\n     * @returns Bounding box of each face with score.\n     */\n    var tinyFaceDetector = function (input, options) {\n        return nets.tinyFaceDetector.locateFaces(input, options);\n    };\n    /**\n     * Attempts to detect all faces in an image using the Tiny Yolov2 Network.\n     *\n     * @param input The input image.\n     * @param options (optional, default: see TinyYolov2Options constructor for default parameters).\n     * @returns Bounding box of each face with score.\n     */\n    var tinyYolov2 = function (input, options) {\n        return nets.tinyYolov2.locateFaces(input, options);\n    };\n    /**\n     * Attempts to detect all faces in an image and the 5 point face landmarks\n     * of each detected face using the MTCNN Network.\n     *\n     * @param input The input image.\n     * @param options (optional, default: see MtcnnOptions constructor for default parameters).\n     * @returns Bounding box of each face with score and 5 point face landmarks.\n     */\n    var mtcnn = function (input, options) {\n        return nets.mtcnn.forward(input, options);\n    };\n    /**\n     * Detects the 68 point face landmark positions of the face shown in an image.\n     *\n     * @param inputs The face image extracted from the bounding box of a face. Can\n     * also be an array of input images, which will be batch processed.\n     * @returns 68 point face landmarks or array thereof in case of batch input.\n     */\n    var detectFaceLandmarks = function (input) {\n        return nets.faceLandmark68Net.detectLandmarks(input);\n    };\n    /**\n     * Detects the 68 point face landmark positions of the face shown in an image\n     * using a tinier version of the 68 point face landmark model, which is slightly\n     * faster at inference, but also slightly less accurate.\n     *\n     * @param inputs The face image extracted from the bounding box of a face. Can\n     * also be an array of input images, which will be batch processed.\n     * @returns 68 point face landmarks or array thereof in case of batch input.\n     */\n    var detectFaceLandmarksTiny = function (input) {\n        return nets.faceLandmark68TinyNet.detectLandmarks(input);\n    };\n    /**\n     * Computes a 128 entry vector (face descriptor / face embeddings) from the face shown in an image,\n     * which uniquely represents the features of that persons face. The computed face descriptor can\n     * be used to measure the similarity between faces, by computing the euclidean distance of two\n     * face descriptors.\n     *\n     * @param inputs The face image extracted from the aligned bounding box of a face. Can\n     * also be an array of input images, which will be batch processed.\n     * @returns Face descriptor with 128 entries or array thereof in case of batch input.\n     */\n    var computeFaceDescriptor = function (input) {\n        return nets.faceRecognitionNet.computeFaceDescriptor(input);\n    };\n    /**\n     * Recognizes the facial expressions of a face and returns the likelyhood of\n     * each facial expression.\n     *\n     * @param inputs The face image extracted from the bounding box of a face. Can\n     * also be an array of input images, which will be batch processed.\n     * @returns An array of facial expressions with corresponding probabilities or array thereof in case of batch input.\n     */\n    var recognizeFaceExpressions = function (input) {\n        return nets.faceExpressionNet.predictExpressions(input);\n    };\n    var loadSsdMobilenetv1Model = function (url) { return nets.ssdMobilenetv1.load(url); };\n    var loadTinyFaceDetectorModel = function (url) { return nets.tinyFaceDetector.load(url); };\n    var loadMtcnnModel = function (url) { return nets.mtcnn.load(url); };\n    var loadTinyYolov2Model = function (url) { return nets.tinyYolov2.load(url); };\n    var loadFaceLandmarkModel = function (url) { return nets.faceLandmark68Net.load(url); };\n    var loadFaceLandmarkTinyModel = function (url) { return nets.faceLandmark68TinyNet.load(url); };\n    var loadFaceRecognitionModel = function (url) { return nets.faceRecognitionNet.load(url); };\n    var loadFaceExpressionModel = function (url) { return nets.faceExpressionNet.load(url); };\n    // backward compatibility\n    var loadFaceDetectionModel = loadSsdMobilenetv1Model;\n    var locateFaces = ssdMobilenetv1;\n    var detectLandmarks = detectFaceLandmarks;\n\n    var ComputeFaceDescriptorsTaskBase = /** @class */ (function (_super) {\n        __extends$1(ComputeFaceDescriptorsTaskBase, _super);\n        function ComputeFaceDescriptorsTaskBase(parentTask, input) {\n            var _this = _super.call(this) || this;\n            _this.parentTask = parentTask;\n            _this.input = input;\n            return _this;\n        }\n        return ComputeFaceDescriptorsTaskBase;\n    }(ComposableTask));\n    var ComputeAllFaceDescriptorsTask = /** @class */ (function (_super) {\n        __extends$1(ComputeAllFaceDescriptorsTask, _super);\n        function ComputeAllFaceDescriptorsTask() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        ComputeAllFaceDescriptorsTask.prototype.run = function () {\n            return __awaiter$1(this, void 0, void 0, function () {\n                var parentResults, alignedRects, alignedFaces, _a, results;\n                var _this = this;\n                return __generator$1(this, function (_b) {\n                    switch (_b.label) {\n                        case 0: return [4 /*yield*/, this.parentTask];\n                        case 1:\n                            parentResults = _b.sent();\n                            alignedRects = parentResults.map(function (_a) {\n                                var alignedRect = _a.alignedRect;\n                                return alignedRect;\n                            });\n                            if (!(this.input instanceof Tensor)) return [3 /*break*/, 3];\n                            return [4 /*yield*/, extractFaceTensors(this.input, alignedRects)];\n                        case 2:\n                            _a = _b.sent();\n                            return [3 /*break*/, 5];\n                        case 3: return [4 /*yield*/, extractFaces(this.input, alignedRects)];\n                        case 4:\n                            _a = _b.sent();\n                            _b.label = 5;\n                        case 5:\n                            alignedFaces = _a;\n                            return [4 /*yield*/, Promise.all(parentResults.map(function (parentResult, i) { return __awaiter$1(_this, void 0, void 0, function () {\n                                    var descriptor;\n                                    return __generator$1(this, function (_a) {\n                                        switch (_a.label) {\n                                            case 0: return [4 /*yield*/, nets.faceRecognitionNet.computeFaceDescriptor(alignedFaces[i])];\n                                            case 1:\n                                                descriptor = _a.sent();\n                                                return [2 /*return*/, extendWithFaceDescriptor(parentResult, descriptor)];\n                                        }\n                                    });\n                                }); }))];\n                        case 6:\n                            results = _b.sent();\n                            alignedFaces.forEach(function (f) { return f instanceof Tensor && f.dispose(); });\n                            return [2 /*return*/, results];\n                    }\n                });\n            });\n        };\n        return ComputeAllFaceDescriptorsTask;\n    }(ComputeFaceDescriptorsTaskBase));\n    var ComputeSingleFaceDescriptorTask = /** @class */ (function (_super) {\n        __extends$1(ComputeSingleFaceDescriptorTask, _super);\n        function ComputeSingleFaceDescriptorTask() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        ComputeSingleFaceDescriptorTask.prototype.run = function () {\n            return __awaiter$1(this, void 0, void 0, function () {\n                var parentResult, alignedRect, alignedFaces, _a, descriptor;\n                return __generator$1(this, function (_b) {\n                    switch (_b.label) {\n                        case 0: return [4 /*yield*/, this.parentTask];\n                        case 1:\n                            parentResult = _b.sent();\n                            if (!parentResult) {\n                                return [2 /*return*/];\n                            }\n                            alignedRect = parentResult.alignedRect;\n                            if (!(this.input instanceof Tensor)) return [3 /*break*/, 3];\n                            return [4 /*yield*/, extractFaceTensors(this.input, [alignedRect])];\n                        case 2:\n                            _a = _b.sent();\n                            return [3 /*break*/, 5];\n                        case 3: return [4 /*yield*/, extractFaces(this.input, [alignedRect])];\n                        case 4:\n                            _a = _b.sent();\n                            _b.label = 5;\n                        case 5:\n                            alignedFaces = _a;\n                            return [4 /*yield*/, nets.faceRecognitionNet.computeFaceDescriptor(alignedFaces[0])];\n                        case 6:\n                            descriptor = _b.sent();\n                            alignedFaces.forEach(function (f) { return f instanceof Tensor && f.dispose(); });\n                            return [2 /*return*/, extendWithFaceDescriptor(parentResult, descriptor)];\n                    }\n                });\n            });\n        };\n        return ComputeSingleFaceDescriptorTask;\n    }(ComputeFaceDescriptorsTaskBase));\n\n    var DetectFaceLandmarksTaskBase = /** @class */ (function (_super) {\n        __extends$1(DetectFaceLandmarksTaskBase, _super);\n        function DetectFaceLandmarksTaskBase(parentTask, input, useTinyLandmarkNet) {\n            var _this = _super.call(this) || this;\n            _this.parentTask = parentTask;\n            _this.input = input;\n            _this.useTinyLandmarkNet = useTinyLandmarkNet;\n            return _this;\n        }\n        Object.defineProperty(DetectFaceLandmarksTaskBase.prototype, \"landmarkNet\", {\n            get: function () {\n                return this.useTinyLandmarkNet\n                    ? nets.faceLandmark68TinyNet\n                    : nets.faceLandmark68Net;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return DetectFaceLandmarksTaskBase;\n    }(ComposableTask));\n    var DetectAllFaceLandmarksTask = /** @class */ (function (_super) {\n        __extends$1(DetectAllFaceLandmarksTask, _super);\n        function DetectAllFaceLandmarksTask() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        DetectAllFaceLandmarksTask.prototype.run = function () {\n            return __awaiter$1(this, void 0, void 0, function () {\n                var parentResults, detections, faces, _a, faceLandmarksByFace;\n                var _this = this;\n                return __generator$1(this, function (_b) {\n                    switch (_b.label) {\n                        case 0: return [4 /*yield*/, this.parentTask];\n                        case 1:\n                            parentResults = _b.sent();\n                            detections = parentResults.map(function (res) { return res.detection; });\n                            if (!(this.input instanceof Tensor)) return [3 /*break*/, 3];\n                            return [4 /*yield*/, extractFaceTensors(this.input, detections)];\n                        case 2:\n                            _a = _b.sent();\n                            return [3 /*break*/, 5];\n                        case 3: return [4 /*yield*/, extractFaces(this.input, detections)];\n                        case 4:\n                            _a = _b.sent();\n                            _b.label = 5;\n                        case 5:\n                            faces = _a;\n                            return [4 /*yield*/, Promise.all(faces.map(function (face) { return _this.landmarkNet.detectLandmarks(face); }))];\n                        case 6:\n                            faceLandmarksByFace = _b.sent();\n                            faces.forEach(function (f) { return f instanceof Tensor && f.dispose(); });\n                            return [2 /*return*/, parentResults.map(function (parentResult, i) {\n                                    return extendWithFaceLandmarks(parentResult, faceLandmarksByFace[i]);\n                                })];\n                    }\n                });\n            });\n        };\n        DetectAllFaceLandmarksTask.prototype.withFaceDescriptors = function () {\n            return new ComputeAllFaceDescriptorsTask(this, this.input);\n        };\n        return DetectAllFaceLandmarksTask;\n    }(DetectFaceLandmarksTaskBase));\n    var DetectSingleFaceLandmarksTask = /** @class */ (function (_super) {\n        __extends$1(DetectSingleFaceLandmarksTask, _super);\n        function DetectSingleFaceLandmarksTask() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        DetectSingleFaceLandmarksTask.prototype.run = function () {\n            return __awaiter$1(this, void 0, void 0, function () {\n                var parentResult, detection, faces, _a, landmarks;\n                return __generator$1(this, function (_b) {\n                    switch (_b.label) {\n                        case 0: return [4 /*yield*/, this.parentTask];\n                        case 1:\n                            parentResult = _b.sent();\n                            if (!parentResult) {\n                                return [2 /*return*/];\n                            }\n                            detection = parentResult.detection;\n                            if (!(this.input instanceof Tensor)) return [3 /*break*/, 3];\n                            return [4 /*yield*/, extractFaceTensors(this.input, [detection])];\n                        case 2:\n                            _a = _b.sent();\n                            return [3 /*break*/, 5];\n                        case 3: return [4 /*yield*/, extractFaces(this.input, [detection])];\n                        case 4:\n                            _a = _b.sent();\n                            _b.label = 5;\n                        case 5:\n                            faces = _a;\n                            return [4 /*yield*/, this.landmarkNet.detectLandmarks(faces[0])];\n                        case 6:\n                            landmarks = _b.sent();\n                            faces.forEach(function (f) { return f instanceof Tensor && f.dispose(); });\n                            return [2 /*return*/, extendWithFaceLandmarks(parentResult, landmarks)];\n                    }\n                });\n            });\n        };\n        DetectSingleFaceLandmarksTask.prototype.withFaceDescriptor = function () {\n            return new ComputeSingleFaceDescriptorTask(this, this.input);\n        };\n        return DetectSingleFaceLandmarksTask;\n    }(DetectFaceLandmarksTaskBase));\n\n    var PredictFaceExpressionsTaskBase = /** @class */ (function (_super) {\n        __extends$1(PredictFaceExpressionsTaskBase, _super);\n        function PredictFaceExpressionsTaskBase(parentTask, input) {\n            var _this = _super.call(this) || this;\n            _this.parentTask = parentTask;\n            _this.input = input;\n            return _this;\n        }\n        return PredictFaceExpressionsTaskBase;\n    }(ComposableTask));\n    var PredictAllFaceExpressionsTask = /** @class */ (function (_super) {\n        __extends$1(PredictAllFaceExpressionsTask, _super);\n        function PredictAllFaceExpressionsTask() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        PredictAllFaceExpressionsTask.prototype.run = function () {\n            return __awaiter$1(this, void 0, void 0, function () {\n                var parentResults, detections, faces, _a, faceExpressionsByFace;\n                return __generator$1(this, function (_b) {\n                    switch (_b.label) {\n                        case 0: return [4 /*yield*/, this.parentTask];\n                        case 1:\n                            parentResults = _b.sent();\n                            detections = parentResults.map(function (parentResult) { return parentResult.detection; });\n                            if (!(this.input instanceof Tensor)) return [3 /*break*/, 3];\n                            return [4 /*yield*/, extractFaceTensors(this.input, detections)];\n                        case 2:\n                            _a = _b.sent();\n                            return [3 /*break*/, 5];\n                        case 3: return [4 /*yield*/, extractFaces(this.input, detections)];\n                        case 4:\n                            _a = _b.sent();\n                            _b.label = 5;\n                        case 5:\n                            faces = _a;\n                            return [4 /*yield*/, Promise.all(faces.map(function (face) { return nets.faceExpressionNet.predictExpressions(face); }))];\n                        case 6:\n                            faceExpressionsByFace = _b.sent();\n                            faces.forEach(function (f) { return f instanceof Tensor && f.dispose(); });\n                            return [2 /*return*/, parentResults.map(function (parentResult, i) { return extendWithFaceExpressions(parentResult, faceExpressionsByFace[i]); })];\n                    }\n                });\n            });\n        };\n        PredictAllFaceExpressionsTask.prototype.withFaceLandmarks = function () {\n            return new DetectAllFaceLandmarksTask(this, this.input, false);\n        };\n        return PredictAllFaceExpressionsTask;\n    }(PredictFaceExpressionsTaskBase));\n    var PredictSingleFaceExpressionTask = /** @class */ (function (_super) {\n        __extends$1(PredictSingleFaceExpressionTask, _super);\n        function PredictSingleFaceExpressionTask() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        PredictSingleFaceExpressionTask.prototype.run = function () {\n            return __awaiter$1(this, void 0, void 0, function () {\n                var parentResult, detection, faces, _a, faceExpressions;\n                return __generator$1(this, function (_b) {\n                    switch (_b.label) {\n                        case 0: return [4 /*yield*/, this.parentTask];\n                        case 1:\n                            parentResult = _b.sent();\n                            if (!parentResult) {\n                                return [2 /*return*/];\n                            }\n                            detection = parentResult.detection;\n                            if (!(this.input instanceof Tensor)) return [3 /*break*/, 3];\n                            return [4 /*yield*/, extractFaceTensors(this.input, [detection])];\n                        case 2:\n                            _a = _b.sent();\n                            return [3 /*break*/, 5];\n                        case 3: return [4 /*yield*/, extractFaces(this.input, [detection])];\n                        case 4:\n                            _a = _b.sent();\n                            _b.label = 5;\n                        case 5:\n                            faces = _a;\n                            return [4 /*yield*/, nets.faceExpressionNet.predictExpressions(faces[0])];\n                        case 6:\n                            faceExpressions = _b.sent();\n                            faces.forEach(function (f) { return f instanceof Tensor && f.dispose(); });\n                            return [2 /*return*/, extendWithFaceExpressions(parentResult, faceExpressions)];\n                    }\n                });\n            });\n        };\n        PredictSingleFaceExpressionTask.prototype.withFaceLandmarks = function () {\n            return new DetectSingleFaceLandmarksTask(this, this.input, false);\n        };\n        return PredictSingleFaceExpressionTask;\n    }(PredictFaceExpressionsTaskBase));\n\n    var DetectFacesTaskBase = /** @class */ (function (_super) {\n        __extends$1(DetectFacesTaskBase, _super);\n        function DetectFacesTaskBase(input, options) {\n            if (options === void 0) { options = new SsdMobilenetv1Options(); }\n            var _this = _super.call(this) || this;\n            _this.input = input;\n            _this.options = options;\n            return _this;\n        }\n        return DetectFacesTaskBase;\n    }(ComposableTask));\n    var DetectAllFacesTask = /** @class */ (function (_super) {\n        __extends$1(DetectAllFacesTask, _super);\n        function DetectAllFacesTask() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        DetectAllFacesTask.prototype.run = function () {\n            return __awaiter$1(this, void 0, void 0, function () {\n                var _a, input, options, faceDetectionFunction;\n                return __generator$1(this, function (_b) {\n                    switch (_b.label) {\n                        case 0:\n                            _a = this, input = _a.input, options = _a.options;\n                            if (!(options instanceof MtcnnOptions)) return [3 /*break*/, 2];\n                            return [4 /*yield*/, nets.mtcnn.forward(input, options)];\n                        case 1: return [2 /*return*/, (_b.sent())\n                                .map(function (result) { return result.detection; })];\n                        case 2:\n                            faceDetectionFunction = options instanceof TinyFaceDetectorOptions\n                                ? function (input) { return nets.tinyFaceDetector.locateFaces(input, options); }\n                                : (options instanceof SsdMobilenetv1Options\n                                    ? function (input) { return nets.ssdMobilenetv1.locateFaces(input, options); }\n                                    : (options instanceof TinyYolov2Options\n                                        ? function (input) { return nets.tinyYolov2.locateFaces(input, options); }\n                                        : null));\n                            if (!faceDetectionFunction) {\n                                throw new Error('detectFaces - expected options to be instance of TinyFaceDetectorOptions | SsdMobilenetv1Options | MtcnnOptions | TinyYolov2Options');\n                            }\n                            return [2 /*return*/, faceDetectionFunction(input)];\n                    }\n                });\n            });\n        };\n        DetectAllFacesTask.prototype.runAndExtendWithFaceDetections = function () {\n            var _this = this;\n            return new Promise(function (res) { return __awaiter$1(_this, void 0, void 0, function () {\n                var detections;\n                return __generator$1(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.run()];\n                        case 1:\n                            detections = _a.sent();\n                            return [2 /*return*/, res(detections.map(function (detection) { return extendWithFaceDetection({}, detection); }))];\n                    }\n                });\n            }); });\n        };\n        DetectAllFacesTask.prototype.withFaceLandmarks = function (useTinyLandmarkNet) {\n            if (useTinyLandmarkNet === void 0) { useTinyLandmarkNet = false; }\n            return new DetectAllFaceLandmarksTask(this.runAndExtendWithFaceDetections(), this.input, useTinyLandmarkNet);\n        };\n        DetectAllFacesTask.prototype.withFaceExpressions = function () {\n            return new PredictAllFaceExpressionsTask(this.runAndExtendWithFaceDetections(), this.input);\n        };\n        return DetectAllFacesTask;\n    }(DetectFacesTaskBase));\n    var DetectSingleFaceTask = /** @class */ (function (_super) {\n        __extends$1(DetectSingleFaceTask, _super);\n        function DetectSingleFaceTask() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        DetectSingleFaceTask.prototype.run = function () {\n            return __awaiter$1(this, void 0, void 0, function () {\n                var faceDetections, faceDetectionWithHighestScore;\n                return __generator$1(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, new DetectAllFacesTask(this.input, this.options)];\n                        case 1:\n                            faceDetections = _a.sent();\n                            faceDetectionWithHighestScore = faceDetections[0];\n                            faceDetections.forEach(function (faceDetection) {\n                                if (faceDetection.score > faceDetectionWithHighestScore.score) {\n                                    faceDetectionWithHighestScore = faceDetection;\n                                }\n                            });\n                            return [2 /*return*/, faceDetectionWithHighestScore];\n                    }\n                });\n            });\n        };\n        DetectSingleFaceTask.prototype.runAndExtendWithFaceDetection = function () {\n            var _this = this;\n            return new Promise(function (res) { return __awaiter$1(_this, void 0, void 0, function () {\n                var detection;\n                return __generator$1(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.run()];\n                        case 1:\n                            detection = _a.sent();\n                            return [2 /*return*/, res(detection ? extendWithFaceDetection({}, detection) : undefined)];\n                    }\n                });\n            }); });\n        };\n        DetectSingleFaceTask.prototype.withFaceLandmarks = function (useTinyLandmarkNet) {\n            if (useTinyLandmarkNet === void 0) { useTinyLandmarkNet = false; }\n            return new DetectSingleFaceLandmarksTask(this.runAndExtendWithFaceDetection(), this.input, useTinyLandmarkNet);\n        };\n        DetectSingleFaceTask.prototype.withFaceExpressions = function () {\n            return new PredictSingleFaceExpressionTask(this.runAndExtendWithFaceDetection(), this.input);\n        };\n        return DetectSingleFaceTask;\n    }(DetectFacesTaskBase));\n\n    function detectSingleFace(input, options) {\n        if (options === void 0) { options = new SsdMobilenetv1Options(); }\n        return new DetectSingleFaceTask(input, options);\n    }\n    function detectAllFaces(input, options) {\n        if (options === void 0) { options = new SsdMobilenetv1Options(); }\n        return new DetectAllFacesTask(input, options);\n    }\n\n    // export allFaces API for backward compatibility\n    function allFacesSsdMobilenetv1(input, minConfidence) {\n        return __awaiter$1(this, void 0, void 0, function () {\n            return __generator$1(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, detectAllFaces(input, new SsdMobilenetv1Options(minConfidence ? { minConfidence: minConfidence } : {}))\n                            .withFaceLandmarks()\n                            .withFaceDescriptors()];\n                    case 1: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    }\n    function allFacesTinyYolov2(input, forwardParams) {\n        if (forwardParams === void 0) { forwardParams = {}; }\n        return __awaiter$1(this, void 0, void 0, function () {\n            return __generator$1(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, detectAllFaces(input, new TinyYolov2Options(forwardParams))\n                            .withFaceLandmarks()\n                            .withFaceDescriptors()];\n                    case 1: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    }\n    function allFacesMtcnn(input, forwardParams) {\n        if (forwardParams === void 0) { forwardParams = {}; }\n        return __awaiter$1(this, void 0, void 0, function () {\n            return __generator$1(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, detectAllFaces(input, new MtcnnOptions(forwardParams))\n                            .withFaceLandmarks()\n                            .withFaceDescriptors()];\n                    case 1: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    }\n    var allFaces = allFacesSsdMobilenetv1;\n\n    function euclideanDistance(arr1, arr2) {\n        if (arr1.length !== arr2.length)\n            throw new Error('euclideanDistance: arr1.length !== arr2.length');\n        var desc1 = Array.from(arr1);\n        var desc2 = Array.from(arr2);\n        return Math.sqrt(desc1\n            .map(function (val, i) { return val - desc2[i]; })\n            .reduce(function (res, diff) { return res + Math.pow(diff, 2); }, 0));\n    }\n\n    var FaceMatcher = /** @class */ (function () {\n        function FaceMatcher(inputs, distanceThreshold) {\n            if (distanceThreshold === void 0) { distanceThreshold = 0.6; }\n            this._distanceThreshold = distanceThreshold;\n            var inputArray = Array.isArray(inputs) ? inputs : [inputs];\n            if (!inputArray.length) {\n                throw new Error(\"FaceRecognizer.constructor - expected atleast one input\");\n            }\n            var count = 1;\n            var createUniqueLabel = function () { return \"person \" + count++; };\n            this._labeledDescriptors = inputArray.map(function (desc) {\n                if (desc instanceof LabeledFaceDescriptors) {\n                    return desc;\n                }\n                if (desc instanceof Float32Array) {\n                    return new LabeledFaceDescriptors(createUniqueLabel(), [desc]);\n                }\n                if (desc.descriptor && desc.descriptor instanceof Float32Array) {\n                    return new LabeledFaceDescriptors(createUniqueLabel(), [desc.descriptor]);\n                }\n                throw new Error(\"FaceRecognizer.constructor - expected inputs to be of type LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array | Array<LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array>\");\n            });\n        }\n        Object.defineProperty(FaceMatcher.prototype, \"labeledDescriptors\", {\n            get: function () { return this._labeledDescriptors; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FaceMatcher.prototype, \"distanceThreshold\", {\n            get: function () { return this._distanceThreshold; },\n            enumerable: true,\n            configurable: true\n        });\n        FaceMatcher.prototype.computeMeanDistance = function (queryDescriptor, descriptors) {\n            return descriptors\n                .map(function (d) { return euclideanDistance(d, queryDescriptor); })\n                .reduce(function (d1, d2) { return d1 + d2; }, 0)\n                / (descriptors.length || 1);\n        };\n        FaceMatcher.prototype.matchDescriptor = function (queryDescriptor) {\n            var _this = this;\n            return this.labeledDescriptors\n                .map(function (_a) {\n                var descriptors = _a.descriptors, label = _a.label;\n                return new FaceMatch(label, _this.computeMeanDistance(queryDescriptor, descriptors));\n            })\n                .reduce(function (best, curr) { return best.distance < curr.distance ? best : curr; });\n        };\n        FaceMatcher.prototype.findBestMatch = function (queryDescriptor) {\n            var bestMatch = this.matchDescriptor(queryDescriptor);\n            return bestMatch.distance < this.distanceThreshold\n                ? bestMatch\n                : new FaceMatch('unknown', bestMatch.distance);\n        };\n        return FaceMatcher;\n    }());\n\n    function createMtcnn(weights) {\n        var net = new Mtcnn();\n        net.extractWeights(weights);\n        return net;\n    }\n\n    function createTinyFaceDetector(weights) {\n        var net = new TinyFaceDetector();\n        net.extractWeights(weights);\n        return net;\n    }\n\n    function resizeResults(results, _a) {\n        var width = _a.width, height = _a.height;\n        if (Array.isArray(results)) {\n            return results.map(function (obj) { return resizeResults(obj, { width: width, height: height }); });\n        }\n        var hasLandmarks = results['unshiftedLandmarks'] && results['unshiftedLandmarks'] instanceof FaceLandmarks;\n        var hasDetection = results['detection'] && results['detection'] instanceof FaceDetection;\n        if (hasLandmarks) {\n            var resizedDetection = results['detection'].forSize(width, height);\n            var resizedLandmarks = results['unshiftedLandmarks'].forSize(resizedDetection.box.width, resizedDetection.box.height);\n            return extendWithFaceLandmarks(extendWithFaceDetection(results, resizedDetection), resizedLandmarks);\n        }\n        if (hasDetection) {\n            return extendWithFaceDetection(results, results['detection'].forSize(width, height));\n        }\n        if (results instanceof FaceLandmarks || results instanceof FaceDetection) {\n            return results.forSize(width, height);\n        }\n        return results;\n    }\n\n    exports.tf = tfCore_esm;\n    exports.TfjsImageRecognitionBase = tfjsImageRecognitionBase;\n    exports.BoundingBox = BoundingBox;\n    exports.Box = Box;\n    exports.BoxWithText = BoxWithText;\n    exports.Dimensions = Dimensions;\n    exports.LabeledBox = LabeledBox;\n    exports.ObjectDetection = ObjectDetection;\n    exports.Point = Point;\n    exports.PredictedBox = PredictedBox;\n    exports.Rect = Rect;\n    exports.awaitMediaLoaded = awaitMediaLoaded;\n    exports.bufferToImage = bufferToImage;\n    exports.createCanvas = createCanvas;\n    exports.createCanvasFromMedia = createCanvasFromMedia;\n    exports.drawBox = drawBox;\n    exports.drawDetection = drawDetection;\n    exports.drawText = drawText;\n    exports.fetchImage = fetchImage;\n    exports.fetchJson = fetchJson;\n    exports.fetchNetWeights = fetchNetWeights;\n    exports.fetchOrThrow = fetchOrThrow;\n    exports.getContext2dOrThrow = getContext2dOrThrow;\n    exports.getDefaultDrawOptions = getDefaultDrawOptions;\n    exports.getMediaDimensions = getMediaDimensions;\n    exports.imageTensorToCanvas = imageTensorToCanvas;\n    exports.imageToSquare = imageToSquare;\n    exports.isMediaElement = isMediaElement;\n    exports.isMediaLoaded = isMediaLoaded;\n    exports.loadWeightMap = loadWeightMap;\n    exports.NetInput = NetInput;\n    exports.resolveInput = resolveInput;\n    exports.toNetInput = toNetInput;\n    exports.env = env;\n    exports.sigmoid = sigmoid$1;\n    exports.inverseSigmoid = inverseSigmoid;\n    exports.iou = iou;\n    exports.nonMaxSuppression = nonMaxSuppression$1;\n    exports.normalize = normalize;\n    exports.padToSquare = padToSquare;\n    exports.shuffleArray = shuffleArray;\n    exports.isTensor = isTensor;\n    exports.isTensor1D = isTensor1D;\n    exports.isTensor2D = isTensor2D;\n    exports.isTensor3D = isTensor3D;\n    exports.isTensor4D = isTensor4D;\n    exports.isFloat = isFloat;\n    exports.isEven = isEven$1;\n    exports.round = round$1;\n    exports.isDimensions = isDimensions;\n    exports.computeReshapedDimensions = computeReshapedDimensions;\n    exports.getCenterPoint = getCenterPoint;\n    exports.range = range$1;\n    exports.isValidNumber = isValidNumber;\n    exports.isValidProbablitiy = isValidProbablitiy;\n    exports.NeuralNetwork = NeuralNetwork;\n    exports.FaceDetection = FaceDetection;\n    exports.FaceLandmarks = FaceLandmarks;\n    exports.FaceLandmarks5 = FaceLandmarks5;\n    exports.FaceLandmarks68 = FaceLandmarks68;\n    exports.FaceMatch = FaceMatch;\n    exports.LabeledFaceDescriptors = LabeledFaceDescriptors;\n    exports.drawContour = drawContour;\n    exports.drawLandmarks = drawLandmarks;\n    exports.drawFaceExpressions = drawFaceExpressions;\n    exports.extractFaces = extractFaces;\n    exports.extractFaceTensors = extractFaceTensors;\n    exports.FaceExpressionNet = FaceExpressionNet;\n    exports.faceExpressionLabels = faceExpressionLabels;\n    exports.FaceLandmarkNet = FaceLandmarkNet;\n    exports.FaceLandmark68Net = FaceLandmark68Net;\n    exports.FaceLandmark68TinyNet = FaceLandmark68TinyNet;\n    exports.createFaceRecognitionNet = createFaceRecognitionNet;\n    exports.FaceRecognitionNet = FaceRecognitionNet;\n    exports.extendWithFaceDescriptor = extendWithFaceDescriptor;\n    exports.extendWithFaceDetection = extendWithFaceDetection;\n    exports.extendWithFaceExpressions = extendWithFaceExpressions;\n    exports.extendWithFaceLandmarks = extendWithFaceLandmarks;\n    exports.allFacesSsdMobilenetv1 = allFacesSsdMobilenetv1;\n    exports.allFacesTinyYolov2 = allFacesTinyYolov2;\n    exports.allFacesMtcnn = allFacesMtcnn;\n    exports.allFaces = allFaces;\n    exports.ComposableTask = ComposableTask;\n    exports.ComputeFaceDescriptorsTaskBase = ComputeFaceDescriptorsTaskBase;\n    exports.ComputeAllFaceDescriptorsTask = ComputeAllFaceDescriptorsTask;\n    exports.ComputeSingleFaceDescriptorTask = ComputeSingleFaceDescriptorTask;\n    exports.detectSingleFace = detectSingleFace;\n    exports.detectAllFaces = detectAllFaces;\n    exports.DetectFacesTaskBase = DetectFacesTaskBase;\n    exports.DetectAllFacesTask = DetectAllFacesTask;\n    exports.DetectSingleFaceTask = DetectSingleFaceTask;\n    exports.DetectFaceLandmarksTaskBase = DetectFaceLandmarksTaskBase;\n    exports.DetectAllFaceLandmarksTask = DetectAllFaceLandmarksTask;\n    exports.DetectSingleFaceLandmarksTask = DetectSingleFaceLandmarksTask;\n    exports.FaceMatcher = FaceMatcher;\n    exports.nets = nets;\n    exports.ssdMobilenetv1 = ssdMobilenetv1;\n    exports.tinyFaceDetector = tinyFaceDetector;\n    exports.tinyYolov2 = tinyYolov2;\n    exports.mtcnn = mtcnn;\n    exports.detectFaceLandmarks = detectFaceLandmarks;\n    exports.detectFaceLandmarksTiny = detectFaceLandmarksTiny;\n    exports.computeFaceDescriptor = computeFaceDescriptor;\n    exports.recognizeFaceExpressions = recognizeFaceExpressions;\n    exports.loadSsdMobilenetv1Model = loadSsdMobilenetv1Model;\n    exports.loadTinyFaceDetectorModel = loadTinyFaceDetectorModel;\n    exports.loadMtcnnModel = loadMtcnnModel;\n    exports.loadTinyYolov2Model = loadTinyYolov2Model;\n    exports.loadFaceLandmarkModel = loadFaceLandmarkModel;\n    exports.loadFaceLandmarkTinyModel = loadFaceLandmarkTinyModel;\n    exports.loadFaceRecognitionModel = loadFaceRecognitionModel;\n    exports.loadFaceExpressionModel = loadFaceExpressionModel;\n    exports.loadFaceDetectionModel = loadFaceDetectionModel;\n    exports.locateFaces = locateFaces;\n    exports.detectLandmarks = detectLandmarks;\n    exports.createMtcnn = createMtcnn;\n    exports.Mtcnn = Mtcnn;\n    exports.MtcnnOptions = MtcnnOptions;\n    exports.createSsdMobilenetv1 = createSsdMobilenetv1;\n    exports.createFaceDetectionNet = createFaceDetectionNet;\n    exports.FaceDetectionNet = FaceDetectionNet;\n    exports.SsdMobilenetv1 = SsdMobilenetv1;\n    exports.SsdMobilenetv1Options = SsdMobilenetv1Options;\n    exports.createTinyFaceDetector = createTinyFaceDetector;\n    exports.TinyFaceDetector = TinyFaceDetector;\n    exports.TinyFaceDetectorOptions = TinyFaceDetectorOptions;\n    exports.TinyYolov2 = TinyYolov2$1;\n    exports.createTinyYolov2 = createTinyYolov2;\n    exports.euclideanDistance = euclideanDistance;\n    exports.resizeResults = resizeResults;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=face-api.js.map","const SSD_MOBILENETV1 = 'ssd_mobilenetv1'\nconst TINY_FACE_DETECTOR = 'tiny_face_detector'\nconst MTCNN = 'mtcnn'\n\n\nlet selectedFaceDetector = SSD_MOBILENETV1\n\n// ssd_mobilenetv1 options\nlet minConfidence = 0.5\n\n// tiny_face_detector options\nlet inputSize = 512\nlet scoreThreshold = 0.5\n\n//mtcnn options\nlet minFaceSize = 20\n\nfunction getFaceDetectorOptions() {\n  return selectedFaceDetector === SSD_MOBILENETV1\n    ? new faceapi.SsdMobilenetv1Options({ minConfidence })\n    : (\n      selectedFaceDetector === TINY_FACE_DETECTOR\n        ? new faceapi.TinyFaceDetectorOptions({ inputSize, scoreThreshold })\n        : new faceapi.MtcnnOptions({ minFaceSize })\n    )\n}\n\nfunction onIncreaseMinConfidence() {\n  minConfidence = Math.min(faceapi.round(minConfidence + 0.1), 1.0)\n  $('#minConfidence').val(minConfidence)\n  updateResults()\n}\n\nfunction onDecreaseMinConfidence() {\n  minConfidence = Math.max(faceapi.round(minConfidence - 0.1), 0.1)\n  $('#minConfidence').val(minConfidence)\n  updateResults()\n}\n\nfunction onInputSizeChanged(e) {\n  changeInputSize(e.target.value)\n  updateResults()\n}\n\nfunction changeInputSize(size) {\n  inputSize = parseInt(size)\n\n  const inputSizeSelect = $('#inputSize')\n  inputSizeSelect.val(inputSize)\n  inputSizeSelect.material_select()\n}\n\nfunction onIncreaseScoreThreshold() {\n  scoreThreshold = Math.min(faceapi.round(scoreThreshold + 0.1), 1.0)\n  $('#scoreThreshold').val(scoreThreshold)\n  updateResults()\n}\n\nfunction onDecreaseScoreThreshold() {\n  scoreThreshold = Math.max(faceapi.round(scoreThreshold - 0.1), 0.1)\n  $('#scoreThreshold').val(scoreThreshold)\n  updateResults()\n}\n\nfunction onIncreaseMinFaceSize() {\n  minFaceSize = Math.min(faceapi.round(minFaceSize + 20), 300)\n  $('#minFaceSize').val(minFaceSize)\n}\n\nfunction onDecreaseMinFaceSize() {\n  minFaceSize = Math.max(faceapi.round(minFaceSize - 20), 50)\n  $('#minFaceSize').val(minFaceSize)\n}\n\nfunction getCurrentFaceDetectionNet() {\n  if (selectedFaceDetector === SSD_MOBILENETV1) {\n    return faceapi.nets.ssdMobilenetv1\n  }\n  if (selectedFaceDetector === TINY_FACE_DETECTOR) {\n    return faceapi.nets.tinyFaceDetector\n  }\n  if (selectedFaceDetector === MTCNN) {\n    return faceapi.nets.mtcnn\n  }\n}\n\nfunction isFaceDetectionModelLoaded() {\n  return !!getCurrentFaceDetectionNet().params\n}\n\nasync function changeFaceDetector(detector) {\n  ['#ssd_mobilenetv1_controls', '#tiny_face_detector_controls', '#mtcnn_controls']\n    .forEach(id => $(id).hide())\n\n  selectedFaceDetector = detector\n  const faceDetectorSelect = $('#selectFaceDetector')\n  faceDetectorSelect.val(detector)\n  faceDetectorSelect.material_select()\n\n  $('#loader').show()\n  if (!isFaceDetectionModelLoaded()) {\n    await getCurrentFaceDetectionNet().load('/')\n  }\n\n  $(`#${detector}_controls`).show()\n  $('#loader').hide()\n}\n\nasync function onSelectedFaceDetectorChanged(e) {\n  selectedFaceDetector = e.target.value\n\n  await changeFaceDetector(e.target.value)\n  updateResults()\n}\n\nfunction initFaceDetectionControls() {\n  const faceDetectorSelect = $('#selectFaceDetector')\n  faceDetectorSelect.val(selectedFaceDetector)\n  faceDetectorSelect.on('change', onSelectedFaceDetectorChanged)\n  faceDetectorSelect.material_select()\n\n  const inputSizeSelect = $('#inputSize')\n  inputSizeSelect.val(inputSize)\n  inputSizeSelect.on('change', onInputSizeChanged)\n  inputSizeSelect.material_select()\n}"],"sourceRoot":""}